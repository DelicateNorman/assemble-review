# 汇编语言程序设计期末考试试题（二）- 标准答案

**考试时间：** 120分钟
**总分：** 100分

---

## 一、单选题（10道题，每题2分，共20分）

1. **(D)** SS（堆栈段寄存器）用于存放堆栈段的基地址。
2. **(D)** SUB [BX], 1234H是合法指令，其他指令都有语法错误。
3. **(C)** 7FFFH - 8000H = FFFFH，有溢出（OF=1），无借位（CF=0）。
4. **(B)** STOSW将AX的内容传送到ES:[DI]指向的字单元。
5. **(C)** DD伪指令用于定义双字变量（4字节）。
6. **(C)** JMP FAR PTR label是段间转移，转移范围最大（1MB空间）。
7. **(A)** MUL BL执行字节乘法，乘积存放在AX中。
8. **(B)** .MODEL TINY定义微型模型，用于创建COM程序。
9. **(A)** CLD指令清除DF标志位，使串操作地址递增。
10. **(A)** RET 4从堆栈弹出返回地址后，SP再加4，用于清除堆栈参数。

---

## 二、填空题（10个，每空2分，共20分）

1. 1，FFFFF
2. 目标地址，CX
3. 溢出，符号
4. 符号常量，当前地址
5. 0，1
6. ES:[DI]，标志位
7. 多（或可变），属性
8. 显示字符串，程序结束返回DOS
9. 顺序，执行
10. 地址，类型

---

## 三、指令正确与错误判断题（5条指令，每条2分，共10分）

1. `MOV [1000H], 1234H`
   - 判断：**错误**
   - 错误原因：立即数1234H是16位，而存储器操作数[1000H]没有指定类型，汇编器无法确定是字节操作还是字操作。应改为MOV WORD PTR [1000H], 1234H或MOV BYTE PTR [1000H], 12H。

2. `ADD AL, BX`
   - 判断：**错误**
   - 错误原因：操作数类型不匹配，AL是8位寄存器，BX是16位寄存器。8086不允许8位和16位寄存器直接进行运算。

3. `PUSH CS`
   - 判断：**正确**
   - 错误原因：无错误，CS寄存器可以压栈操作。

4. `JMP WORD PTR [BX]`
   - 判断：**正确**
   - 错误原因：无错误，这是合法的寄存器间接寻址段内转移指令。

5. `DIV BL, AL`
   - 判断：**错误**
   - 错误原因：DIV指令只有一个操作数，格式为DIV src（被除数在AL或AX中）。应该为DIV BL，此时AL为被除数，BL为除数。

---

## 四、简答题（2题，每题8分，共16分）

### 1. 请简述8086CPU的存储器分段管理机制，包括段地址、偏移地址和物理地址的关系。

**答案：**

**8086存储器分段管理机制：**

**（1）分段的概念：**
- 8086CPU将1MB存储空间分成多个逻辑段，每个段最大64KB
- 段地址必须从16的倍数开始（低4位为0）
- 段的起始地址高16位存放在段寄存器中

**（2）地址类型：**
- **段地址**：段的起始地址的高16位，存放在段寄存器（CS、DS、SS、ES）中
- **偏移地址**：存储单元相对于段起始地址的偏移量，16位，范围0-65535
- **物理地址**：存储单元在存储器中的实际20位地址，范围00000H-FFFFFH

**（3）地址转换关系：**
```
物理地址 = 段地址 × 16 + 偏移地址
```
- 段地址左移4位（相当于乘以16）
- 加上16位偏移地址
- 得到20位物理地址

**（4）逻辑地址表示：**
- 逻辑地址格式：段地址:偏移地址
- 例如：1234H:5678H表示段地址为1234H，偏移地址为5678H
- 物理地址 = 12340H + 5678H = 179B8H

**（5）特点：**
- 一个物理地址可以有多个逻辑地址表示
- 每个段不超过64KB
- 段与段可以重叠
- 便于程序的模块化设计和内存管理

### 2. 请简述子程序参数传递的常用方法，并比较各种方法的优缺点。

**答案：**

**子程序参数传递的常用方法有三种：**

**（1）寄存器传递法：**
- **方法**：将参数存放在约定的寄存器中传递给子程序
- **优点**：
  - 速度快，无需访问内存
  - 实现简单，编程方便
  - 适合传递少量参数
- **缺点**：
  - 寄存器数量有限，传递参数数量受限
  - 寄存器容易被其他操作覆盖，需要保护
  - 不适合传递大量数据或数组

**（2）变量传递法：**
- **方法**：主程序和子程序共享同一个变量，直接访问变量传递参数
- **优点**：
  - 直观易懂，编程简单
  - 可以传递大量数据
  - 适合在不同模块间传递参数
- **缺点**：
  - 需要占用固定的内存空间
  - 缺乏灵活性，变量名固定
  - 多个子程序使用时可能产生冲突

**（3）堆栈传递法：**
- **方法**：主程序将参数压入堆栈，子程序从堆栈中取出参数
- **优点**：
  - 参数数量灵活，不受寄存器限制
  - 不占用固定内存空间
  - 支持递归调用
  - 参数传递规范，便于模块化设计
- **缺点**：
  - 需要精确计算堆栈偏移量
  - 速度相对较慢，需要访问内存
  - 容易出现堆栈不平衡错误
  - 编程复杂度较高

**（4）比较总结：**
- **速度**：寄存器 > 变量 > 堆栈
- **灵活性**：堆栈 > 变量 > 寄存器
- **安全性**：堆栈 > 寄存器 > 变量
- **适用场景**：
  - 少量参数：寄存器传递
  - 固定参数：变量传递
  - 大量或可变参数：堆栈传递

---

## 五、程序阅读题（4段代码，每题5分，共20分）

### 1. 字符串查找程序

**填空答案：**
- lea si, string
- mov al, char
- mov count, bx

**代码段作用：**
该程序段统计字符串string中字符't'出现的次数，并将结果保存在count变量中。程序使用SCASB指令逐个字符比较，找到匹配字符则计数器加1。

### 2. 数据排序程序

**填空答案：**
- 无需填空（代码完整）

**代码段作用：**
该程序段实现对数组array的升序排序功能。使用冒泡排序算法，通过相邻元素比较和交换，将数组元素从小到大排列。最终数组内容为：3, 7, 8, 12, 15。

### 3. 数制转换程序

**填空答案：**
- mov ax, binary
- lea di, decimal

**代码段作用：**
该程序段将二进制数10110101B（即181D）转换为十进制ASCII字符串。使用除10取余的方法，将各位数字转换为ASCII码并存储在decimal缓冲区中。

### 4. 条件分支程序

**填空答案：**
- mov ax, score
- mov grade, 'C'
- mov ah, 2

**代码段作用：**
该程序段实现成绩等级转换功能，根据分数score设置对应的等级字母：
- 90-100分：'A'
- 80-89分：'B'
- 60-79分：'C'
- 0-59分：'D'

---

## 六、程序设计题（14分）

**参考答案：**

```assembly
; 程序功能：实现两个字符串的连接
.model small
.stack 100h
.data
    str1_len   equ 50
    str2_len   equ 50
    str1       db str1_len dup(?)
    str2       db str2_len dup(?)
    result     db str1_len+str2_len dup(?)

    msg_input1 db '请输入第一个字符串: $'
    msg_input2 db '请输入第二个字符串: $'
    msg_result db 0dh,0ah,'连接结果: $'

    temp_len   dw ?

.code
startup
    mov ax, @data
    mov ds, ax

    ; 输入第一个字符串
    mov dx, offset msg_input1
    mov ah, 9
    int 21h

    lea dx, str1
    mov ah, 0ah
    int 21h

    ; 输入第二个字符串
    mov dx, offset msg_input2
    mov ah, 9
    int 21h

    lea dx, str2
    mov ah, 0ah
    int 21h

    ; 字符串连接
    call string_concat

    ; 显示结果
    mov dx, offset msg_result
    mov ah, 9
    int 21h

    lea dx, result
    mov ah, 9
    int 21h

    exit 0

; 字符串连接子程序
; 输入：str1, str2 - 源字符串
; 输出：result - 连接后的字符串
string_concat proc
    push ax
    push si
    push di
    push cx

    ; 将str1复制到result
    lea si, str1 + 1       ; 跳过长度字节
    mov cl, [si-1]         ; 取str1长度
    mov ch, 0
    mov temp_len, cx       ; 保存长度

    lea di, result
    cld

copy_str1:
    mov al, [si]
    mov [di], al
    inc si
    inc di
    loop copy_str1

    ; 将str2连接到result后面
    lea si, str2 + 1       ; 跳过长度字节
    mov cl, [si-1]         ; 取str2长度
    mov ch, 0

copy_str2:
    mov al, [si]
    mov [di], al
    inc si
    inc di
    loop copy_str2

    ; 添加字符串结束符
    mov byte ptr [di], '$'

    pop cx
    pop di
    pop si
    pop ax
    ret
string_concat endp

end
```

**评分标准：**
- 程序结构完整（简化段定义格式）：2分
- 字符串输入功能正确：3分
- 字符串连接算法正确：4分
- 字符串显示功能正确：3分
- 子程序设计和调用正确：2分

---

**总分：100分**