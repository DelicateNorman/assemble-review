# 华中科技大学网络空间安全学院汇编语言程序设计考试答案

---

# 一、顺序程序设计分析题（共25分）

## 1. 答案（15分）

**（1）数学公式和算法原理（4分）**
- 该程序实现了数学公式：1 + 2 + 3 + ... + N = (N+1) × N ÷ 2
- 算法原理：利用等差数列求和公式，避免了循环累加，提高了效率
- 程序计算：(100+1) × 100 ÷ 2 = 10100 ÷ 2 = 5050

**（2）MUL BX指令执行结果（4分）**
- 第13行：MUL BX 指令执行无符号乘法 DX:AX ← AX × BX
- 执行前：AX = 101 (65H)，BX = 100 (64H)
- 计算过程：101 × 100 = 10100 (2774H)
- 执行后：DX = 0，AX = 2774H

**（3）SHR和RCR指令组合的原因（3分）**
- 因为需要实现32位数据的右移除法运算
- DX:AX构成32位数据，单独使用SHR AX, 1无法处理DX中的高位
- SHR DX, 1：将DX右移1位，最低位进入CF
- RCR AX, 1：将AX连同CF标志右移1位，保持32位数据的完整性

**（4）NUM=300时的计算结果（4分）**
- (300+1) × 300 = 301 × 300 = 90300 (160FCH)
- 除以2：90300 ÷ 2 = 45150 (B07EH)
- SUM变量存储：低字SUM = B07EH，高字SUM+2 = 0000H

## 2. 答案（10分）

**（1）字符串处理功能（3分）**
- 功能：将字符串中的所有大写字母转换为小写字母
- 处理后内容：'hello world! this is a test'
- 遇到字符'0'时停止处理并替换为'$'作为字符串结束符

**（2）大写字母判断逻辑漏洞（3分）**
- 存在漏洞：判断逻辑只检查字符是否在'A'到'Z'之间
- 当字符串包含字符'['（ASCII码91）时：
  - '[' > 'Z'（90），会执行JA指令跳过转换
  - 这是正确的，因为'['不是大写字母
- 但如果包含字符'@'（ASCII码64）等特殊字符，可能出现边界问题

**（3）循环优化方案（4分）**
- loop_start循环：遍历字符串，转换大写字母为小写字母
- find_end循环：查找字符串结束符'0'并替换为'$'
- 优化方案：可以在第一个循环中同时记录结束位置
```assembly
loop_start:
    MOV AL, [SI]
    CMP AL, '0'
    JE loop_end           ; 找到结束符时直接处理
    ; ... 转换逻辑 ...
    INC SI
    JMP loop_start
loop_end:
    MOV BYTE PTR [SI], '$' ; 直接替换，无需第二个循环
```

---

# 二、分支程序设计分析题（共30分）

## 1. 答案（15分）

**（1）复杂分支逻辑分析（4分）**
- 处理的异常情况：
  - 算术溢出检测（OF标志位）
  - 符号位处理（SF标志位）
  - 进位检测（CF标志位）
  - 最终溢出标记处理
- 程序实现了带溢出处理的绝对值计算功能

**（2）标志位状态（4分）**
- 第12行ADD AX, BX执行：8000H + 0001H = 8001H
- 标志位状态：
  - OF = 1：正数加正数得到负数，发生溢出
  - SF = 1：结果的最高位为1，表示负数
  - CF = 0：没有进位
  - ZF = 0：结果不为零

**（3）变量值（3分）**
- RESULT = 8001H（原始值，因为后续分支逻辑）
- OVERFLOW = 1（设置了溢出标记）
- 最终程序会将RESULT设置为0FFFFH

**（4）执行路径变化（4分）**
- 改为MOV AX, 7FFFH后：7FFFH + 0001H = 8000H
- 标志位：OF = 1, SF = 1, CF = 0, ZF = 0
- 执行路径：JO跳转 → JC不跳转 → NEG AX → MOV RESULT, AX
- 最终结果：RESULT = 8000H（取绝对值后）

## 2. 答案（15分）

**（1）功能分析（4分）**
- 功能：成绩等级转换程序
- 输入85，输出'D'（80-89分对应D等级）
- 等级划分：90-100(A), 80-89(B), 70-79(C), 60-69(D), <60(F)

**（2）跳转表优化方案（4分）**
```assembly
.DATA
    GRADE_TABLE DW grade_a, grade_b, grade_c, grade_d, grade_f
.CODE
    MOV AX, GRADE
    MOV BX, 10
    DIV BL                    ; AL = 商, AH = 余数
    SUB AL, 5                 ; 调整索引
    JC grade_f                ; 小于60分
    CMP AL, 4
    JA grade_f                ; 大于100分
    MOV BL, AL
    XOR BH, BH
    SHL BX, 1                 ; 乘以2（字指针）
    JMP GRADE_TABLE[BX]
```

**（3）负数处理（3分）**
```assembly
    MOV AX, GRADE
    CMP AX, 0
    JL grade_e                ; 小于0分显示'E'
    ; ... 原有逻辑 ...
grade_e:
    MOV RESULT, 'E'
    JMP done
```

**（4）效率问题分析（4分）**
- 问题：连续比较指令在最坏情况下需要执行4次比较
- 改进建议：
  - 使用二分查找思想减少比较次数
  - 使用除法计算索引，直接跳转到对应处理
  - 对于大量数据处理，跳转表效率更高

---

# 三、循环程序设计分析题（共30分）

## 1. 答案（18分）

**（1）优化分析（4分）**
- 优化：添加了SWAPPED变量检测是否发生交换
- 作用：如果某趟排序没有发生任何交换，说明数组已经有序，可以提前结束排序
- 这是冒泡排序的常见优化，减少了不必要的比较次数

**（2）PUSH/POP必要性（5分）**
- 必要性：保护外层循环计数器CX的值
- 错误情况：如果去掉第14行PUSH CX和第29行POP CX，内层循环的循环控制会破坏外层循环计数器
- 具体问题：内层循环使用DL作为计数器，但LOOP指令会影响CX，导致外层循环次数错误

**（3）循环控制方式差异（4分）**
- 内层循环使用第27行DEC DL + JNZ：因为内层循环次数需要动态计算
- 外层循环使用LOOP：因为外层循环次数固定，且LOOP指令效率较高
- 使用DEC DL是为了避免影响外层循环的CX计数器

**（4）已排序数组执行分析（3分）**
- 执行路径：第一趟外层循环后，SWAPPED = 0（无交换发生）
- 效率：只需执行一趟完整的内层循环比较，然后提前结束
- 比较次数：7次（COUNT-1次），而不是28次（标准冒泡排序）

**（5）COUNT-1的原因（2分）**
- 原因：n个元素的数组最多需要n-1趟排序
- 第11行MOV CX, COUNT-1改为MOV CX, COUNT：会导致最后一趟是多余的空循环，但仍能正确排序
- 性能影响：会增加一次不必要的外层循环

## 2. 答案（12分）

**（1）算法和时间复杂度（4分）**
- 算法：暴力字符串匹配算法（Brute Force）
- 时间复杂度：O(m×n)，其中m是模式串长度，n是文本串长度
- 空间复杂度：O(1)

**（2）边界计算作用（4分）**
- 作用：避免在文本串末尾进行无效的模式匹配
- 原因：如果剩余字符数小于模式串长度，必然无法匹配成功
- JS NotFound：提前判断边界条件，提高效率

**（3）寄存器保护特殊性（4分）**
- 特殊之处：成功匹配时使用POP AX而不是POP SI
- 原因：需要计算匹配位置，AX用于位置计算，SI的值已不再需要
- 计算：位置 = TEXTLEN - 剩余未匹配字符数

---

# 四、子程序设计分析题（共35分）

## 1. 答案（20分）

**（1）递归调用栈变化（5分）**
```
NUMBER=5的调用栈变化：
调用FACT(5):
  BP→[返回地址]
      [参数5]
      [旧BP]
      [BX]
调用FACT(4):
  BP→[返回地址]
      [参数4]
      [旧BP]
      [BX]
调用FACT(3):
  BP→[返回地址]
      [参数3]
      [旧BP]
      [BX]
调用FACT(2):
  BP→[返回地址]
      [参数2]
      [旧BP]
      [BX]
调用FACT(1):
  BP→[返回地址]
      [参数1]
      [旧BP]
      [BX]
返回：1! = 1
返回：2! = 2 × 1 = 2
返回：3! = 3 × 2 = 6
返回：4! = 4 × 6 = 24
返回：5! = 5 × 24 = 120
```

**（2）RET 2指令作用（5分）**
- RET 2：返回并清理栈上2字节参数
- 与RET的区别：普通RET只返回，不清理参数
- 作用：实现C调用约定中的调用者清理栈，保持栈平衡
- 影响：每次递归调用后，栈上的参数被自动清理

**（3）结果计算（4分）**
- NUMBER=5：RESULT = 120 (78H)
- NUMBER=6：RESULT = 720 (2D0H)
- 计算过程：5! = 5×4×3×2×1 = 120

**（4）栈帧建立作用（3分）**
- 第17行PUSH BP：保存调用者的基址指针
- 第18行MOV BP, SP：建立当前函数的栈帧
- 作用：方便通过[BP+偏移]访问参数和局部变量
- 必要性：递归调用中每层都需要独立的栈帧

**（5）负数处理修改（3分）**
```assembly
    MOV AX, [BP+4]
    CMP AX, 0
    JL NegativeCase    ; 负数处理
    CMP AX, 1
    JLE BaseCase
    ; ... 原有递归逻辑 ...
NegativeCase:
    MOV AX, 0          ; 负数的阶乘返回0
    JMP Return
```

## 2. 答案（15分）

**（1）功能和内容（4分）**
- 功能：将十六进制数转换为8位二进制字符串
- HEX_NUM = 0AFH = 10101111B
- BUFFER内容：'10101111$'（长度为8）

**（2）SHL指令选择原因（4分）**
- 第27行SHL AL, 1作用：将AL的最高位移入CF标志位
- 选择左移原因：需要从高位到低位依次检测每一位
- 不能右移：右移会丢失已经处理过的位

**（3）字符串结束符作用（3分）**
- 第38行MOV BYTE PTR [SI], '$'作用：为DOS 09H功能调用提供字符串结束标记
- 问题：如果没有'$'，DOS功能调用会继续显示内存中的垃圾数据
- 影响：导致输出混乱或程序崩溃

**（4）十进制转换算法设计（4分）**
- 设计思路：使用除10取余法
- 算法步骤：
  1. 将AL扩展为AX（16位）
  2. 循环：AX ÷ 10，余数转换为ASCII字符
  3. 直到商为0
  4. 反序输出字符
- 需要添加的子程序：
  - HEX_TO_DEC_STR：主转换函数
  - REVERSE_STRING：字符串反序函数

---

# 五、综合应用和陷阱分析题（共20分）

## 1. 答案（10分）

**（1）内存访问问题（3分）**
- 存在陷阱的指令：
  - 第14行：MOV CX, WORD PTR DATA3（跨边界访问）
  - 其他指令基本正常，但需要注意内存对齐

**（2）跨边界访问问题（3分）**
- 问题：DATA3定义为一个字节，但按字访问会读取相邻内存
- 导致问题：
  - DATA3地址：假设为XXXXH
  - 读取内容：XXXXH处的DATA3和XXXX+1H处的DATA4低字节
  - 可能导致数据不一致或访问错误

**（3）小端序正确读取（4分）**
```assembly
; 正确的小端序双字读取
    MOV AX, WORD PTR DATA4      ; 低16位：4567H
    MOV BX, WORD PTR DATA4+2    ; 高16位：B123H
; 或者使用32位寄存器（如果支持）
    MOV EAX, DWORD PTR DATA4    ; 完整32位：0B1234567H
```

## 2. 答案（10分）

**（1）标志位变化和跳转路径（4分）**
```
执行路径分析：
1. MOV AL, 7FH              ; AL=7FH, 标志位不变
2. ADD AL, 1                ; AL=80H, OF=1, SF=1, ZF=0, CF=0
3. JO overflow1             ; 溢出，跳转到overflow1
4. SUB AL, 1                ; AL=7FH, OF=0, SF=0, ZF=0, CF=1
5. JC carry1                ; 有进位，跳转到carry1
6. CMP AL, 7FH              ; AL=7FH, ZF=1, SF=0, OF=0
7. JE equal1                ; 相等，跳转到equal1
8. NEG AL                   ; AL=81H, OF=1, SF=1, ZF=0, CF=1
9. JS negative2             ; 负数，跳转到negative2
10. 程序结束
```

**（2）最终AL值和流程分析（6分）**
- 最终AL值：81H
- 完整执行流程：
  1. 初始：AL = 7FH (127)
  2. 加1：AL = 80H (-128)，溢出跳转
  3. 减1：AL = 7FH (127)，有借位跳转
  4. 比较：AL = 7FH，相等跳转
  5. 取反：AL = 81H (-127)，设置符号位
  6. 最终：AL = 81H

---

**评分标准参考**：
- 答案准确完整：满分
- 答案部分正确：按比例给分
- 有解题思路但结果错误：酌情给分
- 完全错误：0分

**注意事项**：
- 计算题需要写出详细计算过程
- 程序分析题需要说明 reasoning
- 优化题需要给出具体代码实现