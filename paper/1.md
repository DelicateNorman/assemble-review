# 华中科技大学网络空间安全学院汇编语言程序设计考试试卷

# 程序示例改编题（基于真实程序代码分析）

考试方式：闭卷 考试时长：150分钟

专业班级： 学号： 姓名：

<table><tr><td>题号</td><td>一</td><td>二</td><td>三</td><td>四</td><td>五</td><td>六</td><td>总分</td></tr><tr><td>分数</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>

<table><tr><td>分数</td><td></td></tr><tr><td>评卷人</td><td></td></tr></table>

# 一、子程序嵌套与查表转换分析题（本题共15分 = 4+3+4+4）

阅读以下子程序嵌套程序段，回答相关问题：

```
.MODEL SMALL
.STACK 100H

.CODE
.STARTUP

    MOV AL, 0F7H

    __①__ ALDISP

.EXIT 0

ALDISP PROC NEAR
    PUSH AX
    PUSH CX

    __②__ AX

    MOV CL, 4
    __③__ AL, CL
    CALL HTOASC

    __④__ AX

    CALL HTOASC

    POP CX
    POP AX
    RET
ALDISP ENDP

HTOASC PROC NEAR
    PUSH AX
    PUSH BX
    PUSH DX

    PUSH CS
    __⑤__ DS

    MOV BX, __⑥__ ASCII

    AND AL, 0FH

    __⑦__ ASCII

    MOV DL, AL
    MOV AH, 2
    INT 21H

    POP DX
    POP BX
    POP AX
    RET
HTOASC ENDP

ASCII DB '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
      DB 'A', 'B', 'C', 'D', 'E', 'F'

END
```

(1) 补齐程序中①②③④⑤⑥⑦处的指令或操作。（7分）

(2) 程序执行后，屏幕上会显示什么内容？详细说明执行过程。（3分）

(3) 第70行 `PUSH CS; POP DS` 这两条指令的作用是什么？如果不执行这两条指令，程序会出现什么问题？（3分）

(4) 分析程序执行到第38行 `CALL HTOASC` 时，寄存器AL的值是多少？为什么？（2分）

---

<table><tr><td>得分</td><td>评卷人</td></tr><tr><td></td><td></td></tr></table>

# 二、递归阶乘算法分析题（本题共18分 = 5+4+3+3+3）

阅读以下递归阶乘程序段，回答相关问题：

```
.model small
.stack 200h
.data
    N dw 3
    result dw ?
    msg_result db 'Factorial result: $'
.code
.startup
    mov bx, N
    push bx
    __①__ fact
    pop result

    mov dx, offset msg_result
    mov ah, 9
    int 21h

    mov ax, result
    call display_number

.exit 0

fact proc
    push ax
    push bp
    mov bp, sp
    mov ax, [__②__]     ; 取参数N

    cmp ax, 0
    jne __③__          ; N ≠ 0，递归
    inc ax             ; N = 0，返回1（0! = 1）
    jmp fact2

fact1:
    dec ax             ; ax = N-1
    push ax            ; 传入N-1
    call fact          ; 递归调用fact(N-1)
    pop ax             ; 取回fact(N-1)的结果
    mul __④__ ptr [bp+6] ; ax = (N-1)! × N

fact2:
    mov [bp+6], ax     ; 将结果放回堆栈
    pop bp
    pop ax
    ret
fact endp

display_number proc
    push ax
    push bx
    push cx
    push dx

    mov cx, 0
    mov bx, 10

convert_loop:
    xor dx, dx
    __⑤__ bx
    push dx
    inc cx
    test ax, ax
    jnz convert_loop

display_loop:
    pop dx
    add dl, '0'
    mov ah, 2
    int 21h
    loop display_loop

    pop dx
    pop cx
    pop bx
    pop ax
    ret
display_number endp

end
```

(1) 补齐程序中①②③④⑤处的指令或操作。（5分）

(2) 如果程序第8行改为 `N dw 5`，请详细描述程序执行过程，包括递归调用的堆栈变化。（4分）

(3) 第43行指令 `mul word ptr [bp+6]` 的作用是什么？如果改为 `mul [bp+6]` 会有什么问题？（3分）

(4) 程序执行完毕后，变量 `result` 的值是多少？（假设N=3）（3分）

(5) 第35行 `mov ax, [bp+6]` 中 `[bp+6]` 访问的是什么？请画出此时堆栈的结构图。（3分）

---

<table><tr><td>得分</td><td>评卷人</td></tr><tr><td></td><td></td></tr></table>

# 三、数组最大值最小值查找分析题（本题共18分 = 5+3+3+4+3）

阅读以下数组查找程序段，回答相关问题：

```
.MODEL SMALL
.STACK 100H

.DATA
    array   DW 1,2,3,4,5,6,7,8,9,10
    count   EQU 10
    minimal DW ?
    maximum DW ?
    max_msg DB 'Maximum value: $'
    min_msg DB 0Dh,0Ah,'Minimum value: $'

.CODE
.STARTUP

    CALL __①__
    CALL __②__
    CALL OUTPUT_RESULTS

.EXIT 0

SOLVE_MAX PROC
    PUSH BX
    PUSH CX

    MOV BX, OFFSET array
    MOV CX, count
    MOV AX, [BX]

AGAIN:
    CMP AX, [BX]
    __③__ NO_PROCESS

    MOV AX, [BX]

NO_PROCESS:
    INC BX
    INC BX
    __④__ AGAIN

    MOV maximum, AX

    POP CX
    POP BX
    RET
SOLVE_MAX ENDP

SOLVE_MIN PROC
    PUSH BX
    PUSH CX

    MOV BX, OFFSET array
    MOV CX, count
    MOV AX, [BX]

AGAIN1:
    CMP AX, [BX]
    __⑤__ NO_PROCESS1

    MOV AX, [BX]

NO_PROCESS1:
    INC BX
    INC BX
    LOOP AGAIN1

    MOV minimal, AX

    POP CX
    POP BX
    RET
SOLVE_MIN ENDP

OUTPUT_RESULTS PROC
    PUSH AX
    PUSH DX

    MOV AH, 09H
    LEA DX, max_msg
    INT 21H

    MOV AX, maximum
    CALL OUTPUT_NUMBER

    MOV AH, 09H
    LEA DX, min_msg
    INT 21H

    MOV AX, minimal
    CALL OUTPUT_NUMBER

    POP DX
    POP AX
    RET
OUTPUT_RESULTS ENDP

OUTPUT_NUMBER PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX

    MOV CX, 0
    MOV BX, 10

DIVIDE_LOOP:
    XOR DX, DX
    DIV BX
    ADD DL, '0'
    __⑥__ DX
    INC CX
    TEST AX, AX
    JNZ DIVIDE_LOOP

PRINT_LOOP:
    POP DX
    MOV AH, 02H
    INT 21H
    __⑦__ PRINT_LOOP

    POP DX
    POP CX
    POP BX
    POP AX
    RET
OUTPUT_NUMBER ENDP

END
```

(1) 补齐程序中①②③④⑤⑥⑦处的指令或操作。（7分）

(2) 程序执行完毕后，变量 `maximum` 和 `minimal` 的值分别是多少？（2分）

(3) 比较 `SOLVE_MAX` 和 `SOLVE_MIN` 两个子程序的异同，特别是第55行和第95行的条件跳转指令的作用。（3分）

(4) 第64-65行为什么执行两次 `INC BX`？如果只执行一次会出现什么问题？（3分）

(5) `OUTPUT_NUMBER` 子程序实现的是什么算法？为什么需要使用堆栈来存储字符？（3分）

---

<table><tr><td>得分</td><td>评卷人</td></tr><tr><td></td><td></td></tr></table>

# 四、程序设计与纠错综合题（本题共15分 = 6+5+4）

(1) 基于第三题的程序框架，请设计一个查找数组中所有偶数个数的子程序 `COUNT_EVEN`。要求：
   - 子程序入口参数：数组地址和元素个数
   - 出口参数：偶数个数存储在全局变量中
   - 使用适当的分支和循环结构
   - 包含完整的寄存器保护和恢复（6分）

(2) 分析以下存在错误的程序段，找出所有错误并改正：
   ```asm
   MOV CX, LENGTH ARRAY
   MOV SI, 0

SUM_LOOP:
   MOV AX, ARRAY[SI]
   ADD SUM, AX
   INC SI
   JNZ SUM_LOOP
   ```
   该程序试图计算数组元素的和，但存在多个错误。（5分）

(3) 简述在汇编语言中实现递归算法需要特别注意的几个问题。（4分）

---

<table><tr><td>得分</td><td>评卷人</td></tr><tr><td></td><td></td></tr></table>

# 五、综合算法设计与分析题（本题共20分 = 8+6+6）

基于以下程序框架，实现一个完整的字符串处理和统计程序：

```
.MODEL SMALL
.STACK 200H

.DATA
    input_str db 80, 0, 80 dup(?)      ; 输入缓冲区
    vowels    db 'aeiouAEIOU'           ; 元音字母表
    consonants db 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ' ; 辅音字母表
    digit_count dw ?                    ; 数字计数
    vowel_count dw ?                    ; 元音计数
    consonant_count dw ?                ; 辅音计数
    other_count dw ?                    ; 其他字符计数
    msg_input  db 'Please input a string: $'
    msg_result db 0Dh,0Ah,'Statistics:',0Dh,0Ah,'$'
    msg_digit  db 'Digits: $'
    msg_vowel  db 'Vowels: $'
    msg_consonant db 'Consonants: $'
    msg_other  db 'Others: $'

.CODE
.STARTUP

    ; 1. 显示输入提示
    MOV DX, OFFSET msg_input
    MOV AH, 09H
    INT 21H

    ; 2. 读取用户输入字符串
    LEA DX, input_str
    __①__ 0AH
    INT 21H

    ; 3. 调用字符串分析子程序
    __②__ ANALYZE_STRING

    ; 4. 显示统计结果
    CALL DISPLAY_RESULTS

.EXIT 0

ANALYZE_STRING PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    PUSH SI
    PUSH DI

    ; 初始化计数器
    MOV digit_count, 0
    MOV vowel_count, 0
    MOV consonant_count, 0
    MOV other_count, 0

    ; 设置字符串长度指针
    MOV SI, OFFSET input_str + 2       ; 输入字符串开始位置
    MOV CL, [input_str + 1]             ; 实际输入长度
    MOV CH, 0                           ; CX = 字符串长度

ANALYZE_LOOP:
    JCXZ ANALYZE_DONE                   ; 如果字符串结束，跳转到结束

    MOV AL, [SI]                        ; 取当前字符

    ; 检查是否为数字
    CMP AL, '0'
    JB CHECK_VOWEL
    CMP AL, '9'
    JA CHECK_VOWEL
    INC digit_count
    JMP NEXT_CHAR

CHECK_VOWEL:
    ; 检查是否为元音
    MOV DI, OFFSET vowels
    MOV BL, 10                         ; 元音字母数量
    __③__ CHECK_VOWEL_LOOP

CHECK_VOWEL_LOOP:
    CMP BL, 0
    JZ CHECK_CONSONANT
    CMP AL, [DI]
    JE IS_VOWEL
    INC DI
    DEC BL
    JMP CHECK_VOWEL_LOOP

IS_VOWEL:
    INC vowel_count
    JMP NEXT_CHAR

CHECK_CONSONANT:
    ; 检查是否为辅音
    MOV DI, OFFSET consonants
    MOV BL, 42                         ; 辅音字母数量
    __④__ CHECK_CONSONANT_LOOP

CHECK_CONSONANT_LOOP:
    CMP BL, 0
    JZ IS_OTHER
    CMP AL, [DI]
    JE IS_CONSONANT
    INC DI
    DEC BL
    JMP CHECK_CONSONANT_LOOP

IS_CONSONANT:
    INC consonant_count
    JMP NEXT_CHAR

IS_OTHER:
    INC other_count

NEXT_CHAR:
    INC SI
    DEC CX
    JMP ANALYZE_LOOP

ANALYZE_DONE:
    POP DI
    POP SI
    POP DX
    POP CX
    POP BX
    POP AX
    RET
ANALYZE_STRING ENDP

DISPLAY_RESULTS PROC
    PUSH AX
    PUSH DX

    MOV DX, OFFSET msg_result
    MOV AH, 09H
    INT 21H

    ; 显示数字计数
    MOV DX, OFFSET msg_digit
    MOV AH, 09H
    INT 21H
    MOV AX, digit_count
    CALL OUTPUT_NUMBER

    ; 显示元音计数
    MOV DX, OFFSET msg_vowel
    MOV AH, 09H
    INT 21H
    MOV AX, vowel_count
    CALL OUTPUT_NUMBER

    ; 显示辅音计数
    MOV DX, OFFSET msg_consonant
    MOV AH, 09H
    INT 21H
    MOV AX, consonant_count
    CALL OUTPUT_NUMBER

    ; 显示其他字符计数
    MOV DX, OFFSET msg_other
    MOV AH, 09H
    INT 21H
    MOV AX, other_count
    CALL OUTPUT_NUMBER

    POP DX
    POP AX
    RET
DISPLAY_RESULTS ENDP

; 数字输出子程序（使用前面试题中的实现）
OUTPUT_NUMBER PROC
    ; ... 实现略，参考第三题
    RET
OUTPUT_NUMBER ENDP

END
```

(1) 补齐程序中①②③④处的指令或操作。（8分）

(2) 如果用户输入字符串 "Hello 123 World!"，请详细分析程序的执行流程，并给出最终的统计结果。（6分）

(3) 程序中第68行 `JCXZ ANALYZE_DONE` 指令的作用是什么？如果删除这行指令会有什么问题？另外，说明为什么在处理辅音字母检查时，BL需要设置为42而不是其他数值？（6分）

---

<table><tr><td>得分</td><td>评卷人</td></tr><tr><td></td><td></td></tr></table>

# 六、高级数据结构与算法实现题（本题共22分 = 8+7+7）

基于以下程序框架，实现一个简单的链表操作程序，包括链表创建、遍历、查找和删除功能：

```
.MODEL SMALL
.STACK 300H

.DATA
    ; 链表节点结构
    NODE STRUC
        value dw ?                     ; 数据域（字类型）
        next_node dw ?                 ; 指针域（指向下一个节点）
    NODE ENDS

    ; 全局变量
    head_ptr dw ?                      ; 链表头指针
    current_ptr dw ?                   ; 当前节点指针
    search_value dw 5                  ; 搜索值
    delete_value dw 3                  ; 删除值

    ; 提示信息
    msg_create db 'Creating linked list...',0Dh,0Ah,'$'
    msg_traverse db 'Traversing linked list:',0Dh,0Ah,'$'
    msg_search db 'Searching for value: $'
    msg_found db 'Found!',0Dh,0Ah,'$'
    msg_notfound db 'Not found!',0Dh,0Ah,'$'
    msg_delete db 'Deleting value: $'
    msg_space db ' '

.CODE
.STARTUP

    ; 1. 创建链表
    CALL CREATE_LINKED_LIST

    ; 2. 遍历显示链表
    CALL TRAVERSE_LIST

    ; 3. 搜索指定值
    MOV AX, search_value
    CALL SEARCH_NODE

    ; 4. 删除指定节点
    MOV AX, delete_value
    CALL DELETE_NODE

    ; 5. 再次遍历显示链表
    CALL TRAVERSE_LIST

.EXIT 0

CREATE_LINKED_LIST PROC
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH SI

    MOV head_ptr, 0                    ; 初始化头指针为空
    MOV CX, 5                          ; 创建5个节点的链表
    MOV BX, 1                          ; 节点值从1开始

CREATE_LOOP:
    ; 分配内存空间（简化处理，假设有足够空间）
    __①__ ALLOCATE_SPACE

    ; 如果是第一个节点，设置头指针
    CMP head_ptr, 0
    JNE NOT_FIRST_NODE
    MOV head_ptr, SI
    MOV current_ptr, SI
    JMP SET_NODE_DATA

NOT_FIRST_NODE:
    ; 连接到当前节点的后面
    MOV [current_ptr + 2], SI          ; 设置前驱节点的next指针
    MOV current_ptr, SI                ; 更新当前节点指针

SET_NODE_DATA:
    MOV [SI], BX                       ; 设置节点数据
    MOV [SI + 2], 0                    ; next指针初始化为0
    INC BX
    LOOP CREATE_LOOP

    POP SI
    POP CX
    POP BX
    POP AX
    RET
CREATE_LINKED_LIST ENDP

ALLOCATE_SPACE PROC
    ; 简化的内存分配（实际程序应使用DOS内存分配功能）
    __②__                              ; 分配空间，返回地址在SI
    RET
ALLOCATE_SPACE ENDP

TRAVERSE_LIST PROC
    PUSH AX
    PUSH DX
    PUSH SI

    MOV SI, head_ptr
    JCXZ TRAVERSE_DONE                 ; 如果链表为空，直接返回

TRAVERSE_LOOP:
    CMP SI, 0
    JE TRAVERSE_DONE

    ; 显示节点值
    MOV AX, [SI]
    CALL OUTPUT_NUMBER

    ; 显示空格
    MOV DL, ' '
    MOV AH, 02H
    INT 21H

    ; 移动到下一个节点
    MOV SI, [SI + 2]                   ; 获取next指针
    JMP TRAVERSE_LOOP

TRAVERSE_DONE:
    ; 显示换行
    MOV DL, 0DH
    MOV AH, 02H
    INT 21H
    MOV DL, 0AH
    MOV AH, 02H
    INT 21H

    POP SI
    POP DX
    POP AX
    RET
TRAVERSE_LIST ENDP

SEARCH_NODE PROC
    PUSH AX
    PUSH DX
    PUSH SI

    MOV SI, head_ptr

SEARCH_LOOP:
    CMP SI, 0
    JE NOT_FOUND

    MOV BX, [SI]                       ; 获取节点数据
    CMP BX, AX                         ; 与搜索值比较
    JE FOUND

    MOV SI, [SI + 2]                   ; 移动到下一个节点
    JMP SEARCH_LOOP

FOUND:
    MOV DX, OFFSET msg_found
    JMP DISPLAY_SEARCH_RESULT

NOT_FOUND:
    MOV DX, OFFSET msg_notfound

DISPLAY_SEARCH_RESULT:
    MOV AH, 09H
    INT 21H

    POP SI
    POP DX
    POP AX
    RET
SEARCH_NODE ENDP

DELETE_NODE PROC
    PUSH AX
    PUSH BX
    PUSH SI
    PUSH DI

    MOV SI, head_ptr
    MOV DI, 0                          ; 前驱节点指针

DELETE_LOOP:
    CMP SI, 0
    JE DELETE_DONE                     ; 未找到要删除的节点

    MOV BX, [SI]                       ; 获取节点数据
    CMP BX, AX                         ; 与删除值比较
    JE DELETE_FOUND

    MOV DI, SI                         ; 保存当前节点作为前驱
    MOV SI, [SI + 2]                   ; 移动到下一个节点
    JMP DELETE_LOOP

DELETE_FOUND:
    ; 检查是否删除头节点
    CMP SI, head_ptr
    JNE DELETE_MIDDLE

    ; 删除头节点
    MOV head_ptr, [SI + 2]             ; 头指针指向下一个节点
    JMP DELETE_DONE

DELETE_MIDDLE:
    ; 删除中间节点
    MOV BX, [SI + 2]                   ; 获取被删除节点的next指针
    __③__ [DI + 2], BX                 ; 前驱节点的next指向被删除节点的next

DELETE_DONE:
    POP DI
    POP SI
    POP BX
    POP AX
    RET
DELETE_NODE ENDP

OUTPUT_NUMBER PROC
    ; 数字输出子程序（参考前面实现）
    RET
OUTPUT_NUMBER ENDP

END
```

(1) 补齐程序中①②③处的指令或操作，并说明链表节点在内存中的存储结构。（8分）

(2) 详细描述删除节点操作中 `DELETE_MIDDLE` 标签处的逻辑。如果要删除的节点是链表的最后一个节点，程序应该如何处理？（7分）

(3) 在实际内存分配中，为什么需要使用DOS的内存分配功能而不是静态分配？请说明动态内存分配的优点，并写出使用DOS功能48H分配内存的代码片段。（7分）

---

## 评分标准参考

### 第一题评分标准（子程序嵌套与查表转换）
- (1) 指令填空：①CALL, ②PUSH, ③SHR, ④POP, ⑤POP, ⑥OFFSET, ⑦XLAT（每空1分，共7分）
- (2) 显示内容分析：显示"F7"（1分），执行过程详细说明（2分）
- (3) CS/DS指令作用：说明作用2分，不执行的后果1分
- (4) AL值分析：正确计算0FH（1分），解释原因1分

### 第二题评分标准（递归阶乘算法）
- (1) 指令填空：①CALL, ②bp+6, ③fact1, ④word, ⑤DIV（每空1分，共5分）
- (2) N=5执行过程：递归层次描述2分，堆栈变化图解2分
- (3) MUL指令分析：word ptr作用2分，省略后果1分
- (4) 结果计算：3! = 6（3分）
- (5) 堆栈结构图：正确画出[bp+6]访问内容（3分）

### 第三题评分标准（数组最大值最小值查找）
- (1) 指令填空：①SOLVE_MAX, ②SOLVE_MIN, ③JA, ④LOOP, ⑤JBE, ⑥PUSH, ⑦LOOP（每空1分，共7分）
- (2) 结果值：maximum=10, minimal=1（2分）
- (3) 子程序比较：异同点分析2分，条件跳转作用1分
- (4) INC BX分析：字类型访问需要+2（2分），只+1的后果1分
- (5) OUTPUT_NUMBER算法：除法取余算法2分，堆栈逆序输出原因1分

### 第四题评分标准（程序设计与纠错）
- (1) COUNT_EVEN设计：算法正确3分，结构完整2分，寄存器保护1分
- (2) 错误改正：LENGTH伪指令错误1分，循环控制错误2分，其他错误2分
- (3) 递归问题：堆栈管理2分，参数传递1分，终止条件1分

### 第五题评分标准（综合算法设计与分析）
- (1) 指令填空：①MOV AH, ②CALL, ③JMP, ④JMP（每空2分，共8分）
- (2) 执行流程分析：详细跟踪每个字符的处理过程4分，统计结果正确2分（数字：3个，元音：3个，辅音：7个，其他：3个）
- (3) JCXZ作用：说明循环控制作用2分，删除后果2分，BL=42的原因说明2分

### 第六题评分标准（高级数据结构与算法实现）
- (1) 指令填空与结构：①CALL, ②内存分配代码, ③MOV（每空2分，共6分），链表存储结构说明2分
- (2) 删除逻辑分析：DELETE_MIDDLE逻辑详细说明4分，末尾节点处理3分
- (3) 内存分配理论：动态分配优点4分，DOS功能48H代码实现3分

## 难度分析
- **基础题**：指令填空、简单功能分析（约20%）
- **中等题**：算法理解、程序流程分析（约25%）
- **提高题**：递归分析、堆栈结构、复杂逻辑（约30%）
- **综合题**：程序设计、错误诊断、数据结构实现（约25%）

## 知识点覆盖
1. **子程序设计**：嵌套调用、参数传递、现场保护
2. **递归算法**：阶乘计算、堆栈管理、递归终止
3. **分支循环**：条件判断、循环控制、数组操作
4. **查表转换**：XLAT指令、ASCII转换、段寄存器操作
5. **数值输出**：除法算法、字符转换、堆栈逆序
6. **字符串处理**：字符分类、统计算法、缓冲区操作
7. **数据结构**：链表实现、指针操作、动态内存分配
8. **系统调用**：DOS功能调用、内存管理、输入输出

## 题目特色
- **渐进式难度**：从基础指令到复杂数据结构
- **综合性强**：涵盖汇编语言核心知识点
- **实用性高**：基于真实程序示例
- **挑战性足**：包含高级算法和数据结构实现