# 汇编语言程序设计

# Assembly Language Programming

主讲人：鲁宏伟luhw@hust.edu.cn

# 第一章

# 汇编语言基础知识

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/ed9a964a84ce614336bc11e115cef8474b38d9e7bc6ffeb39caf71e98817cd3e.jpg)

第1章是用汇编语言进行程序设计所需要了解的基本知识。在课堂上，我们重点掌握几个内容：

PC 机软硬件系统  
$\checkmark$  认识汇编语言  
✓基础是熟悉寄存器组  
难点是各种寻址方式

# > 硬件（Hardware）

中央处理单元 CPU

■控制器、运算器、寄存器

■存储器

主存储器：RAM和ROM

辅助存储器：磁盘、光盘、U盘

外部设备

输入设备和输出设备

# > 软件 (Software)

■系统软件  
应用软件

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/3a9afbf71722662c93c26be4d4fe16c774ba0c31040b2241549caca482943511.jpg)

> 中央处理单元 CPU (Intel 80x86)

对汇编语言程序员，最关心其中的寄存器

> 存储器（主存储器）

呈现给汇编语言程序员的，是存储器地址

外部设备 (接口电路)

汇编语言程序员看到的是端口（I/O 地址）

寄存器是CPU内部的高速存储单元  
> 它们为处理器提供各种操作所需要的数据或地址等信息  
汇编语言程序采用它们各自的符号名

16 位 Intel 8086/80286 CPU 中有

AX BX CX DX

SI DI BP SP

32位80386/80486/Pentium系列CPU中有

EAX EBX ECX EDX

ESI EDI EBP ESP

64 位寄存器名将 “E” 改为 “R”  
ARM系列CPU中有

R0-R12 R13(SP) R14(LR) R15(PC)

> 存储器是由大量存储单元组成，需要用编号区别每个单元：编号 = 地址

> 存储器地址是存储器中存储单元的编号  
每个存储单元存放一个字节量的数据

一个字节 B （Byte） = 8 个二进制位 b（bit）

采用十六进制数来表达地址

Intel 8086 具有 1 兆字节（1MB）存储器容量  
■ 存储器地址表示为：00000H ~ FFFFFFFH  
- 其中大写 H (或小写 h) 表示是十六进制数

> I/O 接口电路由接口寄存器组成，需要用编号区别各个寄存器：编号 = 地址

I/O 地址是接口电路中寄存器的编号  
端口是I/O地址的通俗说法  
系统通过这些端口与外设进行通信  
采用十六进制数来表达端口

Intel 8086 支持 64K 个 8 位端口  
I/O 地址可以表示为:  $0000 \mathrm{H} \sim$  FFFFH

机器语言（Machine Language）

B8 64 00 05 00 01

汇编语言（Assembly Language）

mov ax,100

; 取得一个数据 100 (MOV 是传送指令)

add ax,256

; 实现  $100 + 256$  (ADD 是加法指令)

高级语言（High-level Language）

100 + 256

# 以助记符形式表示计算机指令

■助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号  
助记符是表明指令功能的英语单词或其缩写

汇编格式指令以及使用它们编写程序的规则就形成汇编语言（Assembly Language）  
汇编语言程序：用汇编语言书写的程序  
汇编程序：将汇编语言程序“汇编”成机器代码目标模块的程序

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/bc852aef0edb3805db0d51ab29881a7ba132fdb3965f0e2e77964a4fb29e3297.jpg)

汇编语言程序与汇编程序是两个概念

汇编语言与处理器密切相关

汇编语言程序的通用性、可移植性较差

高级语言与具体计算机无关

高级语言程序是标准化语言，可在多种计算机上编译后执行

汇编语言：×

高级语言:  $\sqrt{}$

>汇编语言功能有限、涉及硬件细节  
程序编写比较繁琐，调试比较困难  
高级语言提供了强大的功能，不必关心琐碎问题

$\nearrow$  类似自然语言的语法，易于掌握和应用

汇编语言：×

高级语言:  $\sqrt{}$

# 汇编语言本质上就是机器语言

可以直接、有效地控制计算机硬件  
$\nearrow$  易于产生速度快、容量小的高效率目标程序

高级语言不针对具体计算机系统

不易直接控制计算机的各种操作  
目标程序比较庞大、运行速度较慢

汇编语言:  $\sqrt{}$

高级语言：×

# 汇编语言的优点:

■直接控制计算机硬件部件  
■编写“时间”和“空间”两方面最有效程序

# 汇编语言的缺点:

■与处理器密切有关  
■需要熟悉计算机硬件系统、考虑许多细节  
■编写繁琐，调试、维护、交流和移植困难

汇编语言：？

高级语言：？

> 汇编语言的优点使得它在程序设计中占有重要的位置，不可被取代  
> 汇编语言的缺点使得人们主要采用高级语言进行程序开发工作  
有时需要采用高级语言和汇编语言混合编程，互相取长补短，更好地解决实际问题

混合编程

取长补短

汇编语言在低层（Low Level）但不低级

程序要具有较快的执行时间，或者只能占用较小的存储容量  
程序与计算机硬件密切相关，程序要直接、有效地控制硬件  
大 汇编语言的作用实在不小！  
没有合适的高级语言、或只能采用汇编语言的时候  
分析具体系统尤其是该系统的低层软件、加密解密软件、分析和防治计算机病毒等等

# >1.2.1 数制

二进制数、十六进制数  
它们与十进制数的相互转换

# >1.2.2 数值的编码

定点整数编码  
有符号整数的补码表示

# 1.2.3 字符的编码

BCD码和ASCII码的规律

# 二进制编码的十进制数

一个十进制数位  $0 \sim 9$  用 4 位二进制编码来表示  
常用 8421 BCD 码: 低 10 个 4 位二进制编码表示  
压缩 BCD 码：一个字节表达两位 BCD 码  
■非压缩 BCD 码：一个字节表达一位 BCD 码（低 4 位表达数值，高 4 位常设置为 0）

# $>$  BCD 码很直观

BCD 码：0100 1001 0111 1000.0001 0100 1001 BCD 码便于输入输出，表达数值准确

十进制真值: 4978.149

标准 ASCII 码用 7 位二进制编码，有 128 个  
不可显示的控制字符

前32个和最后一个编码

回车 CR：0DH 换行 LF：0AH 响铃

BEL : 07H

可显示和打印的字符：20H开始的95个编码

- 数码  $0 \sim 9: 30 \mathrm{H} \sim 39 \mathrm{H}$  
大写字母 A ~ Z: 41H ~ 5AH  
小写字母 a ~ z: 61H ~ 7AH  
■容权·20H

真值：现实中真实的数值

机器数：计算机中用 0 和 1 数码组合表达的数值  
无符号数: 只表达 0 和正整数的定点整数  
有符号数: 表达负整数、0 和正整数的定点整数

符号位需要占用一个位  
常用机器数的最高位  
0 表示正数、1 表示负数

定点数：固定小数点的位置表达数值的机器数

■ 定点整数：将小数点固定在机器数的最右侧表达的整数  
- 定点小数：将小数点固定在机器数的最左侧表达的小数

浮点数: 小数点浮动表达的实数

有符号整数在计算机中默认采用补码

- 最高位表示符号：正数用 0 , 负数用 1  
- 正数补码：直接表示数值大小（同无符号数）  
负数补码：将对应正数补码取反加 1

$$
\begin{array}{l} [ 1 0 5 ] _ {\text {补 码}} = 0 1 1 0 1 0 0 1 \mathrm {B} \\ [ - 1 0 5 ] _ {\text {补 码}} = [ 0 1 1 0 1 0 0 1 \mathrm {B} ] _ {\text {取 反 ＋ 1}} \\ = 1 0 0 1 0 1 1 0 \mathrm {B} + 1 = 1 0 0 1 0 1 1 1 \mathrm {B} \\ \end{array}
$$

为什么是补码

8 位二进制补码表示的数值范围：-128 ~ +127  
16 位二进制补码表示的数值范围:  $-2^{15} \sim +2^{15}-1$  
32 位二进制补码表示的数值范围:  $-2^{31} \sim +2^{31}-1$

> 负数真值 “取反加 1” 得机器数补码  
> 负数补码 “取反加 1” 得到负数真值

补码：11100000B

真值: -([11100000] 求反 + 1) = -(00011111+1)

$$
= - 0 0 1 0 0 0 0 0 = - 2 ^ {5} = - 3 2
$$

负数求补运算，等效于用带借位的0作减法

真值: -8 , 补码:  $[-8]_{\text {补码}} = 00 \mathrm{H} - 08 \mathrm{H} = \mathrm{F} 8 \mathrm{H}$

补码：11111000，真值：- (00H-F8H) = -08H

$$
= - 8
$$

用十六进制表达和运算，方便！

# 二进制和十六进制数之间具有对应关系

整数从左向右  
小数从右向左  
■ 每 4 个二进制位对应一个十六进制位

$$
0 0 1 1 1 0 1 0 B = 3 A H, F 2 H = 1 1 1 1 0 0 1 0 B
$$

# 十六进制数的加减运算类似十进制

逢16进位1，借1当16

$$
2 3 \mathrm {D} 9 \mathrm {H} + 9 4 \mathrm {B E H} = \mathrm {B} 8 9 7 \mathrm {H}
$$

$$
\mathrm {A} 5 9 \mathrm {F H} - 6 2 \mathrm {B} 8 \mathrm {H} = 4 2 \mathrm {E} 7 \mathrm {H}
$$

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/201c2e0b667e4765d439aadade973eaf2cb6e92cc87b7230daf77cfedacc5bbe.jpg)

Intel 64 处理器

酷睿多核系列腾多核系列

IA-32 处理器

奔腾 III

奔腾

80486

80386

80286

8086

400

16位80x86处理

器

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/5b01ffa209d24ba43fbae340b3062a3cadd7ef477a3849505dc67b65e95be1db.jpg)

# 本课程采用16位个人计算机

# 16位PC机

■ 8088 CPU 的 IBM PC 和 IBM PC/XT  
80286 CPU 的 IBM PC/AT  
16位80x86CPU的PC兼容机

# 32位PC机

■采用32位80x86CPU而形成的微机  
■ 基本结构仍然源于PC/AT机

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/952698eecf6ab3eea28a6f67b011da0540d99c949d0c2b4207d6928aa50be260.jpg)

# 64位PC机

■采用64位x64CPU而形成的微机  
■ 基本结构同样源于PC/AT机

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/630a226ac4b59e57cdb26f8a0fe10d883f7494d2e50b9c10efee49cd6fad32d7.jpg)

> 人们日常谈论的PC机或微机是上述微型计算机系统的统称

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/3eeeee09c958d9d83515a8d7f89a9b719f1d5c6bc3f0390f9331bad80709ba9e.jpg)

# 64 位处理器

关于

系统正在监控并保护你的电脑。

在Windows安全中心中查看详细信息

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/29bb961346896746eb74bf30d44bc5f67ff79a3ede7507d3d4557e432f38f619.jpg)

设备规格

设备名称

DESKTOP-AJ0Q1LU

处理器

Intel(R) Core(TM)i7-3770 CPU @ 3.40GHz 3.90 GHz

机带RAM

16.0 GB (15.9 GB 可用)

设备ID

4AF63829-683C-49D2-9F01-615EDB2FCA11

产品ID

00331-10000-00001-AA973

系统类型

64位操作系统，基于x64的处理器

<table><tr><td>FFFFFFH</td><td>复制 ROM</td><td rowspan="2">扩展主存</td><td rowspan="6">32位机主存(4GB)</td></tr><tr><td>00100000H</td><td>HMA(64KB)</td></tr><tr><td>000E0000H</td><td>系统 ROM 128KB</td><td rowspan="3">RCXT主存(1MB)</td></tr><tr><td>000C0000H</td><td>扩展 ROM 128KB</td></tr><tr><td>000A0000H</td><td>显示 RAM 128KB</td></tr><tr><td>00000000H</td><td>系统 RAM 640KB</td><td>常规主存</td></tr></table>

系统软件：DOSBox 虚拟环境  
应用软件：开发汇编语言程序涉及

文本编辑器  
汇编程序  
■ 连接程序  
■ 调试程序  
■集成化开发环境

> 文本编辑器用于编辑无任何格式的文档  
程序设计要采用文本编辑器编写源程序  
常见的文本编辑软件有很多

汇编程序将汇编语言源程序翻译（称为“汇编”）成机器代码目标模块  
本课程采用微软的MASM6.11

■ MASM 的最后一个独立版本 MASM 6.11  
Visual C++ 中有 MASM 6.15 （支持 SSE2）  
Visual C++.NET 2003 有 MASM 7.10  
■ Visual C++.NET 2005 的 MASM 支持 Petium 4 的 SSE3 指令系统，同时有 ML64.EXE 程序用于支持 64 位指令系统

连接程序将汇编后的目标模块转换为可执行程序  
每个程序开发环境都有连接程序  
> 连接程序的文件名通常是：LINK.EXE  
32位Windows连接程序不同于16位DOS连接程序

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/86910c85c097faa70ddeb4b70df4856ecd69ead416ad291aa650bcd69d7730eb.jpg)

> 调试程序进行程序排错、分析等  
DOS 的 DEBUG 程序 (前 5 章可用)  
支持源程序调试的 CodeView  
还有 Turbo Debugger 等

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/33fe4823cfeeb87c02842c9e58bacd02a6c15eac9d686e0857bd2bb87ae569fc.jpg)

进行程序设计使用的各种软件的有机集合，有文本编辑器，有语言翻译程序，有连接程序，还组合有调试程序等  
大型的程序设计项目往往要借助这种集成开发环境，也就是软件开发工具（包）  
微软的 Visual Studio 开发系统

> 微处理器是微机的硬件核心，主要包含指令执行的运算和控制部件，还有多种寄存器  
对程序员来说，微处理器抽象为以名称存取的寄存器  
> 8086 内部结构有两个功能模块，完成一条指令的取指和执行功能  
总线接口单元BIU：负责读取指令和操作数  
执行单元 EU：负责指令译码和执行

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/7157ae7cec81c2e95190ca0e0de46b56fa559423b85369c393de6e2b1fba9b60.jpg)

# 8086 的寄存器

15 8 7 0

<table><tr><td>AH</td><td>AL</td></tr><tr><td>BH</td><td>BL</td></tr><tr><td>CH</td><td>CL</td></tr><tr><td>DH</td><td>DL</td></tr></table>

AX累加器

BX 基址寄存器

CX计数器

DX 数据寄存器

数据寄存器

通用寄存器

<table><tr><td>SI</td></tr><tr><td>DI</td></tr><tr><td>BP</td></tr><tr><td>SP</td></tr></table>

源地址寄存器

目的地址寄存器

基址指针

堆栈指针

变址寄存器

指针寄存器

15 0

<table><tr><td>CS</td></tr><tr><td>SS</td></tr><tr><td>DS</td></tr><tr><td>ES</td></tr></table>

代码段寄存器

堆栈段寄存器

数据段寄存器

附加段寄存器

段寄存器

8086 的 16 位通用寄存器是:

AX BX CX DX

SI DI BP SP

> 其中前 4 个数据寄存器都还可以分成高 8 位和低 8 位两个独立的寄存器  
8086 的 8 位通用寄存器是:

AH BH CH DH

AL BL CL DL

对其中某 8 位的操作，并不影响另外对应 8 位的数据

数据寄存器用来存放计算的结果和操作数，也可以存放地址  
每个寄存器又有它们各自的专用目的

■ AX ——累加器，使用频度最高，用于算术、逻辑运算以及与外设传送信息等；  
- BX ——基址寄存器，常用做存放存储器地址；  
CX ——计数器，作为循环和串操作等指令中的隐含计数器；  
- DX - - 数据寄存器，常用来存放双字长数据的高16位，或存放外设端口地址。

变址寄存器常用于存储器寻址时提供地址

■ SI是源变址寄存器  
■DI是目的变址寄存器

> 指针寄存器用于寻址内存堆栈内的数据

■ SP 为堆栈指针寄存器，指示栈顶的偏移地址，不能再用于其他目的，具有专用目的  
BP 为基址指针寄存器，表示数据在堆栈段中的基地址

> SI和DI在串操作指令有特殊用法  
> SP 和 BP 寄存器与 SS 段寄存器联合使用确定堆栈段中的存储单元地址

堆栈是主存中一个特殊的区域  
> 它采用先进后出 FILO（First In Last Out）或后进先出 LIFO（Last In First Out）的原则进行存取操作，而不是随机存取操作方式  
堆栈通常由处理器自动维护  
在8086中，由堆栈段寄存器SS和堆栈指针寄存器SP共同指示

> 标志（Flag）用于反映指令执行结果或控制指令执行形式，形成16位标志寄存器FLAGS（程序状态字PSW寄存器）  
状态标志——用来记录程序运行结果的状态信息，许多指令的执行都将相应地设置它

# CF ZF SF PF OF AF

控制标志——可由程序根据需要用指令设置，用于控制处理器执行指令的方式

# DF IF TF

15 12 11 10 9 8 7 6 5 4 3 2 1 0

<table><tr><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td></tr></table>

> 指令指针寄存器 IP，指示代码段中指令的偏移地址  
> 它与代码段寄存器 CS 联用，确定下一条指令的物理地址  
计算机通过CS：IP寄存器来控制指令序列的执行流程  
IP 寄存器是一个专用寄存器

8086 有 4 个 16 位段寄存器, 每个段寄存器确定一个逻辑段的起始地址, 每种逻辑段均有各自的用途  
CS (Code Segment)

指明代码段的起始地址

SS (Stack Segment)  
指明堆栈段的起始地址  
DS (Data Segment)  
指明数据段的起始地址  
ES (Extra Segment)  
指明附加段的起始地址

# 计算机中信息的单位

■二进制位 Bit：存储一位二进制数：0或1  
■字节 Byte：8 个二进制位， $\mathrm{D}_{7} \sim \mathrm{D}_{0}$  
■字Word：16位，2个字节， $\mathrm{D}_{15} \sim \mathrm{D}_{0}$  
■双字 DWord : 32 位, 4 个字节,  $D_{31} \sim D_{0}$

最低有效位 LSB：数据的最低位， $\mathbf{D}_0$  位  
> 最高有效位 MSB：数据的最高位，对应字节、字、双字分别指  $\mathrm{D}_{7} 、 \mathrm{D}_{15} 、 \mathrm{D}_{31}$  位

# D7 D0

78H

56H

12H

34H

00006H

00005H

00004H

00003H

00002H

00001H

0000H

D31

D7 D0

D15

D0

D0

D0

字节

字

双字

低地址

> 主存储器需要利用地址区别

每个存储单元都有一个编号；被称为存储器地址  
每个存储单元存放一个字节的内容

0002H 单元存放有一个数据

34H

表达为

[0002H] = 34H

> 多字节数据在存储器中占连续的多个存储单元:  
>存放：低字节存入低地址，高字节存入高地址  
>表达：用低地址表示多字节数据占据的地址空间

2号“字”单元的内容为:

$$
[ 0 0 0 2 H ] = 1 2 3 4 H
$$

2号“双字”单元的内容为：

$$
[ 0 0 0 2 H ] = 7 8 5 6 1 2 3 4 H
$$

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/f52909371219a2bb283e9d6be392f3d5df5fb2a7c38aede82dc744b09980936f.jpg)

80x86 处理器采用“低对低、高对高”：小端方式 Little Endian

>同一个存储器地址可以是字节单元地址、字单元地址、双字单元地址等等  
> 字单元安排在偶地址（xxx0B）、双字单元安排在模4地址（xx00B）等，被称为“地址对齐（Align）”  
对于不对齐地址的数据，处理器访问时，需要额外的访问存储器时间  
> 应该将数据的地址对齐，以取得较高的存取速度

8086 CPU 有 20 条地址线

最大可寻址空间为  $2^{20} = 1 \mathrm{MB}$  
■物理地址范围从 00000H ~ FFFFFFFH

>8086CPU 将 1MB 空间分成许多逻辑段 (Segment)

■每个段最大限制为64KB  
■段地址的低4位为0000B

>这样，一个存储单元除具有一个唯一的物理地址外，还具有多个逻辑地址

每个物理存储单元有一个唯一的 20 位编号, 即物理地址:

00000H ~ FFFFFFFH

分段后用户编程时，采用逻辑地址：

段基地址：段内偏移地址

分隔符

逻辑地址=相对地址：205（2层05号房间）  

<table><tr><td>301</td><td>302</td><td>303</td><td>304</td><td>305</td><td>306</td><td>307</td><td>308</td><td>309</td><td>310</td></tr><tr><td>201</td><td>202</td><td>203</td><td>204</td><td>205</td><td>206</td><td>207</td><td>208</td><td>209</td><td>210</td></tr><tr><td>101</td><td>102</td><td>103</td><td>104</td><td>105</td><td>106</td><td>107</td><td>108</td><td>109</td><td>110</td></tr></table>

物理地址=绝对地址：15（第15号房间）  

<table><tr><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td></tr><tr><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td></tr><tr><td>01</td><td>02</td><td>03</td><td>04</td><td>05</td><td>06</td><td>07</td><td>08</td><td>09</td><td>10</td></tr></table>

段地址说明逻辑段在主存中的起始位置  
8086 规定段地址必须是模 16 地址: xxxx0H  
省略低4位0000B，段地址就可以用16位数据表示，就能用16位段寄存器表达段地址  
偏移地址说明主存单元距离段起始位置的偏移量  
每段不超过 64KB，偏移地址也可用 16 位数据表示

将逻辑地址中的段地址左移4位，加上偏移地址就得到20位物理地址  
一个物理地址可以有多个逻辑地址

逻辑地址 1460:100、1380:F00

物理地址 14700H 14700H

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/3404091d5df655bf0fc965da2e120b575241fbb916862c8c5f1d8210621e06b9.jpg)

代码段用来存放程序的指令序列  
代码段寄存器CS存放代码段的段地址  
指令指针寄存器IP指示下条指令的偏移地址  
处理器利用 CS:IP 取得下一条要执行的指令

>堆栈段确定堆栈所在的主存区域  
堆栈段寄存器 SS 存放堆栈段的段地址  
堆栈指针寄存器 SP 指示堆栈栈顶的偏移地址  
处理器利用 SS:SP 操作堆栈顶的数据

数据段存放运行程序所用的数据  
数据段寄存器 DS 存放数据段的段地址  
各种主存寻址方式（有效地址 EA）得到存储器中操作数的偏移地址  
处理器利用 DS:EA 存取数据段中的数据

附加段是附加的数据段，也用于数据的保存：

$\diamond$  附加段寄存器 ES 存放附加段的段地址  
各种主存寻址方式（有效地址 EA）得到存储器中操作数的偏移地址  
处理器利用 ES:EA 存取附加段中的数据  
串操作指令将附加段作为其目的操作数的存放区域

程序的指令序列必须安排在代码段  
程序使用的堆栈一定在堆栈段  
程序中的数据默认是安排在数据段，也经常安排在附加段，尤其是串操作的目的区必须是附加段  
数据的存放比较灵活，实际上可以存放在任何一种逻辑段中

没有指明时，一般的数据访问在 DS 段；使用 BP 访问主存，则在 SS 段  
默认的情况允许改变，需要使用段超越前缀指令；8086指令系统中有4个：

CS: ；代码段超越，使用代码段的数据  
SS: ；堆栈段超越，使用堆栈段的数据  
DS: ; 数据段超越, 使用数据段的数据  
ES: ；附加段超越，使用附加段的数据

# 没有段超越的指令实例:

MOV AX,[2000H] ; AX←DS:[2000H]

; 从默认的 DS 数据段取出数据

采用段超越前缀的指令实例:

MOV AX,ES:[2000H]; AX←ES:[2000H]

; 从指定的 ES 附加段取出数据

# 段寄存器的使用规定

<table><tr><td>访问存储器的方式</td><td>默认</td><td>可超越</td><td>偏移地址</td></tr><tr><td>取指令</td><td>CS</td><td>无</td><td>IP</td></tr><tr><td>堆栈操作</td><td>SS</td><td>无</td><td>SP</td></tr><tr><td>一般数据访问</td><td>DS</td><td>CS ES SS</td><td>有效地址 EA</td></tr><tr><td>BP基址的寻址方式</td><td>SS</td><td>CS ES DS</td><td>有效地址 EA</td></tr><tr><td>内核伪源指针数</td><td>DS</td><td>CS ES CC</td><td>SI</td></tr></table>

# >8086对逻辑段要求:

■段地址低4位均为0  
■ 每段最大不超过 64KB

# >8086 对逻辑段并不要求:

■必须是64KB  
■各段之间并不要求完全分开（即可以重叠）

# 各个逻辑段独立

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/a89a76f4945dc2fa6b86f3ba27ebc14a80ad607488a48c269971a0c23e28666f.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/50926c0f7cb1e6f2489d82d72f624957bb6bb7ed96e2381a3c4520592f35fb3b.jpg)

1MB 空间最多能分成多少个段？

■每隔16个存储单元就可以开始一个段  
所以1MB最多可以有：

$$
2 ^ {2 0} \div 1 6 = 2 ^ {1 6} = 6 4 \mathrm {K} \text {个 段}
$$

1MB 空间最少能分成多少个段?

■每隔64K个存储单元开始一个段  
所以1MB最少可以有：

$$
2 ^ {2 0} \div 2 ^ {1 6} = 1 6 \text {个 段}
$$

> 指令系统设计了多种操作数的来源  
寻找操作数的过程就是操作数的寻址  
> 操作数采取哪一种寻址方式，会影响机器运行的速度和效率  
如何寻址一个操作数对程序设计很重要

# 上机实践的建议

# 配合调试程序单步执行每条指令

感性认识因直观而印象深刻

# 操作码

# 操作数

> 指令由操作码和操作数两部分组成  
操作码说明计算机要执行哪种操作，如传送、运算、移位、跳转等操作，它是指令中不可缺少的组成部分  
操作数是指令执行的参与者，即各种操作的对象  
有些指令不需要操作数，通常的指令都有一个或两个操作数，个别指令有3个甚至4个操作数

# 每种指令的操作码:

- 用一个唯一的助记符表示（指令功能的英文缩写）  
对应着机器指令的一个二进制编码

# > 指令中的操作数:

可以是一个具体的数值  
可以是存放数据的寄存器  
- 或指明数据在主存位置的存储器地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/d5d3f06d04933c4ca379cd668d76e954bb8b07f39d4a64a97078bee4e9cb5b9c.jpg)

1/2 字节

操作码

0/1 字节

mod reg r/m

0/1/2 字节

位移量

0/1/2 字节

立即数

MOV AX,BX ; 机器代码是 89 D8

> 第1个字节89是操作码（含w=1表示16位操作）  
> 第2个字节D8（11011000）是“mod reg r/m”

reg = 011 表示目的操作数为 BX  
mod = 11 和 r/m = 000 表示源操作数为 AX

1/2 字节

操作码

0/1 字节

mod reg r/m

0/1/2 字节

位移量

0/1/2 字节

立即数

MOV AL,[BX+SI+6]；机器代码是 8A 40 06

前一个字节 8A 是操作码（含 w = 0 表示 8 位操作）  
中间一个字节 40（01000000）是“mod reg r/m”字节

reg = 000 表示目的操作数为 AL  
- mod = 01 和 r/m = 000 表示源操作数为 [BX+SI+D8]

最后一个字节就是 8 位位移量（D8 =）06

# 操作码

# 操作数

mov al,05 ；机器代码是 B0 05

前一个字节 B0 是操作码（含一个操作数 AL），后一个字节 05 是立即数

mov ax,0102H ; 机器代码是 B8 02 01

前一个字节 B8 是操作码（含一个操作数 AX），后两个字节 02 01 是 16 位立即数（低字节 02 在低地址）

# 操作码 操作数 1, 操作数 2 ; 注释

> 操作数 2 , 称为源操作数 src , 它表示参与指令操作的一个对象  
> 操作数 1，称为目的操作数 dest，它不仅可以作为指令操作的一个对象，还可以用来存放指令操作的结果  
分号后的内容是对指令的解释

# MOV dest,src; dest<-src

功能：将源操作数 src 传送至目的操作数 dest

MOV AL,05H

MOV BX,AX

MOV AX,[SI]

MOV AX,[BP+06H]

MOV AX,[BX+SI]

; AL←05H

; BX←AX

; AX←DS:[SI]

; AX←SS:[BP+06H]

; AX←DS:[BX+SI]

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/0c40bda098bd2e6f1da3c87dc2fdff8cd34cefef0946b4fda07be19e32670042.jpg)

> 指令中的操作数直接存放在机器代码中，紧跟在操作码之后（操作数作为指令的一部分存放在操作码之后的主存单元中）  
这种操作数被称为立即数imm

- 它可以是 8 位数值 i8（00H ~ FFH）  
也可以是 16 位数值 i16（0000H ~ FFFFH）

立即数寻址方式常用来给寄存器赋值

MOV AL,05H

; AL←05H

MOV AX,0102H

; AX  $\leftarrow$  0102H

MOV

AX,0102H

;

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/fc077e62b6563e13118d90607ddef3dda9b5fa247dbf6eea2ad9b4271e4a1a82.jpg)  
存储器

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/7492ccf67ce9ec02cc62ebfd7c03d8b863443a3d8a58cfa00c1baeb41c367f23.jpg)

# 操作数存放在 CPU 的内部寄存器 reg 中:

8 位寄存器 r8：

AH、AL、BH、BL、CH、CL、DH、DL  
16 位寄存器 r16：

AX、BX、CX、DX、SI、DI、BP、SP  
4个段寄存器seg：

CS、DS、SS、ES

MOV AX,1234H ; AX←1234H

MOV BX,AX ; BX← AX

MOV BX,AX

; BX← AX

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/f66ed8f00314d32320ef2e6f50a207aeb28971d40d13bc2d1573a8a2cf196f43.jpg)

MOV BX, AX

> 指令中给出操作数的主存地址信息（偏移地址，称之为有效地址 EA），而段地址在默认的或用段超越前缀指定的段寄存器中  
> 8086 设计了多种存储器寻址方式

1. 直接寻址方式  
2. 寄存器间接寻址方式  
3. 寄存器相对寻址方式  
4. 基址变址寻址方式  
5. 相对基址变址寻址方式

有效地址在指令中直接给出  
默认的段地址在 DS 段寄存器，可使用段超越前缀改变

MOV AX,[2000H]  
; AX←DS:[2000H]  
; 指令代码: A10020  
MOV AX,ES:[2000H]  
; AX←ES:[2000H]  
; 指令代码: 26 A10020

MOV AX,[2000H] ; AX←DS:[2000H]

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/0bf2bcc257f2e4c81a15b8e51f9087fe1e354e61c4f86d7570d8665baa2cb970.jpg)  
存储器

有效地址存放在基址寄存器 BX 或变址寄存器 SI、DI 中  
默认的段地址在 DS 段寄存器，可使用段超越前缀改变

MOV AX,[SI] ; AX←DS:[SI]

有效地址是寄存器内容与有符号 8 位或 16 位位移量之和，寄存器可以是 BX/BP 或 SI/DI

有效地址 = BX/BP/SI/DI + 8/16 位位移量

段地址对应 BX/SI/DI 寄存器默认在 DS，对应 BP 寄存器默认在 SS；  
可用段超越前缀

$$
\mathsf {M O V A X}, [ \mathrm {D I} + 0 6 \mathrm {H} ]
$$

$$
; \quad A X \leftarrow D S: [ D I + 0 6 H ]
$$

$$
\mathsf {M O V A X}, [ \mathsf {B P} + 0 6 \mathsf {H} ]
$$

$$
; \quad A X \leftarrow S S: [ B P + 0 6 H ]
$$

有效地址由基址寄存器（BX或BP）的内容加上变址寄存器（SI或DI）的内容构成：有效地址  $= \mathrm{BX} / \mathrm{BP} + \mathrm{SI} / \mathrm{DI}$  
段地址对应 BX 基址寄存器默认是 DS，对应 BP 基址寄存器默认是 SS；可用段超越前缀

$$
\mathsf {M O V A X}, [ \mathsf {B X} + \mathsf {S I} ]
$$

$$
; \quad A X \leftarrow D S: [ B X + S I ]
$$

$$
\mathsf {M O V A X}, [ \mathsf {B P} + \mathsf {D I} ]
$$

$$
; \quad A X \leftarrow S S: [ B P + D I ]
$$

$$
\mathsf {M O V A X , D S :} [ \mathsf {B P + D I} ]
$$

$$
; \quad A X \leftarrow D S: [ B P + D I ]
$$

有效地址是基址寄存器 (BX/BP)、变址寄存器 (SI/DI) 与一个 8 位或 16 位位移量之和:

有效地址 = BX/BP + SI/DI + 8/16 位位移量

段地址对应 BX 基址寄存器默认是 DS，对应 BP 基址寄存器默认是 SS；可用段超越前缀

$$
\mathsf {M O V A X}, [ \mathrm {B X} + \mathrm {S I} + 0 6 \mathrm {H} ]
$$

$$
; \quad A X \leftarrow D S: [ B X + S I + 0 6 H ]
$$

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/b40c4b1231efd5fbd1b0d1b4443f3b91892d4e23fe967de8c47dfb7c40ddc327.jpg)

位移量可用符号表示

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/e6b4f2c93f639d6ed98661f5ce5cdec7d0027a42bc73b768b4c77a2221e1488c.jpg)

同一寻址方式有多种表达形式

# 位移量可用符号表示:

$$
\mathsf {M O V A X}, [ \mathsf {S I} + \mathsf {C O u n t} ]
$$

；COUNT是事先定义的变量或常量（就是数值）

MOV AX,[BX+SI+WNUM] ; WNUM 是变量或常量

同一寻址方式可以写成不同的形式:

MOV AX,[BX][SI] ; MOV AX,[BX+SI]

MOV AX,COUNT[SI] ; MOV AX,[SI+COUNT]

MOV AX,WNUM[BX][SI]

; 等同于 MOV AX,WNUM[BX+SI]

; 等同于 MOV AX,[BX+SI+WNUM]

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c77944d6-4864-4c1e-a489-91c7ba866622/202799ce5c85b8a5fa36e3416fc315cd140500979793f221411ab56a743b515d.jpg)  
禁止

i8——一个8位立即数  
i16——一个 16 位立即数  
>imm——代表 i8 或 i16  
dest——目的操作数  
>src——源操作数

> r8——任意一个 8 位通用寄存器

AH AL BH BL CH CL DH DL

> r16——任意一个 16 位通用寄存器

AX BX CX DX SI DI BP SP

reg——代表 r8 或 r16  
>seg———段寄存器

CS DS ES SS

> m8——一个 8 位存储器操作数单元 (所有主存寻址方式)  
> m16——一个 16 位存储器操作数单元 (所有主存寻址方式)  
>mem——代表 m8 或 m16

# 第1章教学要求

1. 了解微机系统的基本软硬件组成  
2. 熟悉汇编语言的基本概念和应用特点  
3. 掌握 8086 的寄存器组和存储器组织  
4. 掌握 8086 的寻址方式

习题

1.14 1.17 1.18 1.19 1.20 1.24

MOV AX,1234H ; AX←1234H  
$\Rightarrow$  MOV BX,AX ; BX←AX  
MOV AX,[2000H] ; AX←DS:[2000H]  
$\Rightarrow$  MOV SI,0102H ; SI←0102H  
MOV AX,[SI] ; AX←DS:[SI]  
$\mathrm{MOV}$  BX,0001H ; BX←0001H  
MOV SI,0002H ; SI←0002H  
MOV AX,[BX+SI] ; AX←DS:[BX+SI]