全局变量会存在.data段，完成了变量命名、内存分配和变量赋值
而局部变量，会把相对于bp的偏移地址放在.text段（即代码段），并且在代码段中完成变量的赋值，变量实际上存在堆栈之中。
但是有一个比较特殊的情况，static局部变量会被存在data段，不会存在text段以及在栈中分配内存。
若定义全局常量变量 const int c，不会在data段进行变量定义和内存分配，也不会在text段进行变量定义和内存分配
分配顺序：在C语言中先定义的变量会放在高字节（相对于后定义的变量），无论是在.data段还是在.text段。【请注意，反汇编的结果发现里面的偏移量都是负值，VAR_8 VAR_14对应的偏移量分别是-8h和-14h】
在使用printf函数来调用局部变量时：
变量入栈的顺序：从右向左的变量依次入栈。
调用常量和变量的区别：调用常量时，常量入栈 直接push 立即数；调用变量时，先将变量mov到寄存器里面，然后再push寄存器。（变量既可能在data段，也可能在堆栈里）
基本数据类型复习：
1.无符号数和有符号数：在内存里面，无符号数0xFFFFFFFF和有符号数-1是一样的。（int和unsigned int,对应汇编中都是双字类型）
2.bool类型和char类型:在内存里面，对应的都是字节类型，bool类型的变量等于false，对应的就是0xFFh，相当于char类型的变量等于-1）
3.指针、数组、字符串：
a.对于数组的定义，例如int x[]={1,2,3,4},应该是从后往前分配，后面的变量在高字节，前面的变量在低字节。中间的间隔是这个数字变量的类型，比如int就是差双字，4个bytes。例如一个实例：
```
VAR_18 ; 这个就是x数组的首地址，即1的地址
VAR_14
VAR_10
VAR_C ；这个就是4的位置
```
b.对于指针的定义，在32位系统中，指针默认分配4个字节的内存。指针是如何赋值的呢？假如要把前面那个int数组x的地址赋给新定义的指针a，汇编代码是什么样子？
```
mov eax,[ebp+var_C]
mov [ebp+var_34],eax ;假设已知指针a被分配到了var_34
```
c.字符串和字符数组有什么不同？字符串在分配内存时，只会分配一个占4字节内存的字符串地址变量和1个字节的终止符\0，这个字符串地址变量会指向数据段的真正字符串，地址在低字节，终止符在高字节。而字符数组和a中讨论的是一样的。因此，我们可以发现，无论字符串有多长，它都只会分配5个字节的空间，但是如果字符数组很长，假如长度为10，就需要分配10个字节的空间。
以下是char s[]="1234"; char x[]={'1','2','3','4'}的区别
```
VAR_28 ;字符串地址变量的地址
VAR_24 ;终止符的地址
mov eax,ds:dworld_xxxx ;真正数据段里面的字符串
mov [bp+var_28],eax;
mov cl,ds:byte_xxxx; 这个指向的应该是终止符
mov [bp+var_24],cl

VAR_31 ;1
VAR_32 ;2
VAR_33 ;3
VAR_34 ;4
然后依次赋初值
```
4.关注一下多维数组，其可以等效为一维数组呢。例如int x[2][3]={{1,2,3},{4,5,6}}
他的内存分配其实等价于int x[]={1,2,3,4,5,6}
x[1]等价于取{4,5,6}的首地址
