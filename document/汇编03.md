# 汇编语言程序设计

# Assembly Language Programming

主讲人：鲁宏伟luhw@hust.edu.cn

# 第三章

# 汇编语言程序格式

第2章学习了8086硬指令，第3章介绍MASM基本的伪指令。第3章重点掌握：

✓程序的格式、开发方法  
✓参数的表达、变量的定义  
✓ 变量和标号的属性

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/8d7afaa0a5c1f9f0e8a593b5c78aac5072f3bcc54bcfb503e54b0895f20f6bfd.jpg)

> 硬指令——使 CPU 产生动作、并在程序执行时才处理的语句，就是第 2 章学习的处理器指令

伪指令（Directive）——不产生CPU动作、在程序执行前由汇编程序处理的说明性语句，例如，数据说明、变量定义等等  
伪指令与具体的处理器类型无关，但与汇编程序的版本有关

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/8321dabf19fe8082f0e931d846ab310b2a66ec0488e2ece0af37c83cc4b95b81.jpg)

本课程采用微软宏汇编程序MASM

6.15

本节从汇编语言程序的语句格式出发，给出第一个示范性的汇编语言源程序，并演示汇编语言程序的过程：

编辑 汇编 连接 调试

即汇编语言程序的开发方法

(1) 执行性语句——由硬指令构成的语句，它通常对应一条机器指令，出现在程序的代码段中：

标号：硬指令助记符 操作数，操作数；注释

(2) 说明性语句——由伪指令构成的语句,它通常指示汇编程序如何汇编源程序:

名字 伪指令助记符 参数, 参数,... ; 注释

# 汇编语言语句实例

MOV CX,0 ;传送指令，具有2个操作数

DELAY:

NOP

;空操作指令，没有操作数，带有标号

LOOP DELAY

;循环指令，标号 DELAY 说明转移位置

BUFFER

DB 1,2,3,4,5,6,7

;数据定义伪指令，在主存中开辟7个连续的字节单元，初值依次为  $1 \sim 7$ ，BUFFER表示首地址

# 标号、名字与标识符

> 标号是反映硬指令位置（逻辑地址）的标识符，后跟一个冒号分隔  
> 名字是反映伪指令位置（逻辑地址）和属性的标识符，后跟空格或制表符分隔，没有一个冒号  
> 标识符（Identifier）一般最多由31个字母、数字及规定的特殊符号（如_、$、?、@）组成，不能以数字开头。默认情况下，汇编程序不区别标识符中的字母大小写  
一个程序中，每个标识符的定义是唯一的，还不能是汇编语言采用的保留字

保留字（Reserved Word）是汇编程序已经利用的标识符，主要有：

o 硬指令助记符——例如：MOV、ADD  
o 伪指令助记符——例如：DB、EQU  
o 操作符——例如：OFFSET、PTR  
寄存器名——例如：AX、CS  
o 预定义符号——例如： @data

硬指令助记符可以是任何一条处理器指令，也可以是一条宏指令  
伪指令助记符将在本章和下章学习  
前一章引入的定义字节数据和字符串的DB就是伪指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/f7efa4d9f3d75fdf77cb06194958600fe1b288eaac6553c545cfcfbc9f4a2815.jpg)

处理器指令的操作数可以是立即数、寄存器和存储单元  
伪指令的参数可以是常数、变量名、表达式等，可以有多个，参数之间用逗号分隔

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/91b76208f6ad9b109379133ba5743787a9102c178748f7dcbcb93ccbe1d81e01.jpg)

> 语句中由分号“;”开始的部分为注释内容，用以增加源程序的可读性  
必要时，一个语句行也可以由分号开始作为阶段性注释  
汇编程序在翻译源程序时将跳过该部分，不对它们做任何处理

> 语句的 4 个组成部分要用分隔符分开  
> 标号后用冒号，注释前用分号  
操作数之间和参数之间使用逗号分隔  
其他部分通常采用空格或制表符  
多个空格和制表符的作用与一个相同  
MASM 支持续行符 “\”

完整的汇编语言源程序由段组成

一个汇编语言源程序可以包含若干个代码段、数据段、附加段或堆栈段，段与段之间的顺序可随意排列  
需独立运行的程序必须包含一个代码段，并指示程序执行的起始点，一个程序只有一个起始点  
所有的可执行性语句必须位于某一个代码段内，说明性语句可根据需要位于任一段内  
通常，程序还需要一个堆栈段

源程序分别用两种格式书写  
第一种格式从MASM5.0开始支持

■简化段定义格式

第二种格式MASM5.0以前就具有  
■完整段定义格式

程序功能

Hello, Everybody!

# ;example.asm

# 简化段定义格式

# MASM 6.x 支持

.model small

.stack

.data

;在数据段定义数据

.code

startup

;在代码段填入指令序列

EXIT 0

;子程序代码

end

# ;lt301.asm (文件名)

.model small ;定义程序的存储模型  
.stack ;定义堆栈段  
.data ;定义数据段

# string db 'Hello, Everybody!',0dh,0ah,'$'

;在数据段定义要显示的字符串  
.code ;定义代码段  
. startup ;程序起始点，建立 DS、SS

mov dx,offset string ;指定字符串

mov ah,9

int 21h ;利用功能调用显示信  
exit 0 ;程序结束点，返  
end ;汇编结束  
例3.1

示信

; exampleb.asm

.model small

.stack

.data

;在数据段定义数据

.code

start : mov ax,@data

mov ds,ax

;在代码段填入指令序列

mov ax,4c00h

int 21h

;子程序代码

end start

简化段定义格式

MASM 5.x 支持

# 3.1.3 汇编语言程序的开发过程

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/190ec69fa9b7dbbf4f6db39b69d309978629aa890f0fc6a788a9cbea04acc4fd.jpg)

# 开发过程 0 : 准备工作

> 安装开发软件包  
默认在 D:\ML615 目录  
进入操作系统（模拟DOS环境）

运行 Windows 目录下的

COMMAND.COM

进入MASM开发目录

d:

cd \ml615

# 开发过程 1: 源程序的编辑

# 源程序文件要以ASM为扩展名

源程序文件的形成（编辑）可以通过任何一个文本编辑器实现：

DOS 中的全屏幕文本编辑器 EDIT  
其他程序开发工具中的编辑环境  
MASM 程序员工作平台 PWB 中的编辑环境

EDIT It301.asm

# 开发过程 2：源程序的汇编

汇编是将源程序翻译成由机器代码组成的目标模块文件的过程

MASM 6.x 提供的汇编程序是 ML.EXE :

ML /c lt301.asm

如果源程序中没有语法错误，MASM将自动生成一个目标模块文件（lt301 obj）；否则MASM将给出相应的错误信息

这时应根据错误信息，重新编辑修改源程序后，再进行汇编

连接程序能把一个或多个目标文件和库文件合成一个可执行程序（.EXE、.COM 文件）：

# LINK It301 obj

如果没有严重错误，LINK将生成一个可执行文件（It301.exe）；否则将提示相应的错误信息

这时需要根据错误信息重新修改源程序后再汇编、链接，直到生成可执行文件

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/986d858e880d64cbca5c7263a25e58acc6b95b20bda8a9b8a012399cd6a6104b.jpg)

汇编和连接过程可以依次自动完成

# 汇编和连接的依次自动实现

ML 汇编程序可自动调用 LINK 连接程序,实现汇编和连接的依次进行

ML It301.asm

汇编程序 ML.EXE 可带其他参数，常用

ML /FI /Sa lt301.asm

该命令除产生模块文件 lt301 obj 和可执行文件 lt301.exe 外，还将生成列表文件 lt301.lst

列表文件是一种文本文件，含有源程序和目标代码，对我们学习汇编语言程序设计和发现错误很有用。采用 /Sa 选项，将在列表文件中得到有些伪指令相应的硬指令

# 开发过程 4 : 可执行程序的调试

经汇编、连接生成的可执行程序在操作系统下只要输入文件名就可以运行:

# It301.exe

操作系统装载该文件进入主存，并开始运行

如果出现运行错误，可以从源程序开始排错，也可以利用调试程序帮助发现错误

本节详细讨论汇编语言程序语句的主要部分：

# 参数 变量名 标号

并引出相关的伪指令和操作符  
本节重点掌握:

常数的表达、  
■ 变量定义伪指令 DB/DW/DD、  
■地址操作符和类型操作符

在源程序语句格式的 4 个组成部分中,参数是指令的操作对象 (学习硬指令时被称为操作数), 参数之间用逗号分隔  
参数根据指令不同可以没有，可以有1个、2个或多个  
汇编语言程序中，指令参数有数值型，它的主要形式是常数和数值表达式；  
硬指令的操作数有立即数；立即数就要用数值型参数表达

> 汇编语言程序中，指令参数还有地址型，它的主要形式是标号和名字（变量名、段名、过程名等）  
硬指令的操作数有存储单元；存储单元就应该用地址型参数（存储器操作数）表达

# 变量定义（Define）伪指令为变量申请固定长度的存储空间，并可同时将相应的存储单元初始化

变量名 伪指令助记符 初值表

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/085a6d800486ae6ef45629be3431c4984b819f1cbebc42fa01aca50ab3b64def.jpg)

变量定义伪指令最常使用

变量名为用户自定义标识符，表示初值表首元素的逻辑地址；用这个符号表示地址，常称为符号地址  
变量名可以没有。这种情况，汇编程序将直接为初值表分配空间，无符号地址  
设置变量名是为了方便存取它指示的存储单元

初值表是用逗号分隔的参数  
主要由数值常数、表达式或？、DUP 组成

？——表示初值不确定，即未赋初值；

DUP——表示重复初值

DUP 的格式为:

重复次数 DUP(重复参数)

变量定义伪指令根据申请的主存空间单位分类

DB——定义字节伪指令  
$\gg$  DW——定义字伪指令  
DD——定义双字伪指令  
DF——定义3字伪指令  
DQ——定义4字伪指令  
DT——定义10字节伪指令  
还有定位伪指令

X

.data

; 数据段

db 'a',-5

db 2 dup(100),?

Y

db 'ABC'

字节单元定义实例

存储单元

偏移地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/9fac31dcc06d50323997151e63d7522bdbc5e3a07272e21bf813b4fc291f86a8.jpg)

# 字节变量的应用

mov al,X

;此处 X 表示它的第 1 个数据, 故  $A L \leftarrow {}^{\prime} a^{\prime}$

dec X+1

;对 X 为始的第 2 个数据减 1 , 故成为 -6

mov Y,al

;现在 Y 这个字符串成为 'aBC'

.data ; 数据段

count dw 8000h,?, 'AB'

maxint

equ 64h

number

dw

maxint

array dw maxint dup(0)

# 字单元定义实例

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/25f0232f26f930608c32025f15f7e088299ebd8b584464339e12b97701ebf283.jpg)  
存储单元  
偏移地址

# 字变量和字常量

字变量和字常量的定义:

WNUM量

EQU 5678H ; 定义 WNUM 为常

COUNT

DW 20H ;定义 COUNT 变量，假设在数据

段的偏移地址为  $10 \mathrm{H}$

字变量和字常量的应用：

MOV AX,[BX+SI+WNUM]

; MOV AX, [BX+SI+5678H]

MOV AX,COUNT

; MOV AX,[0010H]

MOV AX,[SI+COUNT]

; MOV AX,COUNT[SI]

; MOV AX,[SI+10H]

LEABX,COUNT

; LEABX,[0010H]

MOV BX,OFFSET COUNT

; MOV BX,0010H

# 定位伪指令

# 定位伪指令控制数据的偏移地址

# ORG 参数

ORG伪指令是将当前偏移地址指针指向参数表达的偏移地址：

ORG 100h ;从 100h 处安排数据或程序

ORG  $\$ +10$

;使偏移地址加 10 , 即跳过 10 个字节空

# 间

# 值

MASM 中, 符号“$”表示当前偏移地址

EVEN ;从偶地址开始  
> ALIGN n ;从 n 的整数倍地址开始

# (1) 地址属性

标号和名字对应存储单元的逻辑地址  
逻辑地址包括：段地址和偏移地址

# (2) 类型属性

标号、子程序名的类型可以是 NEAR（近）和 FAR（远），分别表示段内或段间  
变量名的类型可以是 BYTE（字节）、WORD（字）和 DWORD（双字）等

# 地址操作符

# 取得名字或标号的段地址和偏移地址两个属性

[ ] 将括起的表达式作为存储器地址

当前偏移地址

采用指定的段地址寄存器

OFFSET名字/标号

返回名字或标号的偏移地址

SEG 名字 / 标号

返回名字或标号的段地址

# 类型操作符

# > 类型操作符对名字或标号的类型属性进行有关设置

类型名 PTR 名字/标号

THIS 类型名

SHORT 标号

TYPE 名字/标号

SIZEOF 变量名

LENGTHOF 变量名

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/cb0125bd163d16742686a842e8bde6662e4882d9001f22bc1c2984e56c2660d0.jpg)

# 类型名 PTR 名字/标号

> PTR 操作符使名字或标号具有指定的类型  
> 类型名可以是

BYTE/WORD/DWORD/FWORD/QWORD/TBYTE

或者是 NEAR/FAR，还可以是由STRUCT、RECORD、UNION以及TYPEDEF定义的类型

mov al,byte ptr w_var ;w_var 是一个字变量

jmp far ptr n_label;n_label 是一个标号

> 使用 PTR 操作符，可以临时改变名字或标号的类型

# THIS 类型名

>利用 THIS 说明的操作数具有汇编时的当前逻辑地址，但具有指定的类型

b_var equ THIS byte

;按字节访问变量b_var，但与w_var的地址相同

w_var dw 10 dup(0) ;按字访问变量 w_var

fjump equ THIS far

;用fjump为段间转移（fjump label far）

njump: mov ax,w_var

;用 njump 为段内近转移，但两者指向同一条指令

LABEL 伪指令的功能等同于“EQU THIS”

# 第3章

.data ;定义数据段

X db 'a',-5

org 10

b_var equ THIS byte

Y dw 'AB'

WNUM EQU 5678H

org  $\S +4$

COUNT dw 20h

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/364173b0-84c6-47a2-925d-440a26831579/699d82e60d136dfd7f27038c689251a59d5b6f77b14fe4189236c32a2aa83e8a.jpg)

# TYPE 名字/标名

返回表明名字或标号类型的一个字量数值  
□对字节、字和双字变量依次返回 1、2 和 4；  
□对短、近和远转移依次返回 ff01h 、ff02h 和 ff05h

mov ax,TYPE w_var ; 汇编结果为 mov ax,2

mov ax,TYPE njump

;汇编结果为 mov ax,0ff02h (near 标号)

> 操作符 SIZEOF 返回整个变量占用的字节数  
> LENGTHOF 返回整个变量的数据项数（即元素数）

SIZEOF = LENGTHOHF × TYPE

> 详述汇编语言程序格式的组成部分  
首先，简单了解 DOS 支持的 exe 程序和 com 程序  
其次，重点掌握简化段定义格式的各条伪指令  
最后，理解完整段定义格式所包含的各种段属性

# exe 程序

> 利用程序开发工具，通常将生成 EXE 结构的可执行程序（扩展名为 .EXE 的文件）  
> 它可以有独立的代码、数据和堆栈段，还可以有多个代码段或多个数据段，程序长度可以超过64KB，执行起始处可以任意指定  
当 DOS 装入或执行一个程序时，DOS 确定当时主存最低的可用地址作为该程序的装入起始点。此点以下的区域称为程序段。在程序段内偏移 0 处，DOS 为该程序建立一个程序段前缀控制块 PSP（Program Segment Prefix），它占 256（=100h）个字节；而在偏移 100h 处才装入程序本身

# com 程序

>COM 程序是一种将代码、数据和堆栈段合一的结构紧凑的程序，所有代码、数据都在一个逻辑段内，不超过 64KB  
在程序开发时，需要满足一定要求并采用相应参数才能正确生成COM结构的程序  
> COM 文件存储在磁盘上是主存的完全影像，不包含重新定位的加载信息，与 EXE 文件相比其加载速度更快，占用的磁盘空间也少  
> 尽管 DOS 也为 COM 程序建立程序段前缀 PSP，但由于两种文件结构不同，所以加载到主存后各段设置并不完全一样

# ;example.asm

# 简化段定义格式

# MASM 6.x 支持

.model small

.stack

.data

;在数据段定义数据

.code

startup

;在代码段填入指令序列

EXIT 0

;子程序代码

end

# .MODEM 存储模型

使用简化段定义，必须有存储模型伪指令  
$\succ$  .model 语句必须位于所有段定义语句之前  
>存储模型决定一个程序的规模，确定进行子程序调用、指令转移和数据访问的缺省属性  
>MASM有7种不同的存储模型:

(1) TINY  
(3) COMPACT  
LARGE  
(7) FLAT

(2) SMALL  
(4) MEDIUM  
(6) HUGE

# TINY 微型模型

> 微型模型是MASM 6.0才引入的

用于创建 COM 类型程序

用微型模型编写汇编语言程序时，所有的段地址寄存器都被设置为同一值

这意味着代码段、数据段、堆栈段都在同一个段内，不大于 64KB；访问操作数或指令都只需要使用 16 位偏移地址

# SMALL 小型模型

一般的程序（例如本书的绝大多数程序示例和习题）都可用这种模型  
在小型模型下，一个程序至多只能有一个代码段和一个数据段，每段不大于64KB

这里的数据段是指数据段、堆栈段和附加段的总和，它们共用同一个段基址，总长度不可超过64KB；因此小模式下程序的最大长度为128KB

访问操作数或指令都只需要使用 16 位偏移地址；这意味着诸如指令转移、程序调用以及数据访问等都是近属性（NEAR），即小型模型下的调用类型和数据指针缺省分别为近调用和近指针

# COMPACT 紧凑模型

适合于数据量大但代码量小的程序  
> 紧凑模型下，代码段被限制在一个不大于64KB的段内；而数据段则可以有多个，超过64KB

这种模型下的调用类型缺省仍为近调用；而数据指针缺省为远（FAR）指针，因为必须用段地址来区别多个数据段

# MEDIUM 中型模型

>中型模型是与紧凑模型互补的模式  
适合于数据量小但代码量大的程序  
中型模型的代码段可以超过 64KB，

有多个；但数据段只能有一个不大于

64KB 的段

这种模型下的数据指针缺省为近指针;

但调用类型缺省是远（FAR）调用，因

为要利用段地址区别多个代码段

# LARGE 大型模型

>较大型程序通常采用的存储模型  
大型模型允许的代码段和数据段都有多个，都可以超过64KB；但全部的静态数据（不能改变的数据）仍限制在64K字节内大型模型下的调用类型和数据指针缺省分别为远调用和远指针

HUGE（巨型模型）与大型模型基本相同，只是静态数据不再被限制在64K字节之内

# FLAT 平展模型

$\succ$  平展模型用于创建一个32位的程序，  
它只能运行在 32 位 x86 CPU 上。  
> DOS 下不能使用 FLAT 模型,

而编写 32 位 Windows 9.x 或 Windows-NT 的程序时，必须采用 FLAT 模型。

DOS下编程可选择前六种模型，一般可以选用SMALL模型

TINY 模型产生 COM 程序，其他模型产生 EXE 程序，FLAT 模型只能用于 32 位程序

.STACK [ 大小 ]  
；堆栈段开始  
.DATA  
；数据段开始  
.CODE [段名]  
; 代码段开始

简化段定义伪指令指明一个逻辑段的开始，同时自动结束前面的一个段  
采用简化段定义伪指令前，需有 .model 语句  
> 使用简化段定义，各段名称和其他用户所需的信息可以使用MASM预定义符号，例如：

@data 表示由 .data 等定义的数据段的段名

# 堆栈段伪指令

# .STACK [ 大小 ]

> 堆栈段伪指令 .STACK 创建一个堆栈段，段名是： stack  
它的参数指定堆栈段所占存储区的字节数，默认是1KB（=1024=400h字节）

# 数据段伪指令

# .DATA

> 数据段伪指令 .data 创建一个数据段，段名是：_DATA。它用于定义具有初值的变量，当然也允许定义无初值的变量  
>无初值变量可以安排在另一个段中，它用 .data? 伪指令创建，数据段名是：_BSS  
> const 伪指令用于建立只读的常量数据段（段名：CONST）

# 代码段伪指令

# .CODE [段名]

• 代码段伪指令 .code 创建一个代码段,它的参数指定该代码段的段名  
如果没有给出段名，则采用默认段名：

在 TINY、SMALL、COMPACT 和 FLAT 模式下，默认的代码段名是：_TEXT

在 MEDIUM、LARGE 和 HUGE 模式下，默认的代码段名是：模块名 _TEXT

# . STARTUP

# 程序开始伪指令

按照CPU类型、存储模型、操作系统和堆栈类型，产生程序开始执行的代码；同时还指定程序开始执行的起始点  
在 DOS 下，还将设置 DS 值，调整 SS 和 SP 值

mov dx,@data

mov ds,dx

mov dx,dgroup

mov ds,dx ；设置

# DS

mov bx,ss

sub bx,dx

shl bx,1

shl bx,1

shl bx,1

shl bx,1

;关中断

mov ss,dx ; 调整 SS和SP

add sp,bx

cti·开中断

产生终止程序执行返回操作系统的指令代码  
它的可选参数是一个返回的数码，通常用0表示没有错误。例如 .exit 0 对应的代码是:

mov ax,4c00h

int 21h

DOS 功能调用的 4ch 子功能（返回 DOS）：

入口参数：AH = 4ch，AL = 返回数码

>指示汇编程序MASM到此结束汇编过程  
源程序的最后必须有一条 END 语句  
可选的标号用于指定程序开始执行点，连接程序将据此设置 CS：IP 值  
> 采用了 .startup 伪指令就不需要再用 “end 标号” 指明开始执行点，但还要有 end 伪指令

不要糊涂

程序终止和汇编结束是两码事

> 利用MASM6.x的简化段定义格式，可以非常容易地创建一个COM程序  
遵循的规则:

■采用TINY模型  
源程序只设置代码段，无数据、堆栈等段  
■ 程序必须从偏移地址 100h 处开始执行  
数据只能安排在代码段中，注意不能与可执行代码相冲突，通常在程序最后

.model tiny ;微型存储模型

.code ;只有代码段

startup ;程序起始点，=ORG 100H

mov dx,offset string

movah,9 ;显示信息

int 21h

movah,01h ;等待按键

int 21h

mov ah,02h ;响铃

mov dl,07h

int 21h

exit 0 ;程序结束点，返回 DOS

string db ‘Press any key to continue!$’

;数据安排在此

end ;汇编结束

例3.5：com程序

# ;examplec.asm

# COM 程序格式

# MASM 6.x 支持

# .model tiny

.code ;只有代码段

startup ;= org 100h

;填入指令序列

EXIT 0

;子程序代码

;在此定义数据

end

# 第3章教学要求（1）

1. 掌握汇编语言语句格式  
2. 掌握简化段定义源程序格式  
3. 掌握常量表达、变量定义及应用，变量、标号和逻辑段的属性  
4. 了解数值表达式和 DOS 的程序结构  
5. 掌握汇编语言源程序的编辑、汇编、连接和调试的开发方法

6. 掌握基本的伪指令:

.MODEM / .STACK / .DATA / .CODE / END  $= /$  EQU DB DW DD

7. 掌握基本的操作符:

+/-、? / DUP、OFFSET / PTR

习题 3.7 3.10 3.18 3.21