# 逆向工程分析技术

鲁宏伟

luhw@hust.edu.cn

# 第四章

# 理解程序逻辑和算术运算

本章从汇编的角度介绍数据的存储和访问、

基本程序逻辑和算术运算

- 随着反汇编和反编译技术的发展，从开发者的角度，对抗反汇编和反编译的技术也在不断迭代，对代码的加密和混淆可能变得更加平凡。常规的一些反汇编和反编译工具，在面对这样一些分析对象时，会无能为力。  
然而，无论开发人员如何对程序进行混淆或者加密，机器指令和汇编指令的关系是无法改变的。  
- 因此，借助于反汇编工具的辅助，如果能够正确地理解一些基本的程序逻辑，就可以从混淆的代码中抽丝剥茧，还原程序的真实运行逻辑，达成我们分析的目标。

# 数据的存储和访问

- 在学习汇编语言程序设计的时候，我们知道，哪怕一个最简单的程序，它至少要包括三个部分：代码段、数据段和堆栈段。  
- 代码段一般指保存程序指令的部分，数据段则用来保存程序中访问的数据，堆栈段则主要用以程序执行过程中数据的缓存。  
- 数据是程序指令执行的对象，理解数据的存储和访问对于理解程序的逻辑至关重要

# 常量和变量

- 常量通常指一个给定的数值（整数或者浮点数），而在不同的程序语言中，其含义会有些不同。例如，C 语言中，常量除了通常的意义之外，有时是指用 const 关键词修饰的变量（后文提到的常量均指这种变量），只能在定义时赋值，此后不得修改。  
- 变量通常是指程序执行过程中其值可以被随时修改的量，又被分为局部变量和全局变量，此外 C 语言中还有一类被称为静态变量（用关键词 static 修饰的变量）。

# 常量和变量

代码4.1  
```c
include<stdio.h>   
int g_a=-1;   
const int gc_c=2;   
static int gs_b=1;   
void func();   
int main()   
{ int  $\mathbf{x} = -1$  unsigned int y  $=$  0xFFFFFF, printf("x=%d,y=%d",x,y); func(); return 0;   
}
```

```c
void func(){ int  $\mathbf{x} = 2$  static short  $\mathrm{y} = 0\mathrm{x}$  ffffff,//int→short会被截断 const int cons_z=3; printf("x=%d,y=%d,cons_z",x,y,cons_z); printf("g_a=%d,gs_b=%d,gc_c=%d",g_a,gs_b,gc_c);   
1
```

# 常量和变量

代码4.1  
```c
include<stdio.h>   
int g_a=-1;   
const int gc_c=2;   
static int gs_b=1;   
void func();   
int main()   
{ int  $\mathrm{x} = -1$  unsigned int y  $=$  0xFFFFFF printf("%d,y=%d",x,y); func(); return 0;   
}
```

```asm
.text:004113C0 _main_0 proc near ; CODE XREF: _main↑j  
.text:004113C0  
.text:004113C0 var_D8 = byte ptr -0D8h  
.text:004113C0 var_14 = dword ptr -14h  
.text:004113C0 var_8 = dword ptr -8
```

```asm
.text:004113DE mov [ebp+var_8], 0FFFFFFFh  
.text:004113E5 mov [ebp+var_14], 0FFFFFFFh  
.text:004113EC mov esi, esp  
.text:004113EE mov eax, [ebp+var_14]  
.text:004113F1 push eax  
.text:004113F2 mov ecx, [ebp+var_8]  
.text:004113F5 push ecx  
.text:004113F6 push offset Format ; "x=%d, y=%d"  
.text:004113FB call ds:printf
```

# 常量和变量

# 代码4.1

include<stdio.h>

int g_a = -1;

const int gc_c = 2;

static int gs_b = 1;

void func();

int main()

{

int  $\mathbf{x} = -1$

unsigned int y = 0xfffff

printf("x=%d, y=%d", x, y);

funcQ;

return 0;

}

void func0{

int  $\mathrm{x} = 2$  ;

static short y = 0xffffff; //int→short 会被截断

const int cons_z = 3;

printf("x=%d, y=%d, cons_z", x, y, cons_z);

printf("g_a=%d, gs_b=%d, gc_c=%d", g_a, gs_b, gc_c);

.text:00411440 sub_411440 proc near;

.text:00411440

.text:00411440 var_D8 =byte ptr -0D8h

.text:00411440 var_14 = dwordptr-14h

.text:00411440 var_8 = dwordptr -8

#

.text:0041145E mov [ebp+var_8], 2

.text:00411465 mov [ebp+var_14], 3

.text:0041146C mov esi,esp

text:0041146E push 3

.text:00411470 movsx' eax, word_417008

.text:00411477 push eax

.text:00411478 mov ecx, [ebp+var_8]

.text:0041147B push ecx

.text:0041147C push offset aXYDConsZ; "x=%d, y=%d, cons_z"

.text:00411481 call ds:.printf

# 常量和变量

代码4.1

include<stdio.h>

int g_a = -1;

const int gc_c = 2;

static int gs_b = 1;

void func();

int main()

{ int  $\mathbf{x} = -1$

unsigned int y = 0xfffff

printf("x=%d, y=%d", x, y);

func0;

return 0;

}

void func(){

int  $\mathbf{x} = 2$

static short y = 0xffffff; //int→short 会被截断

const int cons_z = 3;

printf("x=%d, y=%d, cons_z", x, y, cons_z);

printf("g_a=%d, gs_b=%d, gc_c=%d", g_a, gs_b, gc_c);

.text:00411493

.text:00411495

.text:0041149A

.text:0041149B

.text:004114A1

.text:004114A2 push offset aGADGsBDGcCD ;"g_a=%d..."

.text:004114A7

.text:00411440 sub_411440 proc near;

.text:00411440

.text:00411440 var_D8 =byte ptr -0D8h  
.text:00411440 var_14 = dwordptr-14h  
.text:00411440 var_8 = dword ptr -8

#

.text:00411493 push 2

mov eax,dword 417004  
push eax  
mov ecx,dword 417000  
push ecx

.text:004114A2 push offset aGADGsBDGcCD ;"g_a=%d..."

.text:004114A7 call ds:printf

data:00417000_data  
.data:00417000  
.data:00417000  
.data:00417000 dword_417000  
.data:00417004 dword_417004  
.data:00417008 word_417008  
data:0041700A  
.data:0041700C;int dword_41700C  
.data:0041700C dword_41700C

segment para public 'DATA' use32

assume cs:_data

org 417000h

dd 0FFFFFFF

dd 1

dw 0FFFFH

align 4

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7ecba567cec0c952119951b5756536115be521a6afa4b64b994fd87bd8d0cea1.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/b8f679c2acf44b299e635cfb3fe1382d46644b57a128c7dccc1847ca7be90fc5.jpg)

全局变量g_a的偏移地址和初始值

全局变量gs b (静态变量) 的偏移地址和初始值

局部变量y（静态变量）的偏移地址和初始值

440+5B↑r

$0 + 5 \in  B$

; DATA XREF: _RTC_Failure(void

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/615f97acdc70062dd153ab5706905d12c440d5bac73aaaf0249ab76d47d0f633.jpg)

# 基本数据类型

- 有符号数和无符号数  
char 和布尔类型  
- 整数类型和浮点数类型

# 基本数据类型 - 有符号数和无符号数

- 在 C/C++ 中, 整数类型分为有符号数和无符号数。  
- 在数据宽度相同的时候，它们所能表达的范围是不同的。  
- 这是因为对于有符号数来说，使用最高位来表示数字的正负，当最高位为 1 时是负数，否则为正数。对于 int 类型数据来说，0x00000000 到 0x7FFFFFFF 用来表示正数，而 0x80000000 到 0xFFFFFFF 用来表示负数。  
- 而在内存中的形式究竟如何?

# 基本数据类型 - 有符号数和无符号数

代码4.1  
```c
include<stdio.h>   
int g_a=-1;   
const int gc_c=2;   
static int gs_b=1;   
void func();   
int main()   
{ int  $\mathrm{x} = -1$  unsigned int y  $=$  0xFFFFFF printf("x=%d,y=%d",x,y); func(); return 0;   
}
```

```asm
.text:004113C0_main_0 proc near ; CODE XREF: _main↑j  
.text:004113C0  
.text:004113C0 var_D8 = byte ptr -0D8h  
.text:004113C0 var_14 = dword ptr -14h  
.text:004113C0 var_8 = dword ptr -8
```

```asm
.text:004113DE mov [ebp+var_8], 0FFFFFFFh  
.text:004113E5 mov [ebp+var_14], 0FFFFFFFh  
.text:004113EC mov esi, esp  
.text:004113EE mov eax, [ebp+var_14]  
.text:004113F1 push eax  
.text:004113F2 mov ecx, [ebp+var_8]  
.text:004113F5 push ecx  
.text:004113F6 push offset Format ; "x=%d, y=%d"  
.text:004113FB call ds:printf
```

# 基本数据类型 -char 和布尔类型

# 代码4.2

```lisp
include<stdio.h>   
int main()   
{ char  $\mathbf{x} = -1$  booly=true; printf("x=%d,y=%d",x,y); return0;   
}
```

```asm
.text:004113C0 _main_0 proc near ; CO  
.text:004113C0  
.text:004113C0 var_D8 = byte ptr -0D8h 1 char变量  
.text:004113C0 var_11 = byte ptr -11h  
.text:004113C0 var_5 = byte ptr -5 2 bool变量  
.text:004113C0  
.text:004113C0 push ebp  
.text:004113C1 mov ebp, esp  
.text:004113C3 sub esp, 0D8h  
.text:004113C9 push ebx  
.text:004113CA push esi  
.text:004113CB pushEDI  
.text:004113CC leaEDI, [ebp+var_D8]  
.text:004113D2 mov ecx, 36h  
.text:004113D7 mov eax, 0CCCCCCCCH  
.text:004113DC rep stosd  
.text:004113DE mov [ebp+var_5], 0FFh  
.text:004113E2 mov [ebp+var_11], 1  
.text:004113E6 movzx eax, [ebp+var_11]  
.text:004113EA mov esi, esp  
.text:004113EC push eax  
.text:004113ED movsx ecx, [ebp+var_5]  
.text:004113F1 push ecx  
.text:004113F2 push offset Format ; "x=  
.text:004113F7 call ds:printf
```

; CODE XREF: _main↑j

char变量y   
2 bool变量x

push ebp  
mov ebp, esp  
sub esp, 0D8h  
push ebx  
push esi  
pushEDI  
leaedi,[ebp+var_D8]  
mov ecx, 36h  
mov eax, 0CCCCCCCCH  
rep stosd

mov [ebp+var_5], 0FFh  
mov [ebp+var_11], 1

movzx eax, [ebp+var_11]  
mov esi, esp  
push eax

movsx ecx, [ebp+var_5] push ecx

```batch
push offset Format ; "x=%d, y=%d" call ds:printf
```

3 将两个变量的初值放入栈中  
将栈中的值取出到寄存器中

# 基本数据类型 - 浮点数类型

- 在  $C / C + +$  中，浮点数用 float（单精度）和 double（双精度）来表示。其中，float 占 4 个字节，double 占 8 个字节。  
- 由于计算机只能存储整数，不能存储小数。所有浮点数在计算机中的保存与使用是使用了特殊的编码方式，即 IEEE 编码。  
- 以单精度为例，在内存中的存储格式如下（左边为高位）：

1 位符号

8位指数

23 位尾数

- 其中符号位 1 表示负数, 0 表示正数, 这与整数形式的符号位意义相同

# 基本数据类型 - 浮点数类型

- 与普通的数据类型不同，对于浮点数的操作是通过一组特殊的寄存器来实现的。  
- 这组特殊的寄存器就是 FPU 寄存器，这组寄存器一共有八个用来存储浮点数的寄存器，分别是 ST(0)-ST(7)，每个寄存器都是 80 位寄存器  
- 此外还包括 3 个程序员可以使用的 16 位寄存器（控制寄存器、状态寄存器和特征寄存器）。

# 基本数据类型 - 浮点数类型

- 16 位控制寄存器被程序员用于在 FPU 的各种计算模式之间进行选择, 并且定义了哪个异常会被 FPU 处理或被程序员定义的异常处理器处理。  
- 16 位状态寄存器指出了 FPU 的一般状态。当每条指令执行完后它的内容可能会有所改变。一部分的状态不能被程序员直接改变。它可以在任何时间被间接访问以便观测其内容。  
- 16 位特征寄存器被 FPU 管理用来处理它本身所包含的每个 80 位寄存器的一些信息。

# 基本数据类型 - 浮点数类型

- 8 个数据寄存器组成一个循环堆栈, 栈顶记录保存于状态寄存器中, 相当于堆栈指针。  
- 每次压栈（FLD指令载入数据），堆栈指针就减1，在0～7之间循环。代码并不直接使用这个指针操作这些寄存器，而是使用  $\mathrm{ST}(0) \sim \mathrm{ST}(7)$  表示。ST(0)指栈顶，即状态寄存器中栈顶指针指示的那个寄存器。  
- 而对于这组寄存器的操作也是通过一组特殊的浮点数指令来进行操作。

# 基本数据类型 - 浮点数类型

• 常见的浮点数运算指令如下表所示，而对于其他的指令和基础指令的差别只是多了一个  $\mathrm{F}$  。

表 4.1 浮点数运算指令  ${}^{2}$  

<table><tr><td>FCHS</td><td>修改符号</td></tr><tr><td>FADD</td><td>源操作数与目的操作数相加</td></tr><tr><td>FSUB</td><td>从目的操作数中减去源操作数</td></tr><tr><td>FSUBR</td><td>从源操作数中减去目的操作数</td></tr><tr><td>FMUL</td><td>源操作敏与目的操作数相乘</td></tr><tr><td>FDIV</td><td>目的操作数除以源操作数</td></tr><tr><td>FDIVR</td><td>源操作数除以目的操作数</td></tr></table>

表 4.2 数据传输指令  

<table><tr><td>FLD</td><td>加载浮点数值。将浮点操作数复制到 FPU 堆栈栈顶(称为 ST(0))。操作数可以是 32 位、64 位、80 位的内存操作数 (REAL4、REAL8、REAL10) 或另一个 FPU 寄存器</td></tr><tr><td>FILD</td><td>加载整数。将 16 位、32 位或 64 位有符号整数源操作数转换为双精度浮点数,并加载到 ST(0)。</td></tr><tr><td>FST</td><td>保存浮点数值。浮点操作数从 FPU 栈顶复制到内存。FST 支持的内存操作数类型与 FLD 一致。</td></tr><tr><td>FSTP</td><td>保存浮点值并将其出栈。将 ST(0)的值复制到内存并将 ST(0)弹出堆栈。</td></tr><tr><td>FIST</td><td>保存整数。将 ST(0) 的值转换为有符号整数,并把结果保存到目标操作数。保存的值可以为字或双字。FIST 支持的内存操作数类型与 FST 一致。</td></tr></table>

# 基本数据类型 - 浮点数类型

int main()

{

float  $\mathbf{x} = -1.24$

double y = 3.1415926;

double  $z = y^{*}x$

printf("mul:%f",z);

$\mathbf{z} = \mathbf{x} + \mathbf{y}$

printf("add:%f",z);

return 0;

}

.text:004136FE  
.text:00413704  
.text:00413707  
.text:0041370D  
.text:00413710  
.text:00413713  
.text:00413716  
.text:00413719  
.text:0041371B  
.text:0041371E  
.text:00413721  
.text:00413724  
.text:00413729

.text:004136E0; int __cdecl main_0(int argc, const char **argv, const char **envp)

.text:004136E0 _main_0 proc near ; CODE XREF:_main†j  
.text:004136E0  
.text:004136E0 var_100  
.text:004136E0 var_EC  
.text:004136E0 var 28  
.text:004136E0 var 18  
.text:004136E0 var_8  
.text:004136E0 argc  
.text:004136E0 argv  
.text:004136E0 envp  
3  
double z  
2  
double y  
11  
floatx

.text:0041373C

x=  
y=3.14...  
#  
$\frac{1}{2} =$  
= yX  
$\frac{1}{2} =$  
  
fld ds:flt 415744  
fstp [ebp+var 8]  
fld ds:dbl 415780  
fstp [ebp+var_18]  
fld [ebp+var_8]  
fmul [ebp+var_18]  
fstp [ebp+var_28]  
mov esi,esp  
sub esp, 8  
fld [ebp+var_28]5  
fftp [esp+100h+var_100  
push offset Format ; "mul:%f"  
call ds:printf

t:0041373F   
t:00413742  
t:00413744  
t:00413747  
t:0041374A   
t:0041374D   
t:00413752

.rdata:00415744 flt_415744  
.rdata:00415748  
.rdata:00415750 aFDdVctoolsC  
.rdata:00415750  
.rdata:004157B0 dbl_4157B0  
.rdata:004157B8;const char aAddF[ ]

1

fadd  
fstop  
mov  
sub  
fld  
fstop  
push  
call

[ebp+var_0] [ebp+var_18]  
[ebp+var_28]  
esi, esp  
esp,8  
[ebp+var_28]3  
[esp+100h+var_100]  
offset aAddF ; "add:%f"  
ds:printf  
$z = y + x$  
2  
3  
ar_1004  
; add:%f"  
  
1  
1:%f"

x的初值，4字节

DATA

2

y的初值

8节01

: DATA

#

# 指针、数组和字符串

- 指针是  $C / C + +$  最有特色的数据类型, 其中保存着某个数据的地址, 而对指针的引用可以让我们获取对应类型的数据。  
- 那么不同类型的指针在内存中有什么样的不同，它们又是如何获取地址中的数据的。

# 指针、数组和字符串

```txt
int main()
```

```txt
{
```

```latex
int  $\mathbf{x}[] = \{1,2,3,4\}$
```

```javascript
char s[] = "1234";
```

```txt
char \*a;
```

```txt
int *z;
```

```latex
$\mathbf{z} = \& \mathbf{x}[0]$
```

```txt
printf("%d",z);
```

```txt
a=s;
```

```txt
printf("%s",a);
```

```txt
return 0;
```

```txt
}
```

```txt
__main_0 proc near ; CODE XREF: __main $\uparrow$ j
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c47d128ab5ea32eb3ccb5bc0a5ef4b4051011516fa7626075816c3f255e0933f.jpg)

```css
.text:004113CE
```

```css
.text:004113D3
```

```css
.text:004113D5
```

```css
.text:004113D8
```

```txt
lea eax, [ebp+var_28]
```

```txt
mov [ebp+var_34], eax
```

```txt
mov esi, esp
```

```txt
mov eax, [ebp+var_34]
```

```txt
push eax
```

```batch
push offset aS
```

```txt
call ds:printf
```

```txt
1
```

获取字符串s的首地址，保存到栈中

```txt
C
```

将字符串s的首地址PUSH到栈中

```css
.text:0041140D
```

```css
.text:00411410
```

```css
.text:00411411
```

```txt
.text:00411416
```

```txt
mov eax,dword_417000
```

```txt
xor eax,ebp
```

```txt
mov [ebp+var_4], eax
```

```txt
mov [ebp+var_18], 1
```

```txt
mov [ebp+var_14], 2
```

```txt
mov [ebp+var_10], 3
```

```txt
mov [ebp+var_C], 4
```

```txt
mov eax, ds:dword 415744
```

```txt
mov [ebp+var_28], eax
```

```txt
mov cl, ds:byte_415748
```

```txt
mov [ebp+var 24], cl
```

```txt
lea eax, [ebp+var_18]
```

```txt
mov [ebp+var 40], eax
```

```txt
mov esi,esp
```

```txt
mov eax, [ebp+var_40]
```

```txt
push eax
```

```txt
push offset Format
```

```txt
call ds:printf
```

对数组变量x赋初值

对字符串变量赋初值

字符串末尾以\0结束

获取var_18（对应&x[0]）处的地址，保存到var_40处

将x[0]的地址PUSH到栈中

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6004600b68a8bcd63ce5ba2c11e4401e0f0ec4f4230b93b94c96cce40487edb2.jpg)

# 指针、数组和字符串

- 在 C/C++ 中, 使用数组来保存一组连续的相同类型的数据。  
- 那么不同类型的数组在内存中的表现形式究竟如何?  
- 它们与指针的关系又是怎么样的？

# 指针、数组和字符串

```txt
int main()
```

```txt
{
```

```javascript
int x[] = {1,2,3,4};
```

```javascript
char s[] = {'1', '2', '3', '4'};
```

```txt
char\*a;
```

```txt
int *z;
```

```latex
$\mathbf{z} = \mathbf{x}$
```

```javascript
printf("%d",*z);
```

```latex
$\mathbf{a} = \mathbf{s}$
```

```txt
printf("%s",a);
```

```txt
return 0;
```

.text:004113B0; int __cdecl main_0(int argc, const char **argv, const char **envp)

.text:004113B0 _main_0 proc near ; CODE XREF: _main↑j

```css
.text:00411380
```

```txt
.text:004113B0 var_100
```

```css
.text:004113B0 var_3C
```

```asm
.text:004113B0 var_30
```

```asm
.text:004113B0 var 24
```

```asm
.text:004113B0 var_23
```

```asm
.text:004113B0 var22
```

```asm
.text:004113B0 var 21
```

```asm
.text:004113B0 var_18
```

```asm
.text:004113B0 var_14
```

```asm
.text:004113B0 var_10
```

```asm
.text:004113B0 var_C
```

```asm
.text:004113B0 var_4
```

```txt
text:004113D5
```

```txt
text:004113D8
```

```txt
text:004113DF
```

```txt
text:004113E6
```

```txt
text:004113ED
```

```txt
text:004113F4
```

```txt
text:004113F8
```

```txt
text:004113FC
```

```txt
text:00411400
```

```txt
text:00411404
```

```txt
text:00411407
```

```txt
text:0041140A
```

```txt
text:0041140C
```

```txt
text:0041140F
```

```txt
text:00411411
```

```txt
text:00411412
```

```txt
text:00411417
```

```txt
=byte ptr -100b
```

```txt
= dword ptr -3Ch
```

```txt
-dword pte 10h
```

```txt
=byte ptr -24h
```

```txt
=byte ptr -23h
```

```txt
=byte ptr -22h
```

```txt
=byte ptr -21h
```

```txt
= dword ptr -18h
```

```txt
= dword ptr -14h
```

```txt
= dword ptr -10h
```

```txt
= dword ptr -0Ch
```

```txt
= dword ptr -4
```

mov [ebp+var_4], eax

mov [ebp+var_18], 1  
mov [ebp+var_14], 2  
mov [ebp+var_10], 3  
mov [ebp+var C], 4  
mov [ebp+var_24], 31h ; '1'  
mov [ebp+var_23], 32h ; '2'  
mov [ebp+var_22], 33h ; '3'  
mov [ebp+var21],34h;4

lea eax, [ebp+var_18]  
mov [ebp+var_3C], eax  
mov esi,esp  
mov eax, [ebp+var_3C]  
mov ecx, [eax]  
push ecx  
push offset Format ; %d  
call ds:printf

为数组x预留的空间

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/608ae4c1cbfbc1a23acdd6fc6a691ede5b50c48cf091c1c6392261010f41fee0.jpg)

对数组  $\mathbf{x}$  初始化

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/13a87116d08eb7bf43bbdde3df3d4c130e0e1496092eb2fad2a4dc0626847380.jpg)

对数组s初始化

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/f83a4e1af1c8394fdd84119905f30f54831b452e6da645ad7c275a37c183358c.jpg)

获取数组  $\mathrm{x}$  的首地址,保存到指针变量的地址空间中

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/75f73067d219e0a4e87461e18d38bf3ddf550a534874a8843355528c6b6cb80e.jpg)

取出指针变量的地址，从该地址中取出4个字节（对应x[0]），PUSH到栈中

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/9720c312aa0ed3c1c5332edde6a2f18e66fa0b184574396fa550fefb546b13a5.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/65173695dd6dcd3b1dd3baae005bcacd3380762f3a2c653c82fed34548669a4b.jpg)

，

# 指针、数组和字符串

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/5043d49e002446e6e173637bf4cdb724359359f78e99da3ef4bef5d4a2651800.jpg)

text:004113D8

text:004113DF

text:004113E6

text:004113ED

text:004113F4

text:004113FB

text:00411402

text:00411405

text:00411408

text:0041140A

text:0041140D

text:0041140F

text:00411410

text:00411415

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c38a47b2b460116d80a5d36c5d547ae91e93cf2fdd347327af6d60dfd47e0615.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/30638913841763c651ad75223f284077f73eb38ac2bf810e4b1a62a5787e5a3b.jpg)

# 对二维数组x初始化

lea eax, [ebp+var_14]  
mov [ebp+var_2C], eax

mov esi,esp

mov eax, [ebp+var_2C]  
mov ecx, [eax]

push ecx

push offset Format ; %c  
call ds:printf

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/ce8646ef16ffef2b090a3c3619322f1c2d589dffbd542a645875c531d0f691e6.jpg)

获取数组元素x[1]的地址，保存在为指针变量y预留的地址空间中

取出指针变量y的保存的地址(x[1])，取出该地址的值，PUSH到栈中

，

# 指针、数组和字符串

- 在 C/C++ 中，用 "" 包围的字符被称为字符串，每个字符串的最后都是以 0 作为字符串的结束。  
- 那么字符串在内存中是如何保存的和我们的字符有什么不同。  
前面的示例中定义了字符串变量 chars[] = "1234"，和 chars[] = {'1', '2', '3', '4'}。  
- 前者，编译器在处理的时候，是将字符串保存在数据段，然后通过地址访问该字符串；后者，则是将其视为数组，进行处理。  
- 这是编译器在处理二者的主要区别。

# 结构体和联合体

• C/C++ 可以通过使用结构体来自定义一组由程序员自己指定的不同类型的数据，那么它在内存中是如何保存的呢？

```c
#pragma pack(1) #include<stdio.h> #include<string.h> typedef struct stu_test { char cTest; int iTest; char arrTest[3]; }STest; int main() { STest \*pst; STest st  $=$  {1}; st.iTest  $= 0\mathrm{x}12345678$  ; strcpy(st.arrTest,"ab"); pst  $=$  &st; printf("%s",pst->arrTest); return 0;   
}
```

# 结构体

#pragma pack(1)

include<stdio.h>

include <string.h>

typedef struct stu_test{

char cTest;

int iTest;

char arrTest[3];

}STest;

int main()

1

STest \*pst;

$\mathrm{STestst} = \{1\}$

st.iTest  $= 0\mathrm{x}12345678$

strcpy(st.arrTest,"ab");

pst = &st;

printf("%s", pst->arrTest);

return 0;

}

.text:00413780_main_0

.text:00413780

.text:00413780 var E0

.text:00413780 var 1C

.text:00413780 var_18

.text:00413780

.text:00413780 var 15

.text:00413780 var C

.text:00413780 var_4

.text:0041379E

.text:004137A3

.text:004137A5

.text:004137A8

.text:004137AC

.text:004137AE

.text:004137B1

.text:00413785

.text:004137B8

.text:004137BF

.text:004137C4

.text:004137C7

.text:004137C8

.text:004137CD

.text:004137D0

.text:004137D3

.text:004137D6

.text:004137D9

.text:004137DC

.text:004137DE

.text:004137DF

.text:004137E4

proc near

=byte ptr -0E0h  
=byte ptr -1Ch  
= dword ptr -1Bh  
=byte ptr -17h  
=byte ptr -15h  
= dword ptr -0Ch  
= dword ptr -4

; CODE XREF: _main†j

为结构体st成员变量预留的空间

保存结构指针pst

mov eax, dword_417000

xor eax,ebp

mov [ebp+var_4], eax

mov [ebp+var_1C], 1

xor eax, eax

mov [ebp+var_1B], eax

mov word ptr [ebp+Dest], ax

mov [ebp+var_15], al

mov [ebp+var 1B], 12345678

push offset Source ; "ab"

lea eax, [ebp+Dest]

push eax

call j_strcpy

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/22b1b5e7e8b00d3dc993fa34d86d24f1d82f2c66719a5feed69ed397b541bac1.jpg)

初始化结构体，未指定初始值的成员变量赋值0

为成员变量iTest赋值

为成员变量arrTest赋值

add esp, 8

lea eax, [ebp+var_1C]

mov [ebp+var_C], eax

mov eax, [ebp+var_C]

add eax, 5

mov esi,esp

push eax

push offset Format

call ds:printf

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/4ecb13a06397fbe31af26065111e7d3625851f2d4940df411e2239edb4a766b9.jpg)

获取结构体st的地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7f16daa528d1c17fcf0aa51e26bd3771b13c7a1832e01c08af82b6a23bd77ed9.jpg)

访问结构体第3个成员变量

%

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/a4dd1ad7e9863ffd381a5f47bd7e92bdb0280506207d35997164c79db359086b.jpg)

，

# 结构体

#pragma pack(1)

include<stdio.h>

include<string.h>

typedef struct stu_test{

char cTest;

int iTest;

char arrTest[3];

}STest;

int main()

{

STest \*pst;

$\mathrm{STestst} = \{1\}$

st.iTest  $= 0\mathrm{x}12345678$

strcpy(st.arrTest,"ab");

pst = &st;

printf("%s", pst->arrTest);

return 0;

}

int64 main_0()

int v0; // edx

int64 v1; //ST00_8

char v3; // [esp+D0h] [ebp-1Ch]

int v4; // [esp+D1h] [ebp-1Bh]

char Dest[2]; // [esp+D5h] [ebp-17h]

char *v6; // [esp+E0h] [ebp-Ch]

v3 = 1;

v4 = 0x12345678;

j_strcpy(Dest, "ab");

v6 = &v3;

printf("%s",Dest);

HIDWORD(v1) = vθ;

LODWORD(v1) = 0;

return v1;

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/527aa029549dbf81031eeafa0740bfb3193ae94870583c016d88edc021e3a823.jpg)

# 联合体

pragma pack(1)

include<stdio.h>

typedef union uni_test{

int iTest;

char cTest[4];

short sTest[2];

}UTest;

int main()

{

UTest \*pst;

UTest st={1};

st.iTest  $= 0\mathrm{x}12345678$

st.sTest[0] = 0x2345;

st.sTest[1] = 0x4567;

pst = &st;

printf("%d", pst->iTest);

return 0;

}

.text:00413780_main_0

.text:00413780

.text:00413780 var D8

.text:00413780 var 14

.text:00413780 var 8

上…：0041770

proc near

=byte ptr -0D8h  
= dword ptr -14h  
= dword ptr -8

; CODE XREF: _main†j

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/d37705be0a6ad8126371019926d667735f62486153361e080b060d711c6e3a8e.jpg)

为联合体st预留的地址空间

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/83736f36da4063ea090ea3d6a888b1de8bd32594def8139030bad0c66610ea66.jpg)

保存联合体指针pst

.text:0041379E  
.text:004137A9  
.text:004137AC  
.text:00413781  
.text:004137B5  
.text:004137BA

为联合体成员变量

iTest赋值

mov [ebp+var_14], 1  
mov ebp+var 14, 12345678h

mov eax, 2345h

mov word ptr [ebp+var_14], ax  
mov eax, 4567h  
mov word ptr [ebp+var_14+2], ax

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/f4f460b100f0ea71174260a9704a987dee5362f49bda81797a419e474b7f57c1.jpg)

初始化联合体

lea eax, [ebp+var_14]

mov [ebp+var_8], eax

mov esi, esp

mov eax, [ebp+var_8]

mov ecx, [eax]

push ecx

push offset Format

call ds:printf

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/f1a8166eefc3efed1900b33c499a2b80f6c5f17a5bf45e427f6941b696a34513.jpg)

获取联合体st的地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6a5a0854c1deef567371390ae31ee373ed7469a243ed15efd5f8153c7653fef1.jpg)

访问联合体成员变量iTest

; "d"

# STL (Standard Template Library)

# STL 容器概述

• STL（Standard Template Library）是 C++ 标准库的一个重要组成部分，它提供了一系列经过高度优化的数据结构和算法，用于执行常见的编程任务。STL 被设计为泛型编程的典范，它允许程序员以统一的方式处理不同类型的数据集合。  
• STL 主要包含三个部分: 容器 (Containers)、迭代器 (Operators) 和算法 (Algorithms)。

# STL 容器概述

- 容器主要分为以下几类:  
- 序列容器：这些容器存储元素的线性序列，可以逐个遍历元素。主要的序列容器有：

-vector：一个可以动态增长的数组。支持随机访问，即在任意位置插入或删除元素时，可能需要移动多个元素。  
- deque（双端队列）：支持在序列的开头和结尾快速插入和删除操作。  
- list：一个双向链表，支持在任意位置快速插入和删除元素。  
- forward_list（C++11）：一个单向链表，比 list 更加节省空间，但只能向前遍历。  
- string：一个专门用于存储字符序列的容器，实际上是 vector<char> 的一个特化版本。  
- array（C++11）：一个固定大小的数组，提供随机访问，但不支持动态大小变化。

int main()

cout << "--------vector test--------" << endl;

//定义一个vector

vector<int> vect;

vector<int> vect1(12); // 12个int类型元素，每个元素的初始值均为0

vector<int> vect2(12, 9); //12个int，初试值均为9

//使用数组初始化vector

int a[] = {0,1,2,3,4,5,6,7,8,9,0};

//vector <数据类型><容器名>(<开始地址>,<结束地址的下一个地址>)。执行过vt中元素为1,2,3

vector <int> vt(a + 1, a + 4);

//在尾部压入3个值

vt.push_back(1);

vt.push_back(2)

vt.push_back(3);

v3 = sub_140001A30(std::cout, "--------vector test--------", envp);

std::ostream::operator<<(v3, sub_140001C10);

v41 = 0i64;

v42 = 0i64;

v39 = 0i64;

v4 = operator new(0x30ui64);

\*(_QWORD \*)&v39 = v4;

v40 = v4 + 3;

\*v4=0i64;

v4[1] = 0i64;

v4[2] = 0i64;

\*((_QWORD \*)&v39+1)=v4+3;

v38 = 0i64;

v5 = (_m128i *)operator new(0x30ui64);

v37[0] = v5;

v38 = v5 + 3;

si128 = __mm_load_si128((const __m128i*)&xmmword_140003490);

$^{*}\mathrm{v}5 = \mathrm{si}128;$

v5[1] = si128;

v5[2] = si128;

v37[1] = &v5[3];

Src[0] = (__int128)_mm_load_si128((const __m128i*)&xmmword_140003470);

Src[1] = (__int128)_mm_load_si128((const __m128i*)&xmmword_140003480);

v32 = 8;

v33 = 9i64;

\*(_OWORD \*)Block = 0i64;

Block[0] = operator new(0xCui64);

v7 = (char *)Block[0] + 12;

v36 = (char *)Block[0] + 12;

memmove(Block[0], (char *)Src + 4, 0xCui64);

Block[1] = v7;

v30 = 1;

if（v7==v36）

{

sub_140001C50(Block,v7,&v30);

v9 = (char *)Block[1];

}

else

{

\*(_DWORD \*)v7 = 1;

v9 = (char *)Block[1] + 4;

Block[1] = (char *) Block[1] + 4;

}

v30 = 2;

if（v9==v36）

{

sub_140001C50(Block,v9,&v30);

v10 = (char *)Block[1];

}

else

{

\*(_DWORD\*)v9 = 2;

v10 = (char *)Block[1] + 4;

Block[1] = (char *) Block[1] + 4;

}

v30=3;

if（v10==v36）

{

sub_140001C50(Block,v10,&v30);

v11 = (char *)Block[1];

}

else

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/4547efff9e5a6a5529c3b07b7cec3783dafd5c6bddea49299e6a7a0cfbd4b1a2.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/9a773eef3e78c39a92802b5addc8fb20ed51c17265a4bdffe44e669341af095b.jpg)

//定义迭代器iterator

vector<int>::iterator iter = vt.begin(); //起始地址  
vector<int>::iterator iter_end = vt.end(); //结束地址，两个地址都是指针类型  
//遍历vt

```txt
for (iter != iter_end; iter++)  
{  
    cout << *iter << endl;  
}
```

//弹出一个元素

vt.pop_back();

//以下两行重新获得起始和结尾地址

```cpp
iter  $=$  vt.begin();   
iter_end  $\equiv$  vt.end();   
cout<<"---------executed pop_back--"<<endl;   
for(;iter  $! =$  iter_end;iter++)   
{ cout <<\*iter<<endl;   
}
```

```cpp
v14 = v11 - 4;  
Block[1] = v14;  
v15 = sub_7FF70CEC1A30(std::cout, "", executed pop_back--, v8);  
std::ostream::operator<<(v15, sub_7FF70CEC1C10);  
for ( ; v12 != v14; v12 += 4 )  
{  
    v17 = std::ostream::operator<<(std::cout, *(unsigned int *)v12);  
    std::ostream::operator<<(v17, sub_7FF70CEC1C10);  
}
```

```cpp
v12 = (char *)Block[0];  
if (Block[0] != v11)  
{  
    do  
    {  
        v13 = std::ostream::operator<<(std::cout, *(unsigned int *)v12);  
        std::ostream::operator<<(v13, sub_7FF70CEC1C10);  
        v12 += 4;  
    }  
while (v12 != v11);  
v11 = (char *)Block[1];  
v12 = (char *)Block[0];
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/8fa7f29718d2f75ad4fcde22ad2e180e94796eeba5f2948441b93c11a5b63714.jpg)

# STL 容器概述

- 关联容器：这些容器存储的元素是键值对（key-value pairs），允许通过键快速检索值。主要的关联容器有：

- set：一个只包含唯一键的集合，按键排序。  
- multiset：类似于 set，但允许键重复。  
- map : 存储键值对的集合，每个键都是唯一的，按键排序。  
- multimap：类似于 map，但允许键重复。  
- unordered_set、unorderedMULTiset、unordered_map、unorderedMultimap（ $\mathsf{C} + + 11$ ）：这些容器基于哈希表实现，提供平均常数时间的元素查找、插入和删除操作，但不保证元素的顺序。

include<iostream> #include <map>

using namespace std;

```txt
int main()  
{ //定义一个存放string和int类型的map map<string，int> m;
```

# //添加元素

```matlab
m.insert(make_pair("Alice",25));  
m.insert(make_pair("Bob",30));  
m["Charlie"] = 35;
```

# //遍历map并输出元素

```javascript
cout << "elements in the map: ";  
for (auto it = m.begin(); it != m.end(); ++it) {  
    cout << it->first << "; " << it->second << ";;  
}  
cout << endl;
```

```c
\*(_OWORD \*)v61 = 0i64;  
v3 = operator new(0x48ui64);  
\*v3 = v3;  
v3[1] = v3;  
v3[2] = v3;  
\*((WORD \*)v3 + 12) = 257;  
v61[0] = v3;
```

```c
Block[0] = "Alice";  
LODWORD(Block[1]) = 25;  
sub_140002CD0(v61, &Buf2, Block);  
Block[0] = "Bob";  
LODWORD(Block[1]) = 30;  
sub_140002CD0(v61, &Buf2, Block);  
Block[1] = 0i64;  
si128 = _mm_load_si128((const __m128i*)&xmmword_1400044D0);  
Block[0] = (void *)0x65696C72616843i64;  
*(_DWORD *)(*(_DWORD *)sub_140002570(v61, &Buf2, Block) + 64i64) = 35;
```

```cpp
int main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    std::map<std::string, int> ages;
    ages.insert(std::pair<std::string, int>(“Alice”, 25));
    ages.insert(std::pair<std::string, int>(“Bob”, 30));
    ages.insert(std::pair<std::string, int>(“Charlie”, 35));
    std::cout << "elements in the map:" << std::endl;
    for (std::map<std::string, int>::iterator it = ages.begin(); it != ages.end())
        it++) {
            std::cout << it->first << ";:" << it->second << ";" << std::endl;
        }
}
```

```c
sub_1400021A0(std::cout, "elements in the map: ");  
v5 = *(int64 **)v61[0];  
while (v5 != v61[0])  
{  
    v6 = v5 + 4;  
    if ((unsigned __int64)v5[7] > 0xF)  
        v6 = (_int64 *)v5[4];  
    v7 = sub_140002B10(std::cout, v6, v5[6]);  
    v8 = sub_1400021A0(v7, "", });  
    v9 = std::ostream::operator<<(v8, *(unsigned int *)v5 + 16));  
    sub_1400021A0(v9, "", });  
    v10 = (_int64 **)v5[2];  
    if (*((BYTE *)v10 + 25))  
{  
        for (i = (_int64 *)v5[1]; !*(BYTE *)i + 25); i = (_int64 *)i[1])  
        {  
            if (v5 != (_int64 *)i[2])  
                break;  
            v5 = i;  
        }  
    v5 = i;  
}  
else  
{  
    v5 = (_int64 *)v5[2];  
    for (j = *v10; !*(BYTE *)j + 25); j = (_int64 *)j)  
        v5 = j;  
}  
}  
std::ostream::operator<<(std::cout, sub_140002380);
```

//查找元素  
```txt
auto it = m.find("Bob");  
if (it != m.end()) {  
    cout << "Bob's age is " << it->second << endl;  
}  
else {  
    cout << "Bob is not found in the map" << endl;  
}
```

//修改元素  
```txt
m["Alice"] = 26;  
m.at("Charlie") = 36;
```

//遍历map并输出元素  
```txt
cout << "elements in the map after modification: ";  
for (auto it = m.begin(); it != m.end(); ++it) {  
    cout << it->first << "; " << it->second << ";  
}  
cout << endl;
```

//删除元素  
```javascript
m. erase("Bob");
```

//遍历map并输出元素  
```txt
cout << "elements in the map after deletion: ";  
for (auto it = m.begin(); it != m.end(); ++it) {  
    cout << it->first << "; << it->second << ";
```

goto LABEL_37;  
v22 = *(_QWORD *)v16 + 6);  
```txt
LOWORDBuf2）  $=$  \*(_WORD\*)"Bob";   
WORD1Buf2）  $=$  (unsigned_int8)aBob[2]; v14  $=$  (char \*)v61[0]; v15  $=$  (char \*)\*((_QWORD \*)v61[0] + 1); v16  $=$  (char \*)v61[0]; while（!v15[25]） { v17  $=$  v15+32; if \*((_QWORD\*)v15+7)>0xFui64） v17  $=$  (const void \*)\*((_QWORD\*)v15+4); v18  $=$  \*((_QWORD\*)v15+6); v19  $=$  v18; if（v18>3） v19  $=$  3i64; v20  $=$  memcmp(v17,&Buf2,v19); if（v20） { if（v20<0） goto LABEL_35; } else if（v18<3） { LABEL_35: v15  $=$  (char \*)\*((_QWORD\*)v1 continue; } v16  $=$  v15; v15  $=$  \*(char \*\*)v15; }
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/ae37215007ecdc8f9446986478be962b8f9e94d59ce648ce76de58e1607a3276.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/1a80e59166b8a035cc189075b69dfd72d3c1112b67b552f81f44ab1e2d4872d2.jpg)

```txt
if（v16[25]）
```

```c
v21 = v16 + 32;  
if (*((_QWORD *)v16 + 7) > 0xFui64)  
v21 = (const void *)*((_QWORD *)v16 + 4);
```

```txt
if（v22<3） v13  $= ^{*}((\_ \text{QWORD}^{*})\vee 16 + 6)$  v23  $=$  memcmp(&Buf2,v21,v13); if（!v23）
```

LABEL_37: v16 = v14;  
```txt
if（v22<=3） gotoLABEL_38; gotoLABEL_37; } if（v23<0）
```

```txt
LABEL_38: if (v16 == v14) { v25 = sub_1400021A0(std::cout, "Bob is not found in the map"); } else { v24 = sub_1400021A0(std::cout, "Bob's age is "); v25 = std::ostream::operator<<(v24, *(unsigned int *v16 + 16)); } std::ostream::operator<<(v25, sub_140002380);
```

//查找元素  
```javascript
auto it = m.find("Bob"); LODWORD(Block[0] = *(DWORD *)"Alice"; WORD2(Block[0] = (unsigned __int8)aAlice[4]; cout << "Bob's age is " << *(_DWORD *)*((_DWORD *)sub_140002570(v61, &Buf2, Block) + 64i64) = 26; } if (si128.m128i_i64[1] > 0xFui64) else { cout << "Bob is not found v26 = Block[0]; if (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000) {
```

//修改元素  
```txt
m["Alice"] = 26;  
m.at("Charlie") = 36;
```

//遍历map并输出元素  
```javascript
cout  $\ll$  "elements in the map a.   
for (auto it  $=$  m.begin();it  $! =$  m.end();  $+ + i t$  1 cout << it->first << :<< it->second << "";   
}   
cout << endl;
```

//删除元素  
```javascript
m. erase("Bob");
```

//遍历map并输出元素  
```txt
cout << "elements in the map after deletion: ";  
for (auto it = m.begin(); it != m.end(); ++it) {  
    cout << it->first << "; << it->second << ";
```

```cpp
\*((_DWORD \*)v28 + 16) = 36;   
sub_1400021A0(std::cout, "elements in the map after modification:");   
v37 \(=\) \*(_int64 \*\*v61[0];   
while ( v37 != v61[0 ])   
{ v38 \(=\) v37 + 4; if ( (unsigned _int64)v37[7] > 0xF ) v38 \(=\) (_int64 \*)v37[4]; v39 \(=\) sub_140002B10(std::cout,v38,v37[6]); v40 \(=\) sub_1400021A0(v39，":"); v41 \(=\) std::ostream::operator<<(v40,\*((unsigned int \*)v37 + 16)); sub_1400021A0(v41，""); v42 \(=\) (_int64 \*\*v37[2]; if (\*((_BYTE \*)v42 + 25)) { for ( k \(=\) (_int64 \*)v37[1];！\*((_BYTE \*)k + 25); k \(=\) (_int64 \*)k[1] } if ( v37 != (_int64 \*)k[2]) break; v37 \(=\) k; } v37 \(=\) k; } else { v37 \(=\) (_int64 \*)v37[2]; for ( m \(=\) \*v42;！\*((_BYTE \*)m + 25); m \(=\) (_int64 \)*m) v37 \(=\) m; } }   
std::ostream::operator<<(std::cout, sub_140002380):
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/0f3a1963fd4af4fc7a8da46cccb0ad385552dbb63f91e88decce703afe24f3b1.jpg)

# STL 容器概述

- 容器适配器：这些容器不是直接存储元素的容器，而是对容器或其他容器适配器进行封装以提供特定的功能。主要的容器适配器有：

- stack：后进先出（LIFO）的容器适配器。  
- queue: 先进先出（FIFO）的容器适配器。  
- priority_queue : 提供最大（或最小）元素优先的队列。

# 函数

# 函数

- 函数是程序的重要构成，从反汇编的角度理解函数结构是对程序进行逆向分析的基础。  
- 在程序运行过程中，为了保存在函数中使用的临时数据，使用了栈结构来保存这些临时数据。对于一个在内存中运行的程序（被称为进程）而言，栈为该程序中所有的函数所共享，因此在对函数进行调用前后，必须保持栈平衡。  
- 汇编指令中，对栈的维护是通过两个非常重要的寄存器，即 esp 和ebp 来完成的，它们分别指向了栈的顶部和栈的底部。由于栈的增长是从高地址到低地址增长的，所以栈顶的地址小于栈底的地址，也就是说  $\mathrm{esp} < = \mathrm{ebp}$  。

# 函数

include<stdio.h>

int add(int x, int y);

int main()

1

int  $\mathbf{x} = 0\mathbf{x}1234$

int y = 0x5678;

int rtn = add(x, y);

printf("%d",rtn);

return 0;

}

int add(int x, int y) {

int z;

$\mathbf{z} = \mathbf{x} + \mathbf{y}$

return z;

3

.text:0041379E

.text:004137A5

.text:004137AC

.text:004137AF

.text:004137B0

.text:00413783

.text:00413784

.text:0041378

.text:004137BC

.text:004137BF

.text:004137C1

.text:004137C4

.text:004137C5

.text:004137CA

.text:00411460 sub_411460

.text:00411460

.text:00411460 var CC

.text:00411460 var_8

.text:00411460 arg_0

.text:00411460 arg 4

.text:00411460

.text:00411460

.text:00411461

.text:004163

.text:0041169

.text:0041146A

.text:0041146B

.text:0041146C

.text:00411472

.text:00411477

.text:0041147C

.text:0041147E

.text:00411481

.text:00411484

.text:00411487

.text:0041148A

.text:00411488

.text:0041148C

.text:0041148D

.text:0041148F

.text:00411490

.text:00411490 sub_411460

# 维护栈平衡

mov [ebp+var_8], 1234h

mov [ebp+var_14], 5678h

mov eax, [ebp+var_14]

push eax

mov ecx, [ebp+var_8]

push ecx

call sub 4111DB

add esp, 8

mov [ebp+var_20], eax;

mov esi,esp

mov eax, [ebp+var_20]

push eax

push offset Format

call ds:printf

proc near

;CODEXREF:sub_4111DB↑j

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/08961d50f974002cf9ff49a85a9e15b3ccd9aed5bd51ed9ec89d3e254dc08fa2.jpg)

保存局部变量Z的地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/cac23994e370202e04e291302c5b3f0411c229496c13308ba1e1f1f19683c3aa.jpg)

一个函数开始部分的典型指令

push ebp

mov ebp, esp

sub esp, OCCH

push ebx

push esi

push edi

lea edi, [ebp+var_CC]

mov ecx, 33h

mov eax, 0CCCCCCH

rep stosd

mov eax, [ebp+arg_0]

add eax, [ebp+arg_4]

mov [ebp+var_8], eax

mov eax, [ebp+var_8]

pop edi

pop esi

pop ebx

mov esp,ebp

pop ebp

retn

endp

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/1f1d00bc383780e9e0ce35cdb3391d7feea1b157535b5cb9896b8266a38ab8c8.jpg)

函数处理的主体。通过栈访问函数参数，处理结果保存在eax中

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/eed89ebe2c0884febd762b19552e87cbd266570ed4dca7e7e2cdb10241aa17e4.jpg)

一个函数结束部分的典型指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/51ff22ee8237f4b75c002dda7f7970084ff199c44fdf2fa6b20afa0d07b91bc8.jpg)

对变量  $x$  和  $y$  赋值，并通过

push指令压入栈中

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/d2d7b19cb7768cd3e7db46d30d901386eed179917d6e42b9a0c1e55efc16a5e6.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/87ee69e6500ccf0db2eec3dc2b0ee080c16b82096cd83fa51aadfaa70f399c2b.jpg)

通过eax获取函数的返回值

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6f7ef69cadbe32106ed027e1613448cf14b027e3247060a8d79596885be58832.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7dba9e0b56f1a8281c13e1283018a6ec54920ddc991af2c5db56f89ad6461850.jpg)

# 函数

include<stdio.h> int add(int x, int y); int main() { int  $\mathrm{x} = 0\mathrm{x}1234$  int  $\mathrm{y} = 0\mathrm{x}5678$  int rtn  $=$  add(x,y); printf("%d",rtn); return 0; } int add(int x, int y){ int z;  $\mathrm{z} = \mathrm{x} + \mathrm{y}$  return z; }

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/0b8f1fa4f83c489100555a3e0c313440d1bba76de17b427827343b749c8e1c3e.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/47fedb3e135da20b8f73eb6f581afc79fe13d590a329b8dd863f325f872397ea.jpg)

EDX00000001  
ESI00691109 start  
EDI00AFFB04 Stack[0000B1C]  
EBP00AFFB04 Stack[0000B1C]  
ESP00AFFAOC Stack[0000B1C]  
EIP006937B4 main_0+34  
EFL00000202

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/77ced73af89eea47e3f0ae21c2c2ad23d611d287aff7236eb592508f47d834bf.jpg)

# 函数

include<stdio.h>

int add(int x, int y);

int main()

{

int  $\mathbf{x} = 0\mathbf{x}1234$

int y = 0x5678;

int rtn = add(x, y);

printf("%d",rtn);

return 0;

}

int add(int x, int y) {

int z;

$\mathbf{z} = \mathbf{x} + \mathbf{y}$

return z;

}

# EIP

.text:00691460 var_CC= byte ptr -0CCh

.text:00691460 var_8= dword ptr -8

.text:00691460 arg_0= dword ptr 8

.text:00691460 arg_4= dword ptr 0Ch

.text:00691460

.text:00691460 push

.text:00691461 mov

.text:00691463 sub

.text:00691469 push

. text:0069146A push

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c2ff3e3463e4d8b543f5c0a1743caa16919a5bc658ca0f71fb5e0dd9cecb20fd.jpg)

执行完函数首部的

几条指令后

ebp

ebp,esp

esp,0CCh

ebx

esi

# EIP

.text:0069148C pop

.text:0069148D mov

.text:0069148F pop

.text:00691490 retn

.text:00691490 sub_691460 endp

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/742f8c1abcffe4f28e7b3266cb2cfbcbdc6970d207662257928be49daf86bd66.jpg)

离开函数前

# EIP

.text:006937AF push

.text:006937B0 mov

.text:006937B3 push

.text:006937B4 call

.text:00693789 add

.text:006937BC mov

LEXL:00093/AL INOV

eax

ecx, [ebp+var_8]

ecx

sub_6911DB

esp, 8

[ebp+var 20], eax

.text:006937AF push

.text:006937B0 mov

.text:006937B3 push

.text:006937B4 call

.text:006937B9 add

.text:006937BC mov

.text:006937BF mov

eax

ecx,

ecx

sub_6911DB

esp, 8

[ebp+var_20], eax

esi. eso

E

ECX00001234

EDX0000001

ESI00691109

EDI00AFFB04

EBP00AFFA04

ESP00AFF938

EIP 00691469

EFL00000212

1

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/4becf9168dc313bda1f2914a37502858b76de9f5be1c3e5e1a12968e3bb14b93.jpg)

#

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/066abd95e795b92e2f7abfd9c1466882846c6f2bacdbaddd3ea2381cc836ff9b.jpg)

$\therefore m = \frac{3}{11}$

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6ef52ff215fc47ae8694d201e06091ef6d0413e597f6038ba13e9483a6d379f2.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/2e5cd174e0928b0e82d7975e8fcf3ee1890ef6dd1ccc726a1494f5773e53b1d3.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/10651895d8ff2191f1699fc881ef92cc658a75ad05b7e484e10453e4dab4889d.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/499c086e7a0677c90502c172e6228ad7d7b78c4776b05c7e49cf1ef25cd242d8.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/98c5331aa81b4f81d7c97ab1d0b6448c3e432b031d01316c10ec17d2ee6aa06d.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c4c12e6356943ff2100eeeba0968680186145de5873eb1989b2a2d37e98a196f.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6c30b2161a3f70be278605e69a34beeaa4838907849ec4ddef693d415bdcdf82.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/21446a6970cd16563e68b74c5b984c85fd1b721025a893782e9363235b3bddbe.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/16226bac528f637a842a3ca72ac7a608487d02c3acac22fb0c5385bac69e5f6f.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/1eeb15a1bffbc8d46f8b9a471977b94974daee2c6152e75f9b027eb302a52148.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/5ccef87e76071f570316bb7fa7add8965afad752f26092a9484d72fe758ba775.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/63f189bf2fcf2e3e73b1e9c879e9b2ccbb50d5d51235c33da3f2964ee30331b4.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/86da0a4219dd0be64039c53d0dea1a6afb02f23e79c0b55e15110fb7712867ba.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/4b36d530e1aa996d4e346255decd4156209fae5e2b92495c57585fa1b2aba474.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7d44bda66ca4c18f0848b58412655a1f1fa168c4a176dcc3a0c7b55e2a947581.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/66d30895173d2c3adeda947ebc263d2bc2742084cdfad539a85ca138a7518a85.jpg)

EDI 00AFFB04

EBP00AFFB04

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/56938a38bb438f455e86476730658e60d111215d7949eda603274ee0978c413a.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/901147d1724c8801e85519458e590e5ca40ff7ca20363d129f07b2483fcb87e2.jpg)

ESP 00AFFA08

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6b1334b2fa1a5a53e88c58d41a4e69a5769ba34d1b33367b0655eda0df163507.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6023d932bcebcbef83ab824dad77de37be2e1cc95aae111a57c224bad1d892a7.jpg)

EIP 00691490

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/2a7162b7f424b93a14f6c0a5b14f11a0e4ca891ddbd135bff467387bac0b4986.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/8461634ce4c8a3e920a9c8f520ae264e6e532739e277f8ee4654d45ca91ae101.jpg)

ESI 00691109

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/049e203ba0bb3c0d5bcb779b52561a5b92f342a79a99fd8846d3629ca94633ec.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/b6f7e4bddedae7ab01f7692567afb0a9aa9eccbf714a584a5d64bdd686a5a951.jpg)

EDI 00AFFB04

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/26f26ec294991f5c1c126ea13c06ee0e89805ca29ed6f3c022e00ce188be822d.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c45fe34b594ebf97a1c460328dd74f8d84eb899a4a55060c4932a7418b122786.jpg)

EBP 00AFFB04

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/24897c3a7ea74eb8aa6ff12084601cd92dedab100e9ad193c287c9260c3df3fc.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/b46683ded09b1a827728a60ba12dc19e01b3b4dbac6ae1474fdb27acf6d5d125.jpg)

ESP 00AFFA0C

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6364cad7a9464ae941266cd7419fb6084b04759415a8a67f6c3a969620d3c9dd.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/621695f84dc95fc7a15958466e31171a23aaacc7982fa4509ddf6f1a8766c368.jpg)

EIP 00693789

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/1f71b9fc4b7e54b198760f70bfe84a258e7d2dcf35c0d8a474eedd6ed44e30b9.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/04f988aa320baa7438a3a4ff456ee8f703bdc3f9c9ea860af41059d8f1c27140.jpg)

LDA 000001

ESI00691109

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/f54b535c12b2c00ec73d549d1ed41186d0461f55674400ff60c978d093947cc7.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/3b008d31d5424048b99de2c364dd0c750af7f9049a52f263bf3f81659bd1d192.jpg)

EDI00AFFB04

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/26fe4e31f9a09f0871e87b84451f70222ace0d4a734b54088fa8038fd16404bc.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/ee62587230cac3cde982af45cdc46c0b7b5b00f57d1adba98e533bc12e82e9d0.jpg)

EBP00AFFB04

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/5f6c4fe769208fa833d39af8494f5ecd33ac3e705363655d7c36d486d5ed72d5.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/6aa8254b27cd4a299895d97de91a41156372a881913a00c1edd950e568ca9783.jpg)

ESP00AFFA14

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/bb442a8c63d0b3a6cae8e30507c3fcaa91a215be81eb564e5eb538f0689bfd4e.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c65a0a6c5398c09491fb574bcd81a0c9ddbc6c6eeb311da61b552adc34bc5afb.jpg)

EIP006937BC

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/3f02dd5af0ad903e11946f71cd03d06d07c66857220d658bab40f4455d266fce.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/5930a3b0ba6874d88b258d0619fe8deb9ffba7c6e58530aa85e5866681cd9531.jpg)

EFL00000216

# ,

# 基本程序逻辑

- 在对二进制代码进行逆向分析时，通常可以将程序指令分为顺序流指令和控制流指令。  
• 顺序流指令是指一条指令完成后，将执行权传递给下一条指令的一类指令。简单算术指令，如 add；寄存器与内存之间的传输指令，如 mov；栈操作指令，如 push 和 pop 等都属于顺序流指令。  
- 控制流指令包括了无条件分支指令、条件分支指令、函数调用指令和函数返回指令。

- 为了对抗反汇编和反编译工具的自动分析，程序设计者通常会针对控制流指令进行处理，例如在控制流指令中插入一些无效字节，这就要求逆向分析人员在理解控制流程序逻辑基础上，剔除掉这些无效字节，恢复程序源码，然后再借助工具进行分析。  
- 在理解二进制指令的程序逻辑时，最好的方式应该是从开发者的角度去进行理解。

# 无条件分支指令

- 汇编程序语言指令jmp是无条件跳转指令。CPU执行这条指令后会跳转到jmp指令参数所指向的地址。这个操作对CPU来说，和顺序流指令没什么区别，只是将EIP[32位指令指针寄存器，CPU根据该寄存器的值执行对应的指令。]改成要跳转的地址。  
编写汇编程序时，jmp指令后面跟随的操作数一般是标签（对应的是要跳转到的指令的偏移地址）、寄存器或者内存地址。C语言中对应的语句是goto，虽然为了提高程序的可读性，一般不建议采用goto语句，但某些情况下还是可以使用的，例如大型程序中处理复杂逻辑时，一般也会考虑使用goto。

# 无条件分支指令

- 汇编程序语言指令jmp是无条件跳转指令。CPU执行这条指令后会跳转到jmp指令参数所指向的地址。这个操作对CPU来说，和顺序流指令没什么区别，只是将EIP[32位指令指针寄存器，CPU根据该寄存器的值执行对应的指令。]改成要跳转的地址。  
编写汇编程序时，jmp指令后面跟随的操作数一般是标签（对应的是要跳转到的指令的偏移地址）、寄存器或者内存地址。C语言中对应的语句是goto，虽然为了提高程序的可读性，一般不建议采用goto语句，但某些情况下还是可以使用的，例如大型程序中处理复杂逻辑时，一般也会考虑使用goto。

# 无条件分支指令

int main(){

int  $a = 10$

LOOP:do

if  $\mathrm{a} = 15$

1

$\mathbf{a} = \mathbf{a} + 1$

goto LOOP;

}

printf("a: %d\n", a);

a++;

}while(a<20);

return 0;

}

.text:004113AE  
.text:00411385  
.text:00411385  
.text:00411385  
.text:00411385  
.text:00411389  
.text:004113BB  
.text:004113BE  
.text:004113C1  
.text:004113C4  
.text:004113C6  
.text:004113C6  
.text:004113C6 loc_4113C6:  
.text:004113C6  
.text:004113C8  
.text:004113CB  
.text:004113CC  
.text:004113D1

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7ebc0a7b6c646854ac736bd91637e3863b13126699086cf03502b4945d637232.jpg)

mov [ebp+var_8], 0Ah

标签LOOP对应的偏移地址

cmp [ebp+var_8], 0Fh  
jnz short loc_4113C6

mov eax, [ebp+var_8]  
add eax, 1  
mov [ebp+var_8], eax  
jmp short loc_411385

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/b86b2cc1b4b526e51861202d64e5b05a0b993a21828313a0e665261c84badc23.jpg)

if语句对应的cmp和jnz指令

; CODE XREF: _main_0+29↑j

mov esi,esp  
mov eax, [ebp+var_8]  
push eax  
push offset Format ; "a 的值"  
call ds:printf

```txt
1 int main_0()
2 {
3     int v1; // [esp+D0h] [ebp-8h]
4
5         v1 = 10;
6         do
7     {
8         while (v1 == 15)
9             v1 = 16;
10             printf Format, v1++);
11         }
12         while (v1 < 20);
13         return 0;
14}
```

// Format

db 'a 的值

# 条件分支指令

• C/C++ 程序中, if、if...else if...else 以及 switch...case 语句对应的反汇编程序中都会出现条件分支指令。

# 条件分支指令

• C/C++ 程序中, if、if...else if...else 以及 switch...case 语句对应的反汇编程序中都会出现条件分支指令。

```c
int main()  
{  
    int a = 100;  
    if (a == 10)  
    {  
        printf("a 的值是 10\n");  
    }  
    else if (a == 20)  
    {  
        printf("a 的值是 20\n");  
    }  
    else  
    {  
        printf("没有匹配的值\n");  
    }  
    printf("a 的准确值是%d\n", a);  
    return 0;  
}
```

# 条件分支指令

```c
int main()  
{  
    int a = 100;  
    if (a == 10)  
    {  
        printf("a 的值是 10\n");  
    }  
    else if (a == 20)  
    {  
        printf("a 的值是 20\n");  
    }  
    else  
    {  
        printf("没有匹配的值\n");  
    }  
    printf("a 的准确值是%d\n", a);  
    return 0;  
}
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/65d4eec8546be3b46cb47a3d32e090fe013f5254325e88d2040eed32b42e96b1.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/c9d8e3c1fab5397bf32fc085a939a4ff1ed55c86d3eca23cdc1fc5f694e20f12.jpg)

# 条件分支指令

- switch 语句根据控制表达式的值，可以把程序流跳转到多个语句中的一个执行。  
- 编译器在处理 switch 语句时，会对其进行优化。switch 分支数较少时会直接使用 if...else 来实现，当 switch 分支数较多时，常见的优化方案是将所有跳转的 case 位置偏移放在一个一维数组的表当中，然后将 case 的值当成数组下标进行跳转。

# 条件分支指令

```txt
include<stdio.h>   
int menu(void){return'A';};   
void action1(void){printf("A");}   
void action2(void){printf("B");}   
int main(){ switch（menu()）{ case'A':action1(); break; case'B':action2(); break; default:putchar('a'); }   
}
```

```asm
.text:004114EE call sub 4110EB 1 call menu()
.text:004114F3 mov [ebp+var_C4], eax
.text:004114F9 cmp [ebp+var_C4], 'A' 2 case 'A'
.text:00411500 jz short loc_41150D
.text:00411502 cmp [ebp+var_C4], 'B' 3 case 'B'
.text:00411509 jz short loc_411514
.text:0041150B jmp short loc_41151B 4 default
.text:0041150D
.text:0041150D loc_41150D:
.text:0041150D call sub 4110E6 5 call action1
.text:00411512 jmp short loc_41152F
.text:00411514 7 break
.text:00411514 loc_411514:
.text:00411514 call sub_4110E1 6 call action2)
.text:00411519 jmp short loc_41152F
.text:0041151B 8 break
.text:0041151B loc_41151B:
.text:0041151B mov esi, esp
.text:0041151D push 7 ; Ch
.text:0041151F call ds:putchar
.text:00411525 add esp, 4
.text:00411528 cmp esi, esp
.text:0041152A call jRTC CheckoutEsp
.text:0041152F
.text:0041152F loc_41152F:
.text:0041152F xor eax, eax
.text:0041152F
```

# 条件分支指令

int menu(void){return'A';};

void action1(void){printf("A");}

void action2(void){printf("B");}

int main(){

switch (menu())

{

case 'a':

case'A':action1();

break:

case 'b':

case'B':action2();

break:

default: putchar('a');

}

}

.text:0041155D  
.text:00411560 off_411560  
.text:00411560  
.text:00411560  
.text:0041156C byte_41156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041156C  
.text:0041158E

align 10h

dd offset loc_411525

dd offset loc 41152C

dd offset loc 411533

db 0, 1,

db 2, 2,

db 2, 2,

db 2, 2,

db 2, 2,

db 2, 2,

db 2, 2,

db 2, 2,

db 0, 1

align 40h

; DATA XREF: main 0+4E↑r

; jump table for switch statement

2

; DATA XREF: _main_0+47↑r

2

2

2

#

2

2

2

乙

2 ; indirect table for switch statement

loc_411547:

call sub 4110EB

mov [ebp+var_C4], eax

mov eax, [ebp+var_C4]

sub eax, 41h

mov [ebp+var_C4], eax

cmp [ebp+var_C4], 21h; switch 34 cases

ja short loc_411533; jumptable 0041151E default case

mov ecx, [ebp+var_C4]

movzx edx,ds:byte_41156C[ecx]

jmp ds:off_411560[edx\*4]; switch jump

3

case 'a', 'A'

call sub_4110E6

jmp short loc_411547

7

CODE XREF: _main_0+4E+j

DATA

: jumptable 0041151E cases 0,32

6

break

loc_411525:

loc 41152C:

#

#

loc_411533:

$\frac{1 + \left( {1 + u}\right) }{7} = {140}\because$

4

case 'b', 'B'

call sub 4110E1

jmp short loc_411547

8

CODE XREF: main 0+4E↑j

; DATA XREF: .text:off 411560

; jumptable 0041151E cases 1,33

5

default

mov esi, esp

push 7

call ds:putchar

add esp, 4

cmp esi,esp

call j_RTC 查 CheckEsp

; CODE XREF: _main_0+3F↑j  
;main_0+4E↑j  
; DATA XREF: ...  
; jumptable 0041151E default case  
; Ch

;CODE XREF:main_0+5A↑j

# 循环指令

- 循环是  $C / C + +$  程序中常见的语句  
• 一般有三种循环体: while 循环、do…while 循环以及 for 循环语句  
- 这些循环体对应的反汇编程序中都会出现条件分支指令。

```c
1 #include<stdio.h>   
2 int main()   
3 {   
4 int count  $= 0$  .   
5   
6 count  $= 0$  .   
7 while (count  $<  10$  ）   
8 {   
9 printf("while...\\n");   
10 count++;   
11 }   
12   
13 count  $= 0$  .   
14 do   
15 {   
16 printf("do while..\\n");   
17 count++;   
18 } while count  $<  10$  .   
19   
20 for (count  $= 0$  ; count  $<  10$  ; count++)   
21 {   
22 printf("for...\\n");   
23 }   
24   
25 return 0;   
26 }
```

# 循环指令 -while

• while 循环的流程是：①先进行表达式判断，②当表达式结果为 false，跳出循环体，③结果为 true，执行语句块，④继续

# 杠杆

.text:0041387E  
.text:00413885  
.text:0041388C  
.text:0041388C  
.text:0041388C  
.text:00413890  
.text:00413892  
.text:00413894  
.text:00413899  
.text:0041389F  
.text:004138A2  
.text:004138A4  
.text:004138A9  
.text:004138AC  
.text:004138AF  
.text:004138B2

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/a4f093ef6ecfc93d82ca6f733933da76ce4dabe13fda02acc51fdb5581142aba.jpg)

mov [ebp+var_8], 0  
mov [ebp+var_8], 0

cmp [ebp+var 8], 0Ah

jge short loc_4138B4

mov esi, esp

push offset Format

call ds:printf

add esp, 4

cmp esi,esp

call j_RTC 查 CheckEsp

mov eax, [ebp+var_8]

add eax, 1

mov [ebp+var_8], eax

jmp short loc_41388C

CODE XREF: main_0+52↓j  
1 进行表达式判断  
2 不满足条件，跳出循环  
"while... \n"

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/2376eff1a8751948e04cc2df0e1298c36733d81827a65da6e4d4958b1650bdac.jpg)

满足条件，执行循环体

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/ce81da270bc243e7b7a3ac22b14ca384c029bc74855358ee6d06cb4e61aaddcb.jpg)

继续循环

include<stdio.h>

int main()

{

int count = 0;

count  $= 0$

while (count  $< 10$

{

printf("while...\\n");

count++;

}

count  $= 0$

do

1

printf("do while...\\n");

count++;

} while (count < 10);

for (count = 0; count < 10; count++)

1

printf("for...\\n");

}

return 0;

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/56a7ea07003c62211728c89520ead73de1a1e51c4b930291a938b21a7b916ca4.jpg)

# 循环指令 -for

- for 循环流程:  
(1) 计算表达式 1 ;  
• (2) 求解表达式 2 , 如果值为 true, 则执行 for 语句当中的内嵌语句, 然后执行第 3 步; 如果表达式 2 值为假, 则结束循环, 转到第 5 步;  
(3) 计算表达式 3 ;  
(4) 转回上面第 2 步执行;  
(5) 结束循环。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/7137691f7e272418ebca9a88f6d0760d76b64c17a931177bd3fe8ece6ecfba7c.jpg)

# 循环指令

```c
int main_0()
{
    int i; // [esp+D0h] [ebp-8h]
    for (i = 0; i < 10; ++i)
        printf("while... \n");
    i = 0;
    do
        printf("do while... \n");
        ++i;
    }
    while (i < 10);
    for (i = 0; i < 10; ++i)
        printf("for... \n");
    return 0;
}
```

```c
1 #include<stdio.h>   
2 int main()   
3 {   
4 int count  $= 0$    
5   
6 count  $= 0$    
7 while (count  $<  10$  ）   
8 {   
9 printf("while...\\n");   
10 count++;   
11 }   
12   
13 count  $= 0$    
14 do   
15 {   
16 printf("do while...\\n");   
17 count++;   
18 } while count  $<  10$  .   
19   
20 for count  $= 0$  count  $<  10$  count++)   
21 {   
22 printf("for...\\n");   
23 }   
24   
25 return 0;   
26 }
```

# 算术运算

- 在逆向分析时，某些算术运算指令序列是很容易解读的，但是在其他一些情况下，算术运算指令序列经过了编译器优化处理后，理解起来有一定的难度。

# 算术标志位

- 为了详细理解汇编语言中是如何实现算术和逻辑运算的，必须全面地理解各个标志位以及它们的使用方法。  
- 指令集中几乎所有的算术指令都要用到标志位，因此，要真正理解汇编语言中算术指令序列的含义，必须理解每一个标志位的含义以及算术指令是怎样使用它们的。  
- IA-32 处理器中的标志位都被集中存放在 EFLAGS 存储器中, 它是一个由处理器管理的 32 位寄存器, 程序代码很少会直接访问它。EFLAGS 存储器中的大多数标志位是系统标志位, 系统标志位的状态确定了处理器的当前状态。  
- 除了这些系统标志位外，还有 8 个状态标志位，这 8 个标志位代表了处理器的当前状态，状态标志位的取值与最近一次执行的算术运算的结果有关。

# 算术标志位 -CF 和 OF

- 进位标志位 CF 和溢出标志位 OF 对于汇编语言中的算术指令和逻辑指令是非常重要的两个标志位。它们的功能以及它们之间的区别并不十分明显。  
• CF 和 OF 都是溢出指示符，这就是说它们两都可以用于通知程序算术运算的结果太大了以至于无法把它全部表示在目标操作数中。  
- 这两个标志位的区别与程序所处理的数据类型有关。

# 算术标志位 -CF 和 OF

- 与大多数高级语言不同, 汇编语言程序不会显式地指明当前所处理数据的类型细节。  
- 一些算术指令如 ADD 指令和 SUB 指令也不去管它们处理的操作数到底是有符号数还是无符号数，因为这对它们来说不重要——运算的二进制结果是一样的。  
- 而其他一些指令，如 MUL 指令和 DIV 指令就有无符号数版本和有符号数版本两种——因为不同的数据类型对于乘法和除法来说会产生不同的二进制输出。

# 算术标志位 -CF 和 OF

- 有符号数表示和无符号数表示总是与一个问题有关, 这个问题就是溢出。  
- 因为有符号整数要比同样长度的无符号整数少一位（因为这个特殊的位被用来存放符号），所以有符号数和无符号数的溢出触发条件是不一样的。这就是我们需要 CF 和 OF 两个溢出标志位的原因。  
- 处理器并没有为算术指令提供独立的有符号和无符号两个版本，而是简单地通过用两个溢出标志位报告溢出就把问题合理地解决了：这两个标志位一个用于有符号操作数，一个用于无符号操作数。

# 算术标志位 -CF 和 OF

- 加法或者减法运算可以用同一个版本的指令对有符号操作数和无符号操作数进行运算，并对两个标志位进行置位——置位后的标志位留待接下来的指令处理。  
• 举个例子，考虑下面的算术运算代码，看看它会对这两个溢出标志位产生什么样的影响：

• mov ax, 0x1126  
• mov bx, 0x7200  
• add ax, bx

• 上面的加法指令可能会产生不同的结果, 具体的结果取决于是把目的操作数当作有符号数还是无符号数对待。

# 算术标志位 -CF 和 OF

• mov ax, 0x1126  
• mov bx, 0x7200  
• add ax, bx

• 如果用十六进制数表示的话, 结果是  $0 \times 8326 \dots$  假定 AX 被当作一个无符号操作数。  
- 如果把 AX 当作一个有符号操作数，就会看到发生了溢出，因为任何最高位为 1 的有符号数是负数，0x8326 就成了 -31962 了。显然，因为一个 16 位的有符号数能表示的最大的数是 32767。  
- 因此，上面的代码对无符号数来说没有溢出，但看作是有符号数就溢出了。所以，前面这段代码会导致 OF（表示在有符号操作数中溢出）置 1，而 CF（表示在无符号操作数中溢出）被清零。

# 算术标志位 -ZF

- 当算术运算的结果为 0 时, 零标志位 ZF 将被置 1 ; 如果结果不为 0 , ZF 则被清零。  
- IA-32 汇编语言代码中，在好多种情况下会使用ZF标志位，但可能最常见情况就是比较两个操作数并测试它们是否相等。  
- 比如用 CMP 指令将一个操作数减去另一个操作数，如果减法运算的伪结果（表示此结果并不写入目的操作数中）为 0 就将 ZF 标志位置 1，表明两个操作数相等。如果两个操作数不相等，ZF 被清零。

# 算术标志位-SF

- 符号标志位记录结果的最高位（不管结果是有符号数还是无符号数）。  
- 对于有符号整数，SF相当于整数的符号。  
- 符号标志位 SF 为 1 表明结果是负数, 为 0 表示结果是正数 (或者是 0 )

# 算术标志位-PF

- 奇偶标志位（极少使用）记录算术运算结果低 8 位的二进制奇偶校验。  
• 二进制奇偶校验就是指数中置为 1 的位数是奇数还是偶数，它与数的奇偶性完全是两回事儿。  
• PF为1表明运算结果的低8位中1的个数是偶数，而PF为零则表明结果的低8位中1的个数是奇数。

# 整数算术运算

• 需要指出的是，对于任意一款正常的编译器来说，任何涉及两个常量操作数的算术运算都会在编译阶段被全部清除并代之以它们的运算结果（在汇编语言代码中只能看到这个运算结果）。  
- 因此，我们讨论的算术运算只应用于运算中至少包括一个事先不知道取值的变量的情形。

# 整数算术运算-加法和减法

- 整数的加法和减法通常是用 ADD 和 SUB 指令来实现的，这两条指令可以接收几种不同类型的操作数：寄存器名，立即（硬编码）数或者内存地址。  
- 这些类型的操作数具体怎么组合取决于编译器, 而且通常并不能反映出任何有关源代码的具体信息, 但有一种情况很明显——如果是加上、减去一个立即操作数的话, 那么它通常反映到源代码中的一个硬编码的常数 (当然, 在某些情况下编译器会为了其他目的将常数放到寄存器中再进行加减运算, 而不是按照源代码所指示的方式处理)。  
• 要指出的是，两条指令都是将运算结果存放在左操作数中。

# 整数算术运算-加法和减法

• 加、减法运算都是非常简单的运算，在现代 IA-32 处理器中执行效率非常高，并且通常编译器是用直接的方式实现的。  
- 在早期的 IA-32 处理器中，LEA 指令的执行效率比 ADD 和 SUB 指令高，这导致了许多编译器都优先选用 LEA 指令来实现快速加法和移位操作。  
- 下面是用 LEA 指令执行算术运算的一个例子。

lea ecx, DWORD PTR [edx+edx]

- 需要指出的是，尽管大多数反汇编器会在操作数前加上 "DWORD PTR"，但事实上 LEA 指令并不能区别指针和整数。  
- LEA 不执行任何真正意义上的内存访问。

# 整数算术运算-乘法和除法

- IA-32 处理器提供了几种不同类型的乘法、除法指令，但是它们的运算速度都相对比较慢。因此，编译器通常倾向于使用其他方式来完成乘法和除法运算。  
• 用 2 的整数次方乘或除一个数是最适合于计算机的运算, 因为这在二进制的整数中最容易表示。这就像我们可以轻松地完成乘以或除以 10 的整数次方的运算一样——只需要移小数点或者补零就可以了。  
- 计算机处理乘法和除法运算和我们的处理方法基本上是一样的。总的方法是试着将除数或乘数尽可能精确地转化成易于二进制系统表示的数值。这样，就可以执行相对比较简单的计算了，并找出将除数或乘数的其余部分用到计算中的方法。

# 整数算术运算-乘法和除法

- 对于 IA-32 处理器，等效于移小数点或者补零的操作是执行二进制移位——二进制移位可以用 SHL 和 SHR 指令完成的。  
- 移位操作完成后，编译器通常还会用加法和减法对结果做一些必要的补偿。

# 整数算术运算-乘法和除法

- 当一个变量乘以另外一个变量的时候，通常 MUL / IMUL 指令是最有效的工具。不过，当乘数是一个常数时，大多数编译器决不会使用 MUL / IMUL 指令。  
- 比如说当一个变量乘以常数 3 时, 编译器通常是先将变量左移 1 位然后加上原来的值。完成这一运算可以使用 SHL 指令和 ADD 指令, 也可以只使用 LEA 指令, 如下所示:

lea eax, DWORD PTR [eax+eax*2]

# 整数算术运算-乘法和除法

- 在更加复杂的情况下，编译器会组合使用 LEA 和 ADD 指令。  
• 例如下面这段代码——实现的是乘以 32 的运算：

lea eax, DWORD PTR [edx+edx]

add eax, eax

add eax, eax

add eax, eax

add eax, eax

# 整数算术运算-乘法和除法

- 这段代码是由 Intel 的编译器生成的, 你有没有感觉奇怪:

- 首先，就代码长度而言它很长——这段代码用了 1 个 LEA 指令和 4 个 ADD 指令，这比只用一条 SHL 指令来实现的代码长多了。  
- 其次，令人吃惊的是，这段代码的实际执行速度比只执行一条左移 5 位的 SHL 指令还要快，尽管我们认为 SHL 指令已经算是执行效率非常高的指令了。  
• 其中的原因是：LEA指令和ADD指令都是执行时间短、高吞吐量的指令。  
• 实际上, 执行完这段代码可能不到三个时钟周期（虽然这取决于具体的处理器和其他环境方面的因素）。比较而言, 执行一条 SHL 指令需要 4 个时钟周期,这就是为什么用它实现不如用上面的代码效率高的原因。

# 整数算术运算-乘法和除法

- 我们来看另一段乘法代码：

lea eax, DWORD PTR [esi+esi*2]

sal eax, 2

sub eax, esi

• 上面这段代码是用 GCC 编译器生成的，它先用 LEA 指令实现 ESI 乘以 3，然后用 SAL 指令（SAL 指令与 SHL 指令相同——它们共用同一个操作码）把结果进一步乘以 4。这两次运算将操作数乘以了 12。然后，代码又将结果减去该操作数。  
• 实际上, 这段代码是将操作数乘以 11。用数学表达式可以将这段代码表示为:  $y = (x + x^{*}2)^{*}4 - x$  。

# 整数算术运算-乘法和除法

- 对于计算机来说，除法是整数算术运算中最复杂的运算。  
- 在处理器中实现的内置除法指令有 DIV 指令和 IDIV 指令，相对其他指令来说，它们的执行速度非常慢，执行时间超过了 50 个时钟周期，而加法和减法指令执行时间不到一个时钟周期。  
- 对于除数是未知数的情况，编译器只能使用 DIV / IDIV 指令。这会影响到程序的执行性能，但对于逆向工程人员来说却是个好消息，因为这使得代码可读性强、且很直观。  
- 如果除数是常数的话，情况就变得复杂多了。编译器会根据除数的具体数值选用一些非常有创造性的技术来实现更为高效的除法。  
- 问题出现了——这样做会导致代码的可读性变差。

# 整数算术运算 - 倒数相乘

- 倒数相乘的思想是利用乘法来代替实现除法运算。在 IA-32 处理器上，乘法指令的运算速度比除法指令要快 4 到 6 倍，因此我们会在某些情况下尽量避免使用除法指令，而代之以乘法指令。  
- 其思路就是将被除数乘以除数的倒数。  
• 举例来说, 如果要用 30 除以 3 , 可以容易地计算出 3 的倒数, "1÷3", 计算的结果近似为 0.333 , 再用 30 乘以 0.333 , 就可以得到正确的结果 10 。  
- 在整数算术运算中实现倒数相乘要比这个例子复杂得多，因为能使用的数据类型只有整型。

# 整数算术运算 - 倒数相乘

- 为了解决这一问题，编译器采用了一种被称为“定点运算”的方法。  
- 定点算法采用固定的小数点位置。表示小数时不再用阶码（即小数点在浮点数据类型中的位置），而是要保持小数点的位置不变。  
- 这和硬件浮点数机制截然不同。  
- 硬件浮点数机制是由硬件负责给整数部分和小数部分分配可用的位。有了这种机制，浮点数就可以表示很大范围的数——从极小的数（在 0 到 1 之间的实数）到极大的数（在小数点前有数十个 0）。

# 整数算术运算 - 倒数相乘

• 用整型数来近似地表示实数，需要在整数中定义一个假想的小数点，用它来确定哪一部分表示的是该实数的整数值而哪一部分表示的是该实数的小数部分。  
• 实数的整数值就用划分后用于表示整数部分的“位”（分配的数量）按照普通的整型数的方式来表示。实数的小数部分尽可能精确地用可用的位数表示出来。  
- 显然，很多实数值都不能精确地表示，只能近似地表示。  
• 举例来说, 要表示 0.5 , 小数值应为  $0 \times 80000000$  (假定是 32 位的小数值), 要表示 0.1 , 可以近似为 0.125 , 其小数值应为  $0 \times 20000000$  ( )。  
•  $0.125 * 2 = 0.25$ , 取整数部分 0 ;  $0.25 * 2 = 0.5$ , 取 0 ;  $0.5 * 2 = 1$ , 取 1 。所以 0.125 的二进制结果为 0.001 ( .0010 0000 0000 0000 0000 0000 0000 0000 0000 )

# 整数算术运算 - 倒数相乘

• 再回到我们原来的问题上，为了用乘法来实现除 32 位被除数的除法运算，编译器会为被除数乘上一个 32 位的倒数，相乘的结果是一个 64 位的数，其中低 32 位是余数（也是用一个小数值来表示的），高 32 位就是我们要的结果。  
- 看一下左边的代码，这段代码干了什么事？

```latex
$\begin{array}{rl} & \mathrm{argc = ~dword~ptr~4}\\ & \mathrm{argv = ~dword~ptr~8}\\ & \mathrm{envp = ~dword~ptr~0Ch}\\ & \mathrm{call~ds:rand}\\ & \mathrm{lea~ecx,~[eax + 0FFFFh]}\\ & \mathrm{mov~eax,~68DB8BADh}\\ & \mathrm{imul~ecx}\\ & \mathrm{sar~edx,~0Ch}\\ & \mathrm{mov~eax,~edx}\\ & \mathrm{shr~eax,~1Fh}\\ & \mathrm{add~eax,~edx}\\ & \mathrm{push~eax}\\ & \mathrm{push~offset~Format~;~"a=%d\n"}\\ & \mathrm{call~ds:printf}\\ & \mathrm{add~esp,~8}\\ & \mathrm{xor~eax,~eax}\\ & \mathrm{retn} \end{array}$
```

```txt
int __cdecl main(int argc, const char **argv, const char **envp)  
{  
    int v3; // eax  
    v3 = rand();  
    printf("a=%d\n", (v3 + 0xFFFF) / 10000);  
    return 0;  
}
```

# 整数算术运算 - 倒数相乘

68DB8BADh 与除数 10000 (2710h) 什么关系?

$$
1 0 0 0 0 {=} 6 2 5 ^ {*} 2 ^ {4},
$$

$$
1 / 1 0 0 0 0 = (1 / 6 2 5) / 2 ^ {4} = 0. 0 0 1 6 * 2 ^ {8} / 2 ^ {1 2}
$$

0.0016 用 32 位的小数表示:

$$
\begin{array}{l} 1 / 1 0 0 0 0 = (0. 0 0 1 6 * 2 ^ {8}) / 2 ^ {1 2} \\ = (0. 0 0 1 6 <   <   8) > > 1 2 \\ = 0 \times 6 8 d b 8 b a c > > 0 \times 0 C \\ \end{array}
$$

```python
def dec2bin(x):
    x -= int(x)
    bins = []
while x:
    x *= 2
    bins.append("1" if x >= 1. else "0")
    x -= int(x)
return bins
bins = dec2bin(.0016)
#ss = bins[8+i] for i in 32
binchar =".join(bins[8:40])
print(hex(int(binchar, 2)))
print("length = %d" len(bins))
print(bins[0:40])
```

0x68db8bac

左移8位

length = 62

$$
\begin{array}{l} \left[ \begin{array}{c c c c c c c c c} 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} \\ 1 ^ {\prime} & 0 ^ {\prime} & 1 ^ {\prime} & 1 ^ {\prime} & 1 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} & 0 ^ {\prime} \end{array} \right], \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime}, \quad 1 ^ {\prime}, \quad 0 ^ {\prime} ] \end{array}
$$

# 整数算术运算 - 倒数相乘

再回到我们原来的代码  
代码中直接取 edx 相当于  $>> 32$ , 然后再 saredx, OCh, 总体右移了 44 位  $(32 + 12)$  
为什么是右移 12 位呢, 因为这个数是  $1 / 625$  的, 但  $10000 = 625 * 2^{4}$  
0x68db8bad 是 1/625 左移 8 位，再左移 4 位恰好就是 1/10000 的 2 进制值

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/c32994ce-f964-4218-9409-5cd29df458a9/39fcb4f1734c417a02471bd350c67f3d6e5d8e9132b3cb7d7baec5b7155e2dbc.jpg)

# 整数算术运算 - 倒数相乘

• 在计算 0.0016 小数值时，如果把二进制值左移不是 8 位，例如 7 位呢（取 [7:39]，则得到的 16 进制值为  $0 \times 346 \mathrm{dc} 5 \mathrm{~d} 6 + 1$  ，是否能得到同样的结果呢？  
- 反编译能够得到同样的结果!

```latex
$\begin{array}{rl} & \mathrm{argc = ~dword~ptr~4}\\ & \mathrm{argv = ~dword~ptr~8}\\ & \mathrm{envp = ~dword~ptr~0Ch}\\ & \mathrm{call~ds:rand}\\ & \mathrm{lea~ecx,~[eax + 0FFFFh]}\\ & \mathrm{mov~eax,~346DC5D7h}\\ & \mathrm{imul~ecx}\\ & \mathrm{sar~edx,~0Bh}\\ & \mathrm{mov~eax,~edx}\\ & \mathrm{shr~eax,~1Fh}\\ & \mathrm{add~eax,~edx}\\ & \mathrm{push~eax}\\ & \mathrm{push~offset~Format};\quad \text{"a=%d\n"}\\ & \mathrm{call~ds:printf}\\ & \mathrm{add~esp,~8}\\ & \mathrm{xor~eax,~eax}\\ & \mathrm{retn} \end{array}$
```

```c
int __cdecl main(int argc, const char **argv, const char **envp)  
{  
    int v3; // eax  
    v3 = rand();  
    printf("a=%d\n", (v3 + 0xFFFF) / 10000);  
    return 0;
```

# 整数算术运算 - 倒数相乘

# - 倒数相乘还可以换一种方法理解

• 考虑  $a / b = c$  
b 是常量  
• 设  $b^{*} k = 2 \wedge n$  
2 的 n 次直接用移位运算即可  
• a *2^n/ (b*2 ^n) = c  
• a * b *k/b = c* 2^n  
• a *k >>> n = c  
- 所以  $a * k >> n = a / b \parallel$  编译器会选择  $n$  的长度从而保证后面位数舍弃时, 造成的影响最小  
- 当  $b = 625$  时,  $n = 40, k = 68DB8BACh + 1 = 68DB8BADh$  
- 对不同的除数  $b$ , 选取合适的  $n$  和  $k$ , 除法运算就变成了乘法和移位运算。

# 整数算术运算 - 倒数相乘

# 32 位魔术数的示例

d 是除数  
M 是魔术数  
s 是右移的位数  
•  $a * M \gg s = a / d$

<table><tr><td></td><td colspan="2">Signed</td><td colspan="2">Unsigned</td><td></td></tr><tr><td>d</td><td>M(hex)</td><td>s</td><td>M(hex)</td><td>a</td><td>s</td></tr><tr><td>-5</td><td>99999999</td><td>1</td><td></td><td></td><td></td></tr><tr><td>-3</td><td>55555555</td><td>1</td><td></td><td></td><td></td></tr><tr><td>-2k</td><td>7FFFFFFF</td><td>k-1</td><td></td><td></td><td></td></tr><tr><td>1</td><td>-</td><td>-</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2k</td><td>80000001</td><td>k-1</td><td>232-k</td><td>0</td><td>0</td></tr><tr><td>3</td><td>55555556</td><td>0</td><td>AAAAAAAAAB</td><td>0</td><td>1</td></tr><tr><td>5</td><td>66666667</td><td>1</td><td>CCCCCCCD</td><td>0</td><td>2</td></tr><tr><td>6</td><td>2AAAAAAAB</td><td>0</td><td>AAAAAAAAB</td><td>0</td><td>2</td></tr><tr><td>7</td><td>92492493</td><td>2</td><td>24924925</td><td>1</td><td>3</td></tr><tr><td>9</td><td>38E38E39</td><td>1</td><td>38E38E39</td><td>0</td><td>1</td></tr><tr><td>10</td><td>66666667</td><td>2</td><td>CCCCCCCD</td><td>0</td><td>3</td></tr><tr><td>11</td><td>2E8BA2E9</td><td>1</td><td>BA2E8BA3</td><td>0</td><td>3</td></tr><tr><td>12</td><td>2AAAAAAAB</td><td>1</td><td>AAAAAAAAB</td><td>0</td><td>3</td></tr><tr><td>25</td><td>51EB851F</td><td>3</td><td>51EB851F</td><td>0</td><td>3</td></tr><tr><td>125</td><td>10624DD3</td><td>3</td><td>10624DD3</td><td>0</td><td>3</td></tr><tr><td>625</td><td>68DB8BAD</td><td>8</td><td>D1B71759</td><td>0</td><td>9</td></tr></table>