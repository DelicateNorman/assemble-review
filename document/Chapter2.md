# 第2章 8086的指令系统

计算机是通过指令序列来解决问题的，每种计算机都有支持的指令集合。计算机的指令系统就是指该计算机能够执行的全部指令的集合。Intel 8086 指令系统可分为 6 类：数据传送类指令，算术运算类指令，位操作类指令，控制转移类指令，串操作类指令，处理机控制类指令。

本章的重点是理解 8086 常用指令的功能，这是进行汇编语言程序设计的基础。为了更好地掌握每条指令，可以利用调试程序 DEBUG 作为实践环境进行指令汇编和单步执行，观察各种指令执行的实际效果。

下面将分类讲解每条指令。在学习每条指令时，请注意如下几方面。

指令的功能——该指令能够实现何种操作。通常，指令助记符就是指令功能的英文单词或其缩写形式。  
指令支持的寻址方式——该指令中的操作数可以采用何种寻址方式。1.6节介绍了大多数指令支持的各种寻址方式，并给出本书采用的符号。  
指令对标志的影响——该指令执行后是否对各标志位有影响，以及如何影响。  
其他方面——该指令其他需要注意的地方，如指令执行时的约定设置、必须预置的参数、隐含使用的寄存器等。

# 2.1 数据传送类指令

数据传送是计算机中最基本、最重要的一种操作。传送指令也是最常使用的一类指令。数据传送指令的功能是把数据从一个位置传送到另一个位置。8086有14种数据传送指令，实现寄存器和寄存器之间、主存和寄存器之间、AL/AX与外设端口之间（见5.4.1节）的字与字节的多种传送操作。

数据传送类指令除标志寄存器传送指令外，均不影响标志位。指令介绍中不再说明。

# 2.1.1 通用数据传送指令

通用数据传送指令包括 MOV、XCHG 和 XLAT 指令，提供方便灵活的通用传送操作。

# 1. 传送指令 MOV

传送指令MOV的格式如下：

mov dest, src ;dest<src

MOV指令把1字节或字的操作数从源地址src传送至目的地址dest（其中，“ $\leftarrow$ ”表示赋值，下同）。源操作数可以是立即数、寄存器或主存单元，目的操作数可以是寄存器或主存单元，但不能是立即数。MOV指令是采用寻址方式最多的指令，用约定的符号可以表达如下：

```txt
mov reg/mem,imm ；立即数送寄存器或主存  
mov reg/mem/seg,reg ；寄存器送寄存器（包括段寄存器）或主存  
mov reg/seg,mem ；主存送寄存器（包括段寄存器）
```

；段寄存器送主存或寄存器也就是说，MOV指令可以实现立即数到寄存器、立即数到主存的传送，以及寄存器与寄存器之间、寄存器与主存之间、寄存器与段寄存器之间的传送、主存与段寄存器之间的传送。

（1）立即数传送至通用寄存器（不包括段寄存器）或存储单元

mov reg/mem,imm ;reg/mem--imm

【例2.1】立即数传送。

```txt
mov al, 4 ; al←4，字节传送  
mov cx, 0ffh ; cx←00ffh，字传送  
mov si, 200h ; si←0200h，字传送  
mov byte ptr[si], 0ah ; ds:[si]←0ah，byte ptr说明是字节操作  
mov word ptr[si+2], 0bh ; ds:[si+2]←0bh，word ptr说明是字操作
```

注意观察每条指令。例如，在上述第2条指令中，立即数（OFFH）使用了前导0。因为在程设计语言中字母开头通常表示标识符（如常量、变量、标号等），所以MASM规定十六进制如果以字母开头需要添加前导0，以便与标识符区别。同样，最后2条指令的立即数也使用前导0（0AH和0BH)，如果缺少这个0，则会被理解为寄存器（AH和BH)。

在包括传送指令的绝大多数双操作数指令中（除非特别说明），目的操作数与源操作数必须类型一致，或者同为字，或者同为字节，否则为非法指令。例如：

mov al, 050ah ; 非法指令: 050ah 为字, 而 al 为字节指定的寄存器有明确的字节或字类型, 所以对应的立即数必须分别是字节或字。但在涉及存储单元时, 指令中给出的立即数可以理解为字, 也可以理解为字节, 此时必须显式指明。为区别字节传送还是字传送, 可用汇编操作符 byte ptr (字节) 和 word ptr (字) 指定。

注意，8086 不允许立即数传送至段寄存器，所以下列指令是非法的：

mov ds, 100h ; 非法指令：不允许立即数至段寄存器的传送

（2）寄存器传送至寄存器（包括段寄存器）或存储单元

mov reg/mem/seg,reg ;reg/mem/seg←reg

【例2.2】 寄存器传送。

```txt
mov ax,bx mov ah, al mov ds, ax mov [bx], a
```

（3）存储单元传送至寄存器（包括段寄存器）

MOV REG/SEG, MEM ; REG/SEG←MEM

【例2.3】 存储器传送。

```txt
mov al, [bx] mov dx, [bp] ; dx←ss:[bp] mov es, [si] ; es←ds:[si]
```

8086指令系统除串操作类指令外，不允许两个操作数都是存储单元，所以没有主存至主存的数据传送，要实现这种传送可通过寄存器间接实现。

【例2.4】buffer1单元的数据传送至buffer2单元。buffer1和buffer2是两个字变量。

```txt
mov ax, buffer1 ; ax←buffer1（将buffer1内容送ax)  
mov buffer2, ax ; buffer2←ax  
; buffer1、buffer2实际表示直接寻址方式
```

虽然存在通用寄存器和存储单元向 CS 段寄存器传送数据的指令,却不允许执行,因为  ${}^{2}$

样直接改变 CS 值将引起程序执行混乱。例如:

mov cs, [si] ; 不允许使用的指令

（4）段寄存器传送至通用寄存器（不包括段寄存器）或存储单元

mov reg/mem,seg ;reg/mem←seg

【例2.5】 段寄存器传送。

```txt
mov [si], ds  
mov ax, es  
mov ds, ax
```

注意，不允许段寄存器之间的直接数据传送。例如：

mov ds, es ; 非法指令：不允许seg←seg传送

# 2. 交换指令XCHG

交换指令用来将源操作数和目的操作数内容交换，其格式为：

xchg reg,reg/mem ;reg  $\longleftrightarrow$  reg/mem，也可表达为：xchgreg/mem，reg

XCHG指令中操作数可以是字也可以是字节，可以在通用寄存器与通用寄存器或存储器之间对换数据，但不能在存储器与存储器之间交换数据。

【例2.6】用交换指令实现寄存器之间的数据交换。

```txt
mov ax, 1234h ; ax=1234h  
mov bx, 5678h ; bx=5678h  
xchg ax, bx ; ax=5678h, bx=1234h  
xchg ah, al ; ax=7856h
```

【例2.7】用交换指令实现寄存器与存储器之间的数据交换。

```txt
xchg ax, [2000h] ; 也可以表达为 xchg [2000h], ax  
xchg al, [2000h] ; 也可以表达为 xchg [2000h], al
```

# 3. 换码指令XLAT

换码指令用于将 BX 指定的缓冲区中，AL 指定的位移处的数据取出赋给 AL，格式为：

```txt
xlat label  
xlat al←ds:[bx+al]
```

这两种格式完全等效。第一种格式中, label 表示首地址的符号, 既便于阅读也便于明确缓冲区所在的逻辑段; 第二种格式也可以用 XLATB 助记符。实际的首地址在 BX 寄存器中。

【例2.8】将首地址为  $100\mathrm{H}$  的表格缓冲区中的3号数据取出。

```txt
mov bx, 100h mov al, 03h xlat
```

换码指令常用于将一种代码转换为另一种代码，如扫描码转换为 ASCII 编码，数字  $0 \sim 9$  转换为 7 段显示码等。使用前，首先在主存中建立一个字节量表格，表格的内容是要转换成的目的代码，表格的首地址存放于 BX 寄存器中，需要转换的代码存放于 AL 寄存器，要求被转换的代码应是相对表格首地址的位移量。设置好后，执行换码指令，即将 AL 寄存器的内容转换为目标代码。

最后说明一点, 因为 AL 的内容实际上是距离表格首地址的位移量, 只有 8 位, 所以表格的最大长度为 256 , 超过 256 的表格需要采用修改 BX 和 AL 的方法才能转换。

XLAT指令中没有显式指明操作数，而是默认使用BX和AL寄存器。这种采用默认操作

数的方法称为隐含寻址方式, 指令系统中有许多指令采用隐含寻址方式。

# 2.1.2 堆栈操作指令

堆栈是一个“先进后出”的主存区域，位于堆栈段中，使用SS段寄存器记录其段地址。堆栈只有一个出口，即当前栈顶。栈顶是地址较小的一端（低端），它用堆栈指针寄存器SP指定。在图2-1(a)中，堆栈内还没有数据，是空的，此时栈顶和栈底指向同一个单元。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/78e5d5920ad5c604d872e8a7c6d97d668f8de2eeabe7cc954d92b6d9e1085e0d.jpg)  
(a) 堆栈段  
图2-1 堆栈操作

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/ca13f8b8c86600b02a289eba8feef26d0f0a12f4e8d372ce152ff0963ecca0ce.jpg)  
(b) 进栈 PUSH

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/d052c28fa8c5a3c5c8a5af65e5b4cd6eb3b1dc3f1b6d7c1b7aea026ba196f535.jpg)  
(c)出栈POP

堆栈有两种基本操作，对应有两条基本指令：进栈指令PUSH和出栈指令POP。

# 1. 进栈指令 PUSH

进栈指令先使堆栈指针 SP 减 2，然后把一个字操作数存入堆栈顶部。堆栈操作的对象只能是字操作数，进栈时，低字节存放于低地址，高字节存放在高地址，SP 相应向低地址移动字节单元。

```txt
push r16/m16/seg ; sp←sp-2, ss:[sp]←r16/m16/seg
```

【例2.9】将7812H压入堆栈（见图2-1(b)）。

mov ax, 7812h

push ax

再如，将主存单元DS:[2000H]的一个字压入堆栈。

push [2000h]

# 2. 出栈指令POP

出栈指令把栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP加2。目的操作数应为字操作数，字从栈顶弹出时，低地址字节送低字节，高地址字节送高字节。

```txt
pop r16/m16/seg ; r16/m16/seg←ss:[sp], sp←sp+2
```

【例2.10】将栈顶一个字的内容弹出送AX寄存器（见图2-1(c)）。

pop ax

再如，将栈顶一个字送入主存 DS:[2000H]：

pop [2000h]

堆栈是系统中不可缺少的数据区域。堆栈可用来临时存放数据，以便随时恢复它们。堆栈也常用于在子程序间传递参数。在子程序中，通常需要保存被修改的寄存器内容，以便在返回时恢复它们，这时可用下例的方法。

【例2.11】 现场的保护与恢复。

```txt
push ax ;进入子程序后（或调用子程序前）  
push bx  
push ds  
pop ds ;返回主程序前（或调用子程序后）  
pop bx  
pop ax
```

注意：POP指令的顺序与PUSH指令相反，因为堆栈是一个先进后出的区域，只有这样才能使各寄存器恢复原来内容。

8086 处理器的堆栈建立在主存区域中，使用 SS 段寄存器指向段基地址。堆栈段的范围由堆栈指针寄存器 SP 的初值确定，这个位置就是堆栈底部（不再变化）。堆栈只有一个数据出入口，即当前栈顶（不断变化），由堆栈指针寄存器 SP 的当前值指定栈顶的偏移地址，如图 2-2 所示。随着数据进入堆栈，SP 逐渐减小；数据依次弹出、SP 逐渐增大。随着 SP 增大，弹出的数据不再属于当前堆栈区域中；随后进入堆栈的数据也会占用这个存储空间。当然，如果进入堆栈的数据超出了设置的堆栈范围，或者已无数据可以弹出，即 SP 增大到栈底，就产生堆栈溢出错误。堆栈溢出，轻者使程序出错，重者导致系统崩溃。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/892411dc7c15cf28d148934d677ef967bcc37d4d030e824295a95ac2375c8ee9.jpg)  
图2-2 8086处理器堆栈操作

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/67c423f30a7e0f398b1fe5a9dcd357e6b85bdfb01b2648eae8ac16bdc0060265.jpg)

堆栈操作常被比喻为“摞盘子”。盘子一个压着一个叠起来放进箱子里，就像数据进栈操作；叠起来的盘子应该从上面一个接一个拿走，就像数据出栈操作。最后放上去的盘子被最先拿走，就是堆栈的“后进先出”操作原则。不过，8086处理器的堆栈段是“向下生长”的，即随着数据进栈，堆栈顶部（指针SP）逐渐减小，所以可以想像成为一个倒扣的箱子，盘子（数据）从下面放进去。

# 3. 堆栈的应用

堆栈是程序中不可或缺的一个存储区域。除堆栈操作指令外，还有子程序调用CALL和子程序返回RET、中断调用INT和中断返回IRET等指令，以及内部异常、外部中断等情况都会使用堆栈、修改SP值（将在后续章节中逐渐展开）。

堆栈可用来临时存放数据，以便随时恢复它们。使用POP指令时，应该明确当前栈顶的数据是什么，可以按程序执行顺序向前观察由哪个操作压入了该数据。

既然堆栈是利用主存实现的，当然能以随机存取方式读写其中的数据。通用寄存器之一的堆栈基址指针BP就是出于这个目的而设计的。例如：

```txt
mov bp, sp ; bp←sp
```

mov ax，[bp+4] ;ax<-ss:[bp+4],bp默认与堆栈段配合

mov [bp], ax ss:[bp]  $\leftarrow$  ax

利用堆栈实现主、子程序间传递参数就利用上述方法，这也是堆栈的主要作用之一。

堆栈还常用于子程序的寄存器保护和恢复。由于堆栈的栈顶和内容随着程序的执行不化，因此编程时要注意入栈和出栈的数据要成对，要保持堆栈平衡。

# 2.1.3 标志传送指令

# 1.标志寄存器传送

标志寄存器传送指令用来传送标志寄存器的内容，包括LAHF/SAHF、PUSHF/POPF指令

# （1）标志送AH指令LAHF

LAHF指令将标志寄存器FLAGS的低字节送寄存器AH，即状态标志位SF/ZF/AF/PI分别送入AH的第7/6/4/2/0位，而AH的第5/3/1位任意。

1ahf ; ah<flags 的低字节

# （2）AH送标志指令SAHF

SAHF 将 AH 寄存器内容送 FLAGS 的低字节, 即根据 AH 的第 7、6、4、2、0 位相置 SF、ZF、AF、PF、CF 标志。由此可见, SAHF 和 LAHF 是一对功能相反的指令, 它影响标志寄存器的低 8 位, 而对高 8 位无影响。

sahf ; flags的低字节  $\leftarrow$  ah

# （3）标志进栈指令PUSHF

PUSHF 指令将标志寄存器的内容压入堆栈，同时栈顶指针 SP 减 2。这条指令可用来为全部标志位。

pushf ; sp←sp-2, ss:[sp]←flags

# （4）标志出栈指令POPF

POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2。

popf ; flags  $\leftarrow$  ss:[sp],sp←sp+2

【例2.12】 置位单步标志TF。

```txt
pushf ;保存全部标志到堆栈  
pop ax ;从堆栈中取出全部标志  
or ax, 0100h ;设置d8=tf=1，而ax其他位不变  
push ax ;将ax压入堆栈  
popf ;将堆栈内容取到标志寄存器，即flags<-ax
```

# 2.标志位操作

标志位操作指令可用来对 CF、DF 和 IF 三个标志位进行设置，除影响其所设置的标志均不影响其他标志。

```txt
clc ;复位进位标志：CF  $\leftarrow 0$    
stc ;置位进位标志：CF  $\leftarrow 1$    
cmc ;求反进位标志：CF  $\leftarrow \sim \mathrm{CF}$    
cld ;复位方向标志：DF  $\leftarrow 0$    
std ;置位方向标志：DF  $\leftarrow 1$    
cli ;复位中断标志，禁止可屏蔽中断：IF  $\leftarrow 0$    
sti ;置位中断标志，允许可屏蔽中断：IF  $\leftarrow 1$
```

许多指令的执行都会影响标志，上述指令提供了直接改变CF、DF、IF的方法。标志寄

器中的其他标志需要用 LAHF/SAHF 或 PUSHF/POPF 指令间接改变。

# 2.1.4 地址传送指令

地址传送指令将存储器的逻辑地址送至指定的寄存器。

# 1. 有效地址传送指令LEA

LEA指令将存储器操作数的有效地址传送至指定寄存器。

```txt
lea r16, mem ; r16←mem 的有效地址 ea
```

【例2.13】有效地址的获取。

```txt
mov bx, 0400h  
mov si, 3ch  
lea bx, [bx+si+0f62h]; bx←bx+si+0f62h=0400h+3ch+0f62h=139eh
```

这里，BX得到的是主存单元的有效地址，不是物理地址，也不是该单元的内容。

# 2. 指针传送指令

LDS 和 LES 指令将主存中 MEM 指定的字送至 R16，并将 MEM 的下一字送 DS 或 ES 寄存器。实际上，MEM 指定了主存的连续 4 字节作为逻辑地址，即 32 位的地址指针。

```csv
lds r16, mem ; r16←mem, ds←mem+2  
les r16, mem ; r16←mem, es←mem+2
```

【例2.14】 地址指针的传送。

```txt
mov word ptr [3060h], 0100h  
mov word ptr [3062h], 1450h  
lds si, [3060h] ; ds=1450h, si=0100h  
les di, [3060h] ; es=1450h, di=0100h
```

# 2.2 算术运算类指令

算术运算类指令用来执行二进制数及十进制数的算术运算：加、减、乘、除。这类指令会根据运算结果影响状态标志，有时要利用某些标志才能得到正确的结果。

2.1 节介绍的数据传送类指令中，除了标志为目的操作数的标志传送指令外，其他传送指令并不影响标志；也就是说，标志并不因为传送指令的执行而改变，所以没有涉及标志问题。但现在我们需要了解它们了。

# 2.2.1 状态标志

一方面，状态标志作为加、减运算和逻辑运算等指令的辅助结果，另一方面，用于构成各种条件、实现程序分支，是汇编语言编程中非常重要的方面。

# 1. 进位标志 CF（Carry Flag）

处理器设计的进（借）位标志类似十进制数据加减运算中的进位和借位，不过只是体现二进制数据最高位的进位或借位。具体来说，当加减运算结果的最高有效位有进位（加法）或借位（减法）时，将设置进位标志为1，即  $\mathrm{CF} = 1$ ；如果没有进位或借位，则设置进位标志为0，

即  $\mathrm{{CF}} = 0$  。换句话说,加减运算后,如果  $\mathrm{{CF}} = 1$  ,则说明数据运算过程中出现了进位或借位；如果  $\mathrm{{CF}} = 0$  ,则说明没有进位或借位。

例如，有两个8位二进制数00111010和01111100，如果相加，运算结果是10110110。计算过程中，最高位没有向上再进位，所以这个运算结果将使得  $\mathrm{CF} = 0$  。但如果是10101010和01111100相加，结果是[1]00100110，出现了向高位进位（用[]表达），所以这个运算结果将使得  $\mathrm{CF} = 1$  。

进位标志是针对无符号整数运算设计的，反映无符号数据加减运算结果是否超出范围、是否需要利用进（借）位反映正确结果。 $N$  位无符号整数表示的范围是： $0 \sim 2^{N} - 1$ 。如果相应的数的加减运算结果超出了其能够表示的这个范围，就是产生了进位或借位。

在上面例子中，二进制数据  $00111010 + 01111100 = 10110110$  被转换成十进制数表示为  $58 + 124 = 182$  。运算结果182仍在  $0\sim 255$  范围之内，没有产生进位，所以  $\mathrm{CF} = 0$  。

对于二进制数据  $10101010 + 01111100 = [1]00100110$ ，将它们转换成十进制数表示是  $170 + 1294 = 256 + 38$ 。运算结果294超出了  $0 \sim 255$  范围，所以使得  $\mathrm{CF} = 1$ 。这里，进位  $\mathrm{CF} = 1$  表示了十进制数据256。

# 2. 溢出标志 OF (Overflow Flag)

把水倒入茶杯时, 如果超出了茶杯容量, 水会漫出来, 这就是溢出的本意: 一个容器不能存放超过其容积的物体。同理, 处理器设计的溢出标志用于表示有符号整数进行加减运算的结果是否超出范围。若超出范围, 就是有溢出, 将设置溢出标志  $OF = 1$ , 否则  $OF = 0$  。

溢出标志是针对有符号整数运算设计的，反映有符号数据加减运算结果是否超出范围。处理器默认采用补码形式表示有符号整数， $N$  位补码表达的范围是： $-2^{N-1} \sim +2^{N-1}-1$ 。如果有符号整数运算结果超出了这个范围，就是产生了溢出。

对上面例子的两个8位二进制数0011010和01111100，按照有符号数的补码规则它们都是正整数，即十进制数58和124。它们求和的结果是二进制数10110110，即十进制数182。运算结果182超出了  $-128\sim +127$  范围，产生溢出，所以  $OF = 1$  。另一方面，按照补码规则，8位二进制数结果10110110的最高位为1，实际上表达的是负数，所以在溢出情况下的运算结果是错误的。

对于二进制数 10101010，最高位是 1，按照补码规则表达负数，求反加 1 得到绝对值，即十进制数 -86。它与二进制数 01111100（十进制数表示为 124）相加，结果是 [1] 00100110。因为进行有符号数据运算，所以不考虑无符号运算出现的进位，00100110 才是我们需要的结果，即 38  $(-86 + 124)$ 。运算结果 38 没有超出  $-128 \sim +127$  范围，将使得  $\mathrm{OF} = 0$ 。所以，有符号数据进行加减运算，只有在没有溢出情况下才是正确的。

注意，溢出标志 OF 和进位标志 CF 是两个意义不同的标志。进位标志表示无符号整数运算结果是否超出范围，超出范围后加上进位或借位运算结果仍然正确；而溢出标志表示有符号整数运算结果是否超出范围，超出范围运算结果不正确。处理器对两个操作数进行运算时，按照无符号整数求得结果，并相应设置进位标志 CF；同时，根据是否超出有符号整数的范围，置溢出标志 OF。应该利用哪个标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数，就应该关心进位；若认为是有符号数，则要注意是否溢出。

处理器利用异或门等电路判断运算结果是否溢出。按照处理器硬件的方法或者前面论述的原则进行判断会比较麻烦，这里给出一个人工判断的简单规则：只有当两个相同符号数相加（含

两个不同符号数相减）而运算结果的符号与原数据符号相反时，才产生溢出，因为此时的运算结果显然不正确，在其他情况下则不会产生溢出。

# 3. 其他状态标志

零标志ZF（Zero Flag）反映运算结果是否为0。若运算结果为0，则设置ZF=1，否则ZF=0。例如，8位二进制数  $00111010 + 01111100 = 10110110$  ，结果不是0，所以设置ZF=0。如果是8位二进制数  $10000100 + 01111100 = [1]00000000$  ，最高位进位有进位CF标志反映，除此之外的结果是0，所以这个运算结果将使得ZF=1。注意，零标志ZF=1，反映结果是0。

符号标志SF（Sign Flag）反映运算结果是正数还是负数。处理器通过符号位可以判断数据的正负，因为符号位是二进制数的最高位，所以运算结果最高位（符号位）是符号标志的状态，即运算结果最高位为1，则  $\mathrm{SF} = 1$  ，否则  $\mathrm{SF} = 0$  。例如，8位二进制数  $00111010 + 01111100 = 10110110$  ，结果最高位是1，所以设置  $\mathrm{SF} = 1$  。如果是8位二进制数  $10000100 + 01111100 = [1]00000000$  ，最高位是0（进位1不是最高位），所以这个运算结果将使得  $\mathrm{SF} = 0$  。

奇偶标志 PF（Parity Flag）反映运算结果最低字节中“1”的个数是偶数还是奇数，便于用软件编程实现奇偶校验。最低字节中“1”的个数为零或偶数时， $\mathrm{PF} = 1$ ；为奇数时， $\mathrm{PF} = 0$ 。例如，8位二进制数  $00111010 + 01111100 = 10110110$ ，结果中“1”的个数为5个，是奇数，故设置  $\mathrm{PF} = 0$ 。如果是8位二进制数  $10000100 + 01111100 = [1]00000000$ ，除进位外的结果是零个“1”，所以这个运算结果将使得  $\mathrm{PF} = 1$ 。注意，PF 标志仅反映最低8位中“1”的个数是偶数或奇数，不管进行16位或32位操作。

加减运算结果将同时影响上述5个标志，表2-1总结了前面示例，便于对比理解。

表 2-1 加法运算结果对标志的影响  

<table><tr><td>加法运算及其结果</td><td>CF</td><td>OF</td><td>ZF</td><td>SF</td><td>PF</td></tr><tr><td>00111010+01111100=[0]10110110</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>10101010+01111100=[1]00100110</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>10000100+01111100=[1]00000000</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></table>

调整标志 AF（Adjust Flag）反映加减运算时最低半字节有无进位或借位。最低半字节（即  $\mathrm{D}_3$  位向  $\mathrm{D}_4$  位）有进位或借位时， $\mathrm{AF} = 1$ ，否则  $\mathrm{AF} = 0$ 。调整标志主要由处理器内部使用，用于十进制数算术运算的调整指令，用户一般不必关心。例如，8 位二进制数  $00111010 + 01111100 = 10110110$ ，低 4 位有进位，所以  $\mathrm{AF} = 1$ 。

# 2.2.2 加法指令

加法指令包括 ADD、ADC 和 INC 指令，执行字或字节的加法运算。

# 1. 加法指令 ADD

加法指令 ADD 将源操作数与目的操作数相加，结果送到目的操作数，支持寄存器与立即数、寄存器、存储单元，以及存储单元与立即数、寄存器间的加法运算。

add

reg,imm/reg/mem

; reg←reg+imm/reg/mem

add

mem,imm/reg

;mem←mem+imm/reg

【例2.15】 加法运算。

MOV

al,0fbh

; al=0fbh

```txt
add al, 07h ;al=02h mov word ptr [200h], 4652h ;[200h]=4652h mov bx,1feh ;bx=1feh add al,b1 ;al=00h add word ptr [bx+2], 0f0f0h ;[200h]=3742h
```

ADD指令按照状态标志的定义相应设置这些标志的0或1状态。例如二进制8位加  $07 + \mathrm{FBH} \rightarrow 02\mathrm{H}$  运算后，标志为  $\mathrm{OF} = 0$  ，  $\mathrm{SF} = 0$  ，  $\mathrm{ZF} = 0$  ，  $\mathrm{AF} = 1$  ，  $\mathrm{PF} = 0$  ，  $\mathrm{CF} = 1$  ；用调试程序缩执行后，上述标志状态依次为NV，PL，NZ，AC，PO，CY。

同样，进行二进制16位加法  $4652\mathrm{H} + \mathrm{FOFOH}\rightarrow 3742\mathrm{H}$  运算后，标志为  $\mathrm{OF = 0}$  ，  $\mathrm{SF = 0}$  ，ZF=AF=0，PF=1，CF=1；调试程序依次显示为NV，PL，NZ，NA，PE，CY。注意，PF仅反低8位中“1”的个数，AF只反映  $\mathbf{D}_3$  对  $\mathbf{D}_4$  位是否有进位。

# 2. 带进位加法指令ADC

ADC指令除完成ADD加法运算外，还要加进位CF，其用法及对状态标志的影响也与AI指令一样。ADC指令主要用于与ADD指令相结合实现多精度数相加。

```txt
adc reg,imm/reg/mem reg<reg+imm/reg/mem+cf adc mem,imm/reg mem<mem+imm/reg+cf
```

【例2.16】无符号双字加法运算。

```asm
mov ax, 4652h ; ax=4652h  
add ax, 0f0f0h ; ax=3742h, cf=1  
mov dx, 0234h ; dx=0234h  
adc dx, 0f0f0h ; dx=f325h, cf=0
```

上述程序段完成  $\mathrm{DX.AX = 02344652H + F0F0F0F0H = F3253742H}$

# 3.增量指令INC

INC指令对操作数加1（增量)，是一个单操作数指令，操作数可以是寄存器或存储器。

```txt
inc reg/mem ;reg/mem--reg/mem+1
```

例如：

```txt
inc bx  
inc byte ptr [bx]
```

设计加1指令和后面介绍的减1指令的目的是用于对计数器和地址指针的调整，所以它不影响进位CF标志，对其他状态标志位的影响与ADD、ADC指令一样。

# 2.2.3 减法指令

减法指令包括 SUB、SBB、DEC、NEG 和 CMP，执行字或字节的减法运算，除 DEC 不响 CF 标志外，其他减法指令按定义影响全部状态标志位。

# 1. 减法指令SUB

减法指令 SUB 使目的操作数减去源操作数，结果送目的操作数，支持的操作数类型同法指令。

```txt
sub reg,imm/reg/mem reg- reg-imm/reg/mem   
sub mem,imm/reg mem-mem-imm/reg
```

【例2.17】 减法运算。

```txt
mov al,0fbh ;al=0fbh
```

```csv
sub al,07h ;al=0fAh,cf=0   
mov word ptr[200h],4652h ;[200h]=4652h   
mov bx,1feh ;bx=1feh   
sub al,bl ;al=0f6h,cf=1   
sub word ptr[bx+2]，0f0f0h ;[200h]=5562h,cf=1
```

# 2. 带借位减法指令 SBB

带借位减法指令SBB使目的操作数减去源操作数，还要减去借（进）位CF，结果送到目的操作数。SBB指令主要用于与SUB指令相结合，实现多精度数相减。

```txt
sbb reg,imm/reg/mem reg<reg-imm/reg/mem-cf sbb mem,imm/reg mem<mem-imm/reg-cf
```

【例2.18】 无符号双字减法运算。

```asm
mov ax, 4652h ; ax=4652h  
sub ax, 0f0f0h ; ax=5562h, of=0, sf=0, zf=0, af=0, pf=0, cf=1  
mov dx, 0234h ; dx=0234h  
sbb dx, 0f0f0h ; dx=1143h, of=0, sf=0, zf=0, af=0, pf=0, cf=1
```

上述程序段完成DX.AX=02344652H-F0F0 F0F0H=11435562H，有借位  $\mathrm{CF} = 1$  。

# 3. 减量指令 DEC

DEC指令对操作数减1（减量），是一个单操作数指令，操作数可以是寄存器或存储器。

```txt
dec reg/mem ;reg/mem--reg/mem-1
```

同 INC 指令一样，DEC 指令不影响 CF，但影响其他状态标志。例如：

```txt
dec cx  
dec word ptr [si]
```

# 4. 求补指令NEG

NEG指令也是一个单操作数指令，对操作数执行求补运算，即用零减去操作数，然后将结果返回操作数。求补运算也可以表达成：将操作数按位取反后加1。NEG指令对标志的影响与用零做减法的SUB指令一样。

```txt
neg reg/mem ;reg/mem-0-reg/mem
```

【例2.19】 求补运算。

```txt
mov ax,0ff64h   
neg al ;ax=ff9ch，of  $\equiv 0$  ，sf  $= 1$  ，zf  $= 0$  ，pf  $= 1$  ，cf  $= 1$    
sub al,9dh ;ax=fffffh，of  $\equiv 0$  ，sf  $= 1$  ，z-f  $= 0$  ，pf  $= 1$  ，cf  $= 1$    
neg ax ;ax=0001h，of  $\equiv 0$  ，sf  $= 0$  ，zf  $= 0$  ，pf  $= 0$  ，cf  $= 1$    
dec al ;ax=0000h，of  $\equiv 0$  ，sf  $= 0$  ，zf  $= 1$  ，pf  $= 1$  ，cf  $= 1$    
neg ax ;ax=0000h，of  $\equiv 0$  ，sf  $= 0$  ，zf  $= 1$  ，pf  $= 1$  ，cf  $= 0$
```

# 5. 比较指令 CMP

```csv
cmp reg,imm/reg/mem reg-imm/reg/mem   
cmp mem,imm/reg mem-imm/reg
```

比较指令将目的操作数减去源操作数，但结果不回送目的操作数。也就是说，CMP指令与减法指令SUB执行同样的操作，同样影响标志，只是不改变目的操作数。

CMP 指令用于比较两个操作数的大小关系。执行比较指令之后，可以根据标志判断两个数是否相等、大小关系等。所以，CMP 指令后面常跟条件转移指令，根据比较结果不同产生不同的分支。另外，CMP 指令的操作数与 ADD/ADC、SUB/SBB 指令都一样。

【例2.20】比较AL是否大于100。

```txt
cmp al, 100 ;al-100  
jb below ;al<100，跳转到below执行  
sub al, 100 ;al≥100，al<-al-100  
inc ah ;ah<-ah+1
```

```txt
below:
```

# 2.2.4 乘法指令

乘法指令用来实现两个二进制操作数的相乘运算，包括两条指令：无符号数乘法指令MUL和有符号数乘法指令IMUL。

```batch
mul r8/m8 ;无符号字节乘：ax<-al  $\times$  r8/m8  
mul r16/m16 ;无符号字乘：dx. ax<-ax  $\times$  r16/m16  
imul r8/m8 ;有符号字节乘：ax<-al  $\times$  r8/m8  
imul r16/m16 ;有符号字乘：dx. ax<-ax  $\times$  r16/m16
```

乘法指令隐含使用一个操作数 AX 和 DX, 源操作数则显式给出, 可以是寄存器或存储单元。若是字节量相乘, 则 AL 与  $r8 / m8$  相乘得到 16 位的字, 存入 AX 中; 若是 16 位数据相乘则 AX 与  $r16 / m16$  相乘, 得到 32 位的结果, 其高字存入 DX, 低字存入 AX 中。

乘法指令利用对 OF 和 CF 的影响, 可以判断相乘的结果中高一半是否含有有效数值。如果乘积的高一半 (AH 或 DX) 没有有效数值, 即对 MUL 指令高一半为 0 , 对 IMUL 指令高一半是低一半的符号扩展, 则  $\mathrm{{OF}} = \mathrm{{CF}} = 0$  ; 否则  $\mathrm{{OF}} = \mathrm{{CF}} = 1$  。

乘法指令对其他状态标志的影响没有定义，即成为任意，不可预测。注意，这与对标志没有影响是不同的，没有影响是指不改变原来的状态。

【例2.21】无符号数0B4H与11H相乘。

```asm
mov al, 0b4h ; al=b4h=180d  
mov bl, 11h ; bl=11h=17d  
mul bl ; ax=0bf4h=3060d,of=cf=1 (ax高8位不为0)
```

注意：含有结尾字母D表示这是一个十进制数，目的是便于与十六进制数进行比较。

这里 B4H 按照无符号整数编码是真值 180, 与 17 相乘结果为 3060, 即十六进制数 OBF4H。如果 B4H 按有符号整数编码（补码）理解, 则真值是 -76 , 与 17 相乘结果为 -1292 , 用补码表示是 FAF4H。进行有符号乘法的程序片段如下:

```txt
mov al, 0b4h ; al=b4h=-76d  
mov bl, 11h ; bl=11h=17d  
imul bl ; ax=faf4h=-1292d,of=cf=1  
; ax高8位不是低8位的符号扩展，表示含有有效数字
```

计算二进制数乘法:  $\mathrm{B4H} \times 11\mathrm{H}$  。如果把它当做无符号数, 用 MUL 指令, 则结果为  $0\mathrm{BF4H}$ , 如果看做有符号数, 用 IMUL 指令, 则结果为 FAF4H。由此可见, 同样的二进制数看做无符号数与有符号数相乘, 即采用 MUL 与 IMUL 指令, 其结果是不相同的。

# 2.2.5 除法指令

除法指令执行两个二进制数的除法运算, 包括无符号二进制数除法指令 DIV 和有符号二进制数除法指令 IDIV 两条指令。

```txt
div r8/m8 ；无符号字节除：al←ax÷r8/m8的商
```

```txt
;ah-ax÷r8/m8的余数 div r16/m16 ；无符号字除：ax-dx.ax÷r16/m16的商 dx-dx.ax÷r16/m16的余数 idiv r8/m8 有符号字节除：al-ax÷r8/m8的商 idiv r16/m16 ；有符号字除：ax-dx.ax÷r16/m16的商 dx-dx.ax÷r16/m16的余数
```

除法指令隐含使用 DX 和 AX 作为一个操作数，指令中给出的源操作数是除数。如果是字节除法，AX 除以 R8/M8，8 位商存入 AL，8 位余数存入 AH。如果是字除法，DX.AX 除以 R16/M16，16 位商存入 AX，16 位余数存入 DX。余数的符号与被除数符号相同。

【例2.22】无符号数0400H除以  $\mathrm{B4H}$

```txt
mov ax, 0400h ; ax=400h=1024d  
mov bl, 0b4h ; bl=b4h=180d  
div bl ; 商 al=05h，余数 ah=7ch=124d
```

同样，若是有符号数  $0400 \mathrm{H}$  除以  $\mathrm{B} 4 \mathrm{H}$ ，则

```txt
mov ax, 0400h ; ax=400h=1024d  
mov bl, 0b4h ; bl=b4h=-76d  
idiv bl ; 商 al=f3h=-13d，余数 ah=24h=36d
```

除法指令DIV和IDIV对标志的影响没有定义，却可能产生溢出。当被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达，便产生溢出，8086CPU中就产生编号为0的内部中断（见2.4.5节）。实用的程序中应该考虑这个问题，操作系统通常只提示出错。

对 DIV 指令, 除数为 0 , 或者在字节除时商超过 8 位, 或者在字除时商超过 16 位, 则发生除法溢出。对 IDIV 指令, 除数为 0 , 或者在字节除时商不在  $-128 \sim 127$  范围内, 或者在字除时商不在  $-32768 \sim 32767$  范围内, 则发生除法溢出。

# 2.2.6 符号扩展指令

8086处理器支持8和16位数据操作，大多数指令要求两个操作数类型一致。但是，实际的数据类型不一定满足要求。例如，16位与8位数据的加减运算，需要先将8位扩展为16位；16位除法需要将被除数扩展成32位。不过，位数扩展后数据大小不能因此改变。

对无符号数据，只要在前面加 0 就实现了位数扩展、大小不变，这就是零位扩展（Zero Extension）。例如，8 位无符号数据  $80\mathrm{H}$  （ $=128$ ），零位扩展为 16 位  $0080\mathrm{H}$  （ $=128$ ）。8086 没有设计实现零位扩展的指令，需要时可以直接对高位进行赋值 0 实现。

对有符号数据（补码）表示，增加位数而保持数据大小不变，需要进行符号扩展（Flag Extension），即用一个操作数的符号位（即最高位）形成另一个操作数，增加的各位全部是符号位的状态。例如，8 位有符号数据  $64 \mathrm{H} (= 100)$  为正数，符号位为 0，（高位）符号扩展成 16 位是  $0064 \mathrm{H} (= 100)$  。再如：16 位有符号数据  $\mathrm{FF00H} (= -256)$  为负数，符号位为 1，符号扩展成 32 位是  $\mathrm{FFFFFF00H} (= -256)$  。典型的例子是真值“-1”，字节量补码表达是 FFH，字量补码是 FFFFH，双字量补码表达为FFFFFFFH。

8086 设计有 2 条符号扩展指令 CBW 和 CWD。CBW 指令将 AL 的最高有效位 D7 扩展至 AH, 即: 如果 AL 的最高有效位是 0 , 则 AH=00 ; AL 的最高有效位为 1 , 则 AH=FFH, AL 不变。CWD 将 AX 的内容符号扩展形成 DX, 即: 如果 AX 的最高有效位  $\mathrm{D}_{15}$  为 0 , 则  $\mathrm{DX} = 0000 \mathrm{H}$ ;

如果AX的最高有效位  $\mathrm{D}_{15}$  为1，则  $\mathrm{DX} = \mathrm{FFFFH}$

```txt
cbw ;al符号扩展到ax  
cwd ;ax符号扩展到dx和ax寄存器对  $(\mathrm{dx},\mathrm{ax})$
```

【例2.23】符号扩展

```asm
mov al, 80h ;al=80h cbw ;ax=ff80h add al,255 ;al=7fh cbw ;ax=007fh
```

符号扩展指令常用来获得除法指令所需要的被除数。

【例2.24】 进行有符号数除法  $\mathrm{AX} \div \mathrm{BX}$

```txt
cwd idiv bx
```

整数数据经过零位或者符号扩展增加了位数, 大小没有变化, 新扩展的位数只是数据的符号, 并没有数值含义。反过来说, 如果高位部分都是符号位, 可以截断这些高位部分, 也不改变数据大小。例如, 真值 -1 用 32 位补码表达为 FFFFFFFH, 高位都是符号位, 所以截断高 16 位, 得到 16 位表达是 FFFFH; 其实 “-1” 用 8 位就可以表达了, 所以可以再截断高 8 位。

这时，回过来理解乘法指令对标志OF和CF影响的设计原因。两个  $N$  位数据相乘，可能得到  $2N$  位的乘积。但如果乘积的高一半是低一半的符号位扩展，说明高一半不含有效数值，就可以放心地截断高一半而不影响正确的结果。

# 2.2.7 十进制调整指令

前面介绍的算术运算指令都是针对二进制数的。然而，十进制是我们日常使用的进制。为了方便进行十进制数的运算，8086提供一组十进制数调整指令。这组指令对二进制数运算的结果进行十进制调整，以得到十进制数的运算结果。

十进制数在计算机中也要用二进制编码表示，这就是二进制编码的十进制数：BCD 码。8086 支持压缩 BCD 码和非压缩 BCD 码，相应地，十进制调整指令分为压缩 BCD 码调整指令和非压缩 BCD 码调整指令。

# 1. 压缩BCD码调整指令

压缩 BCD 码是通常的 8421 码, 它用 4 个二进制位表示一个十进制位, 1 字节可以表示两个十进制位, 即  $00 \sim 99$  。压缩 BCD 码调整指令包括加法和减法的十进制调整指令 DAA 和 DAS。用来对二进制数加、减法指令的执行结果进行调整, 得到十进制数结果。注意, 在使用 DAA 或 DAS 指令前, 应先执行加法或减法指令。DAA 指令跟在以 AL 为目的操作数的 ADD 或 ADC 指令后, 对 AL 的二进制数结果进行十进制调整, 并在 AL 中得到十进制数结果。DAS 指令跟在以 AL 为目的操作数的 SUB 或 SBB 指令之后, 对 AL 的二进制数结果进行十进制调整, 并在 AL 中得到十进制数结果。

```txt
daa ;al←将al中的加和调整为压缩bcd码das ;al←将al中的减差调整为压缩bcd码
```

DAA 和 DAS 指令对 OF 标志无定义, 按结果影响所有其他标志, 其中 CF 反映压缩 BCD 码相加减的进借位状态。

【例2.25】压缩BCD码的加法运算。

```txt
mov al, 68h ; al=68h，表示压缩bcd码68
```

```txt
mov bl, 28h ; bl=28h，表示压缩bcd码28  
add al, bl ; 二进制数加法：al=68h+28h=90h  
dae ; 十进制调整：al=96h  
; 实现压缩bcd码加法：  $68 + 28 = 96$
```

再如，压缩BCD码的减法运算：

```txt
mov al, 68h ; al=68h，表示压缩bcd码68  
mov bl, 28h ; bl=28h，表示压缩bcd码28  
sub al, bl ;二进制数减法：al=68h-28h=40h  
das ;十进制调整：al=40h  
;实现压缩bcd码减法：68-28=40
```

【例2.26】已知  $\mathrm{AX} = 1234\mathrm{H}$  ，  $\mathrm{BX} = 4612\mathrm{H}$  ，计算1234-4612的差。

```txt
sub al, bl das xchg al, ah sbb al, bh das xchg al, ah ; ax=6622h, cf=1
```

把  $1234\mathrm{H}$  和  $4612\mathrm{H}$  认为是无符号十进制数，则利用借位 1，则  $1234 - 4612 = 6622$  ，结果正确。如果认为是有符号十进制数，则  $1234 - 4612 = -(4612 - 1234) = -3378$  ，结果仍然正确吗？正确，因为用补码表示-3378 就是 6622（ $0000 - 6622 = 9999 - 6622 + 1$ ）。实际上，位数为  $n$  的十进制整数  $d$  ，其补码定义为： $10^{n} - d$ 。

# 2.非压缩BCD码调整指令

非压缩 BCD 码用 8 个二进制位表示一个十进制位, 实际上只是用低 4 个二进制位表示一个十进制位  $0 \sim 9$ , 高 4 位任意, 但通常默认为 0 。 $0 \sim 9$  的 ASCII 编码是  $30 \mathrm{H} \sim 39 \mathrm{H}$ , 所以  $0 \sim 9$  的 ASCII 编码 (高 4 位变为 0) 就可以认为是非压缩 BCD 码。

对非压缩 BCD 码, 8086 提供 AAA、AAS、AAM 和 AAD 四条指令, 分别用于对二进制数加、减、乘、除指令的结果进行调整, 以得到非压缩 BCD 码表示的十进制数结果。由于只要在调整后的结果中加上  $30 \mathrm{H}$  就成为 ASCII 编码, 所以这组指令实际上也是针对 ASCII 编码的调整指令的。

（1）加法的非压缩BCD码调整指令AAA

```txt
aaa ; al←将al中的加和调整为非压缩bcd码; ah←ah+调整产生的进位
```

该指令跟在以 AL 为目的操作数的 ADD 或 ADC 指令之后, 对 AL 进行非压缩 BCD 码调整。如果调整中产生了进位, 则将进位 1 加到 AH 中, 同时  $\mathrm{{CF}} = \mathrm{{AF}} = 1$  ,否则  $\mathrm{{CF}} = \mathrm{{AF}} = 0$  。AAA 指令对其他标志无定义。另外, 该指令使 AL 的高 4 位清 0 。

【例2.27a】 非压缩BCD码的加法运算。

```txt
mov ax, 0608h ; ax=0608h，表示非压缩bcd码68  
mov bl, 09h ; bl=09h，表示非压缩bcd码9  
add al, bl ; 二进制数加法：al=08h+09h=11h  
aaa ; 十进制调整：ax=0707h  
; 实现非压缩bcd码加法：  $68 + 9 = 77$
```

（2）减法的非压缩BCD码调整指令AAS

aas

；al←将al中的减差调整为非压缩BCD码，ah←ah-调整产生的借位

该指令跟在以 AL 为目的操作数的 SUB 或 SBB 指令之后, 对 AL 进行非压缩 BCD 码调整。如果调整中产生了借位, 则将 AH 减去借位 1 , 同时  $\mathrm{{CF}} = \mathrm{{AF}} = 1$  ,否则  $\mathrm{{CF}} = \mathrm{{AF}} = 0$  。AAS 指令对其他标志无定义。另外, 该指令使 AL 的高 4 位清 0 。

【例2.27b】非压缩BCD码的减法运算。

```txt
mov ax, 0608h ; ax=0608h，表示非压缩BCD码68  
mov bl, 09h ; bl=09h，表示非压缩BCD码9  
sub al, bl ; 二进制数减法：al=08h-09h=ffh  
aas ; 十进制调整：ax=0509h  
; 实现非压缩BCD码减法：68-9=59
```

(3) 乘法的非压缩 BCD 码调整指令 AAM

aam

; ax←将ax中的乘积调整为非压缩BCD码

该指令跟在以 AX 为目的操作数的 MUL 指令后, 对 AX 进行非压缩 BCD 码调整。利用 MUL 相乘的两个非压缩 BCD 码的高 4 位必须为 0 。AAM 指令根据结果设置 SF、ZF 和 PF,但 OF、CF 和 AF 无定义。

【例2.27c】 非压缩BCD码的乘法运算。

```txt
mov ax, 0608h ; ax=0608h，表示非压缩 BCD 码 68  
mov bl, 09h ; bl=09h，表示非压缩 BCD 码 9  
mul bl ; 二进制数乘法：ax=08h×09h=0048h  
aam ; 十进制调整：ax=0702h，实现非压缩 BCD 码乘法： $8 \times 9 = 72$
```

(4) 除法的非压缩 BCD 码调整指令 AAD

aad

; ax←将ax中的非压缩BCD码扩展成二进制数，即：al-10xah+al，ah-0

AAD 调整指令与其他调整指令的应用情况不同, 是先将存放在 AX 寄存器中的两位非缩 BCD 码数进行调整, 再用 DIV 指令除以一个非压缩 BCD 码数, 这样得到非压缩 BCD 码的除法结果。其中, 要求 AL、AH 和除数的高 4 位为 0 。AAD 指令根据结果设置 SF、ZF、PF, 但 OF、CF 和 AF 无定义。

【例2.27d】 非压缩BCD码的除法运算。

```txt
mov ax, 0608h ; ax=0608h，表示非压缩BCD码68  
mov bl, 09h ; bl=09h，表示非压缩BCD码9  
aad ;二进制扩展：ax=68=0044h  
div bl ;除法运算：商al=07h，余数ah=05h;实现非压缩BCD码除法：  $68 = 7\times 9 + 5$
```

十进制调整指令只针对要求 BCD 码运算的应用, 并且要与对应的运算指令配合。表 2 综合了 8086 算术运算的各种情况。

表 2-2 8086 支持的 4 种数据类型的算术运算  

<table><tr><td></td><td>加法</td><td>减法</td><td>乘法</td><td>除法</td></tr><tr><td>无符号二进制数</td><td>ADD, ADC</td><td>SUB, SBB</td><td>MUL</td><td>DIV</td></tr><tr><td>有符号二进制数</td><td>ADD, ADC</td><td>SUB, SBB</td><td>IMUL</td><td>IDIV</td></tr><tr><td>压缩 BCD 码</td><td>ADD, ADC, DAA</td><td>SUB, SBB, DAS</td><td></td><td></td></tr><tr><td>非压缩 BCD 码</td><td>ADD, ADC, AAA</td><td>SUB, SBB, AAS</td><td>MUL, AAM</td><td>AAD, DIV</td></tr></table>

# 2.3 位操作类指令

位操作类指令对二进制数的各位进行操作，包括逻辑运算指令和移位指令。

# 2.3.1 逻辑运算指令

逻辑运算指令用来对字或字节按位进行逻辑运算，包括5条指令：逻辑与AND、逻辑或OR、逻辑非NOT、逻辑异或XOR和测试TEST。

# 1. 逻辑与指令 AND

AND指令对两个操作数执行按位的逻辑与运算，即只有相“与”的两位都是1结果才是1，否则结果为0。逻辑与的结果送目的操作数。

```txt
AND DEST, SRC ; DEST←DEST ∧ SRC (符号 ∧ 表示逻辑与)
```

AND 指令及后面介绍的其他双操作数逻辑指令 OR、XOR 和 TEST 指令，所支持的操作数组合同加减法指令一样。

```txt
逻辑运算助记符 reg,imm/reg/mem reg<reg逻辑运算imm/reg/mem 逻辑运算助记符 mem,imm/reg mem<mem逻辑运算imm/reg
```

在这两个操作数中，源操作数可以是任意寻址方式，目的操作数只能是立即数外的其他寻址方式，并且两个操作数不能同时为存储器寻址方式。

所有双操作数的逻辑指令均设置  $\mathrm{CF = OF = 0}$  ，根据结果设置SF、ZF和PF状态，而对AF未定义。

【例2.28】 逻辑与运算。

```txt
mov al, 45h  
and al, 31h
```

AND 指令可用于复位一些位, 但不影响其他位。这时只需将要置 0 的位同 0 相 “与”, 而维持不变的位同 1 相 “与” 就可以了。

再如，将 BL 中  $\mathbf{D}_0$  和  $\mathbf{D}_3$  清 0，其余位不变，则

```txt
and bl, 11110110b
```

# 2. 逻辑或指令 OR

OR 指令对两个操作数执行按位的逻辑或运算, 即只要相 “或” 的两位中有一位是 1 , 结果就是 1 , 否则结果为 0 。逻辑或的结果送目的操作数。所支持的操作数如 AND 指令。

```txt
or dest, src ;dest<-destVsrc（符号  $\vee$  表示逻辑或）
```

【例2.29】 逻辑或运算。

```txt
mov al, 45h  
or al, 31h
```

OR指令可用于置位某些位，而不影响其他位。这时只需将要置1的位同1相“或”，维持不变的位同0相“或”即可。

再如，将BL中  $\mathbf{D}_0$  和  $\mathbf{D}_3$  置1，其余位不变，则

```txt
or bl,00001001b
```

# 3. 逻辑异或指令 XOR

XOR指令对两个操作数执行按位的逻辑异或运算，即相“异或”的两位不相同时，结果

就是 1 。否则结果为 0 , 其结果送目的操作数。所支持的操作数如 AND 指令。

;dest  $\leftarrow$  dest  $①$  src（符号  $\oplus$  表示逻辑异或）

【例2.30】逻辑异或运算。

mov al, 45h

xor al, 31h

; AL=74H, CF=OF=0, SF=0, ZF=0, PF=1

XOR 可用于求反某些位，而不影响其他位。要求求反的位同 1 相“异或”，维持不变的位同相“异或”。

再如，将BL中  $\mathbf{D}_0$  和  $\mathbf{D}_3$  求反，其余位不变，则

xor bl,00001001b

XOR指令经常给寄存器清0，同时使CF清0。例如：

xor ax,ax

；  $AX = 0$  ，  $CF = OF = 0$  ，  $SF = 0$  ，  $ZF = 1$  ，  $PF = 1$

# 4. 逻辑非指令 NOT

NOT指令对操作数按位取反，即原来为0的位变成1，原来为1的位变成0。NOT指令是一个单操作数指令，该操作数可以是立即数外的任何寻址方式。注意，NOT指令不影响标志位。

not reg/mem

; reg/mem← ~reg/mem (符号~表示逻辑反)

【例2.31】逻辑非运算。

mov al, 45h

not al

；AL  $=$  0BAH，标志不变

# 5. 测试指令TEST

TEST 指令对两个操作数执行按位的逻辑与运算，但结果不回到目的操作数。TEST 指令执行的操作与 AND 指令相同，但不保存执行结果，只根据结果来设置状态标志。

test dest, src

; dest ∧ src（符号 ∧ 表示逻辑与）

TEST指令通常用于检测一些条件是否满足又不希望改变原操作数的情况。这条指令之后一般是条件转移指令，目的是利用测试条件转向不同的程序段。

【例2.32】TEST指令用于测试某一（几）位是否（同时）为0或为1。

test al, 01h

; 测试 a1 的最低位 d0

jnz there

；标志  $zf = 0$  ，即  $\mathrm{d}\theta = 1$  ，则程序转移到there

…

；否则  $zf = 1$  ，即  $\mathsf{d}\theta = \theta$  ，顺序执行

there:

# 2.3.2 移位指令

移位（Shift）指令分成逻辑（Logical）移位指令和算术（Arithmetic）移位指令，分别具有左移（Left）或右移（Right）操作，如图2-3所示。

shl reg/mem, 1/cl ; 逻辑左移: reg/mem 左移 1/c1 位, 最低位补 0

j最高位进入cf

shr reg/mem, 1/cl ; 逻辑右移: reg/mem 右移 1/cl 位, 最高位补 0 , 最低位进入 cf

sal reg/mem, 1/c1 ; 算术左移，功能与 shl 相同

sar reg/mem, 1/cl ; 算术右移: reg/mem 右移 1/cl 位, 最高位不变, 最低位进入 cf

4条（实际为3条）移位指令的目的操作数可以是寄存器或存储单元。后一个操作数表示移位位数，该操作数为1，表示移动1位；当移位位数大于1时，则用CL寄存器值表示，该操作数表达为CL。

移位指令按照移入的位设置进位标志 CF，根据移位后的结果影响 SF、ZF、PF，对 AF 没有定义。如果进行 1 位移动，则按照操作数的最高符号位是否改变，相应设置溢出标志 OF：如果移位前的操作数最高位与移位后操作数的最高位不同（有变化），则  $\mathrm{OF} = 1$ ，否则  $\mathrm{OF} = 0$ 。当移位次数大于 1 时，OF 不确定。

【例2.33】 移位指令的功能。

```txt
mov cl,4 MSB LSB mov al,0f0h ；al=f0h shl al,1 图2-3移位指令；al=e0h，cf=1，sf=1，zf=0，pf=0，of=0shr al,1 ;al=70h，cf=0，sf=0，zf=0，pf=0，of=1 sar al,1 ;al=38h，cf=0，sf=0，zf=0，pf=0，of=0 sar al,cl ;al=03h，cf=1，sf=0，zf=0，pf=1
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/e149b115722f0b499f5fc0e36d5eff643706366fa6cc84ce3a4c356cfd1efa18.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/431ea06be8474966535e91db48c57572be82c1c9a506b4deb0cfb893f20d8076.jpg)  
图2-3 移位指令

逻辑左移和算术左移实际上是同一条指令的两种助记符形式，两者完全相同，建议采用SHL。在指令系统中还有类似的情况。采用多个助记符只是为了方便使用，增加可读性。

逻辑左移指令SHL执行一次移位，相当于无符号数乘2；逻辑右移指令SHR执行1位移位，相当于无符号数除以2，商在目的操作数中，余数由CF标志反映。

算术右移指令 SAR 执行 1 位移位，相当于有符号数除以 2。注意，当操作数为负（最高位为 1）且最低位有 1 移出时，SAR 指令产生的结果与等效的 IDIV 指令的结果不同。例如，-5 (FBH) 经 SAR 右移 1 位等于 -3 (FDH)，而 IDIV 指令执行  $-5 \div 2$  的结果为 -2。

【例2.34】利用移位指令计算  $\mathrm{DX} \gets 3 \times \mathrm{AX} + 7 \times \mathrm{BX}$ , 假设为无符号数运算, 无进位。

```txt
mov si, ax  
sh1 si, 1 ; si←2×ax  
add si, ax ; si←3×ax  
mov dx, bx  
mov cl, 03h  
sh1 dx, cl ; dx←-8×bx  
sub dx, bx ; dx←-7×bx  
add dx, si ; dx←7×bx+3×ax
```

# 2.3.3 循环移位指令

循环（Rotate）移位指令类似移位指令，但要从一端移出的位返回到另一端形成循环，分为不带进位循环移位和带进位循环移位，分别具有左移或右移操作，如图2-4所示。

```txt
rol reg/mem, 1/cl ;不带进位循环左移  
ror reg/mem, 1/cl ;不带进位循环右移  
rcl reg/mem, 1/cl ;带进位循环左移  
rcr reg/mem, 1/cl ;带进位循环右移
```

前两条指令不将进位 CF 纳入循环位中。后两条指令将进位标志 CF 纳入循环位中，与操作数一起构成的 9 位或 17 位二进制数一起移位。

循环移位指令的操作数形式与移位指令相同，如果仅移动1次，可以用1表示；如果移位多次，则需用CL寄存器表示移位次数。循环移位指令按照指令功能设置进位标志CF，不影响

SF、ZF、PF、AF标志。对OF标志的影响，循环移位指令与前面介绍的移位指令一样。

【例2.35】将DX.AX中的32位数值左移1位。

SHL AX, 1

RCL DX,1

【例2.36】把AL最低位送BL最低位，但保持AL不变。

ROR BL,1

ROR AL,1

RCL BL, 1

ROL AL,1

利用移位或循环移位指令可以方便地实现 BCD 码转换。

【例 2.37】AH 和 AL 分别存放着非压缩 BCD 码的两位，将其合并成为一个压缩 BCD 码存入 AL。

MOV CL,4

ROL AH,CL ；也可以用SHL AH,CL

ADD AL, AH ；也可以用OR AL, AH

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/37aef390c9d64db0608e261a3d995b41c336388c3f517660116985ec05e8f1b9.jpg)  
(a) 左循环移位ROL

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/24523a6f87312d600d304f0aadbeca03127afa62805d96a9b4368c51da75213d.jpg)  
(b) 右循环移位ROR

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/8d1129b5d5689f3760126b66dfd45879c02657fc88f81c96a4bce22a7292ebd8.jpg)  
(c) 带进位左循环移位 RCL

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/ee27ce1f33676e3d32c71afd9af682e1ee4be230fe715c5ef511fa59db328b83.jpg)  
(d) 带进位右循环移位RCR  
图2-4 循环移位指令

# 2.4 控制转移类指令

在Intel 8086中，程序的执行序列是由代码段寄存器CS和指令指针IP确定的。CS包含前指令所在代码段的段地址，IP则是要执行的下一条指令的偏移地址。程序的执行一般依指序列顺序执行，但有时需要改变程序的流程。控制转移类指令通过修改CS和IP寄存器的值改变程序的执行顺序，包括5组指令：无条件转移指令、有条件转移指令、循环指令、子程指令和中断指令。本节介绍指令功能本身，第4章中介绍指令应用。

一条指令执行后，需要确定下一条执行的指令，也就是确定下条执行指令的地址，这被为指令寻址。程序顺序执行，下一条指令在存储器中紧邻着前一条指令，指令指针寄存器自动增量，这就是指令的顺序寻址。程序转移则控制程序流程从当前指令跳转到目的地指令实现程序分支、循环或调用等结构，这就是指令的跳转寻址。目的地指令所在的存储器地址为目的地址、目标地址或转移地址，指令寻址实际上主要是指跳转寻址，也称为目标地址寻址。3086处理器设计有相对、直接和间接3种指明目标地址的方式，其基本含义类似于对应的存储器数据寻址方式。图2-5汇总了各种寻址方式（含1.6节的数据寻址）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/a91b73adefad13b05aa53b978bf684444d7c55cd7979e4dbc61d772481814b27.jpg)  
图2-5 寻址方式

控制转移类指令采用的指令寻址方式如下。

• 相对寻址方式: 指令代码中提供目的地址相对于当前 IP 的位移量, 转移到的目的地址 (转移后的 IP 值) 就是当前 IP 值加上位移量 (如图 2-6(a)所示)。当向地址增大方向转移时, 位移量为正; 向地址减小方向转移时, 位移量为负。  
- 直接寻址方式：指令代码中提供目的地的逻辑地址（如图 2-6(b)所示），转移后的 CS 和 IP 值直接来自指令操作码后的目的地址操作数。  
间接寻址方式：指令代码中指示寄存器或存储单元，目的地址从寄存器或存储单元中间接获得，分别被称为指令寻址的寄存器间接寻址（如图2-6(c)所示）和存储器间接寻址（如图2-6(d)所示）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/41a563637c5438dc3396f6812de22ce77ce1fb2047046a006dcc7ca9630ef273.jpg)  
(a) 相对寻址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/49458adff87e75da42665f4054271b96d70c98d0e27d34b5917df7acf6196194.jpg)  
(b) 直接寻址  
图2-6 指令寻址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/a2e159e0924bd9ff429b20ffb3622711b034d1014fa9b38bcd09a7ddedbc0149.jpg)  
(c) 寄存器间接寻址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/1b67cb68bfcfea5590cf9aaf38ace48f51aff0c133a7045217584de0f364a8f4.jpg)  
(d) 存储器间接寻址

# 2.4.1 无条件转移指令

无条件转移就是无任何先决条件就能使程序改变执行顺序。处理器只要执行无条件转移指令JMP，就使程序转到指定的目标地址处，从目标地址处开始执行那里的指令。

JMP指令可以将程序转移到1MB存储空间的任何位置。根据跳转的距离，JMP指令分为段内转移和段间转移。

段内转移是指在当前代码段 64 KB 范围内转移，因此不需要更改 CS 段地址，只要改变 IP 偏移地址。如果转移范围可以用一个 8 位数  $(-128 \sim +127$  之间的位移量）表达，则可以形成“短转移”（short jump）；如果地址位移用一个 16 位数表达，则形成“近转移”（near jump）， $\pm 32$  KB 范围内。

段间转移是指从当前代码段跳转到另一个代码段, 此时需要更改 CS 段地址和 IP 偏移地址,这种转移也称为 “远转移” (far jump)。转移的目标地址必须用一个 32 位数表达, 叫做 32 位远指针, 它就是逻辑地址。

由此可见，JMP指令根据目标地址不同的提供方法和内容，可以分成4种格式。

# 1. 段内转移，相对寻址

指令代码中的位移量是指紧接着JMP指令后的那条指令的偏移地址到目标指令的偏移地址的地址位移。当向地址增大方向转移时，位移量为正；向地址减小方向转移时，位移量为负。通常，汇编程序能够根据位移量大小自动形成短转移或近转移指令。同时，汇编程序也提供近转移near ptr操作符。

jmp label

;ip←ip+位移量

# 2. 段内转移，间接寻址

jmp r16/m16

ip←r16/m16

这种形式的 JMP 指令, 将一个 16 位寄存器或主存单元内容送入 IP 寄存器, 作为新的指令指针, 但不修改 CS 寄存器的内容。例如:

```txt
jmp ax ;ip--ax  
jmp word ptr[2000h] ;ip-[2000h]
```

# 3. 段间转移，直接寻址

段间直接转移指令是将标号所在段的段地址作为新的CS值，标号在该段内的偏移地址作为新的IP值。这样，程序就能跳转到新的代码段执行。

```txt
jmp far ptr label ;ip<-label的偏移地址，cs<-label的段地址
```

一个标号在同一个段内还是在另一个段中，汇编程序能够自动识别。如果要强制一个段间远转移，则可以用汇编伪指令 far ptr。

# 4. 段间转移，间接寻址

```txt
jmp far ptr mem;ip←[mem],cs←[mem+2]
```

段间间接转移指令用一个双字存储单元表示要跳转的目标地址。这个目标地址存放在主存中连续的两个字单元中，其中低位字送IP寄存器，高位字送CS寄存器。例如：

```txt
mov word ptr[bx], 0  
mov word ptr[bx+2], 1500h  
jmp far ptr[bx]
```

```txt
; 转移到 1500h: 0
```

# 2.4.2 条件转移指令

条件转移指令JCC根据指定的条件确定程序是否发生转移。如果满足条件，则程序转移到目标地址去执行程序；如果不满足条件，则程序将顺序执行下一条指令（如图2-7所示）。其通用格式为：

```txt
jcc label
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/6066b0ece82576ac2bec084cc3215188824c20a276b7dd0c159a27640bbad68b.jpg)  
图2-7 条件转移指令JCC的执行流程

```txt
；条件满足，发生转移：ip←ip+8位位移量；否则，顺序执行：ip←ip+2
```

其中，label表示目标地址（8位位移量）。因为JCC指令为2字节，所以顺序执行就是当前指令偏移指针IP加2。条件转移指令跳转的目标地址只能用前面介绍的段内相对短跳转，即目标地址只能在同一段内，且在当前IP地址-128～+127个单元的范围内。

与其他控制转移指令一样，条件转移指令不影响标志，但它要利用标志。条件转移指令JCC中的CC表示利用标志判断的条件，有16种，如表2-3所示。表中

斜线分隔了同一条指令的多个助记符形式，根据判定的标志位的不同分为3种情况。

# 1. 判断单个标志位状态

这组指令单独判断 5 个状态标志之一, 根据某一个状态标志是 0 或 1 决定是否跳转。

(1) JZ/JE 和 JNZ/JNE 利用零标志 ZF, 判断结果是否为零 (或相等)

【例2.38】如果AL最高位为0，则设置  $\mathrm{AH} = 0$ ；如果AL最高位为1，则设置  $\mathrm{AH} = \mathrm{FF}$ （也就是用一段程序实现符号扩展指令CBW的功能）。

使用“不等于零转移JNZ指令”：

```txt
test al, 80h
```

```txt
；测试最高位
```

表 2-3 条件转移指令中的条件  

<table><tr><td>助记符</td><td>标志位</td><td>英文含义</td><td>中文说明</td></tr><tr><td>JZ/JE</td><td>ZF=1</td><td>Jump if Zero/Equal</td><td>等于零/相等转移</td></tr><tr><td>JNZ/JNE</td><td>ZF=0</td><td>Jump if Not Zero/NotEqual</td><td>不等于零/不相等转移</td></tr><tr><td>JS</td><td>SF=1</td><td>Jump if Sign</td><td>符号为负转移</td></tr><tr><td>JNS</td><td>SF=0</td><td>Jump if Not Sign</td><td>符号为正转移</td></tr><tr><td>JP/JPE</td><td>PF=1</td><td>Jump if Parity/Parity Even</td><td>“1”的个数为偶转移</td></tr><tr><td>JNP/JPO</td><td>PF=0</td><td>Jump if Not Parity/Parity Odd</td><td>“1”的个数为奇转移</td></tr><tr><td>JO</td><td>OF=1</td><td>Jump if Overflow</td><td>溢出转移</td></tr><tr><td>JNO</td><td>OF=0</td><td>Jump if Not Overflow</td><td>无溢出转移</td></tr><tr><td>JC/JB/JNAE</td><td>CF=1</td><td>Jump if Carry/ Below/Not Above or Equal</td><td>进位/低于/不高于等于转移</td></tr><tr><td>JNC/JNB/JAE</td><td>CF=0</td><td>Jump if Not Carry/Not Below/Above or Equal</td><td>无进位/不低于/高于等于转移</td></tr><tr><td>JBE/JNA</td><td>CF=1或ZF=1</td><td>Jump if Below or Equal/Not Above</td><td>低于等于/不高于转移</td></tr><tr><td>JNBE/JA</td><td>CF=0且ZF=0</td><td>Jump if Not Below or Equal/Above</td><td>不低于等于/高于转移</td></tr><tr><td>JL/JNGE</td><td>SF≠OF</td><td>Jump if Less/Not Greater or Equal</td><td>小于/不大于等于转移</td></tr><tr><td>JNL/JGE</td><td>SF=OF</td><td>Jump if Not Less/Greater or Equal</td><td>不小于/大于等于转移</td></tr><tr><td>JLE/JNG</td><td>SF≠OF或ZF=1</td><td>Jump if Less or Equal/Not Greater</td><td>小于等于/不大于转移</td></tr><tr><td>JNLE/JG</td><td>SF=OF且ZF=0</td><td>Jump if Not Less or Equal/Greater</td><td>不小于等于/大于转移</td></tr></table>

```txt
jz next0 ；最高位为0（zf=1），转移到next0 mov ah,offh ；最高位为1，顺序执行 jmp done ；无条件转向done   
next0: mov ah,0   
done:
```

上述程序段也可以用“等于零转移JZ指令”：

```txt
test al, 80h ;测试最高位  
jnz next1 ;最高位为1（zf=0），转移到next1  
mov ah, 0h ;最高位为0，顺序执行  
jmp done ;无条件转向done  
next1: mov ah, 0ffh  
done:
```

（2）JS和JNS利用符号标志SF，判断结果是正是负

【例2.39】计算  $\left|X - Y\right|$ ,  $X$  和  $Y$  为存放于 X 单元和 Y 单元的 16 位操作数, 结果存入 RESULT 中。

```txt
mov ax, x  
sub ax, y  
jns nonneg  
neg ax  
nonneg: mov result, ax  
; 保存结果
```

(3) JO 和 JNO 利用溢出标志 OF, 判断结果是否产生溢出

【例2.40】计算  $X - Y$  ，  $X$  和  $Y$  分别为存放于  $\mathbf{X}$  单元和  $\mathrm{Y}$  单元中的16位有符号操作数。若溢出，则转移到OVERFLOW处理。

```txt
mov ax, x  
sub ax, y  
jo overflow  
... ;没有溢出，结果正确  
overflow: ... ;溢出处理
```

(4) JP/JPE 和 JNP/JPO 利用奇偶标志 PF, 判断结果中 “1” 的个数是偶数还是奇数

数据通信为了可靠常要进行校验。最常用的校验方法是奇偶校验, 如把字符的 ASCII 码的最高位用做校验位, 使包括校验位在内的字符中为 “1” 的个数恒为奇数 (这就是奇校验), 或恒为偶数 (偶校验)。若采用奇校验, 在字符的 ASCII 码中为 “1” 的个数已为奇数时, 则令其最高位为 “0”, 否则令最高位为 “1”。

【例2.41】设字符的ASCII编码在AL寄存器中，将字符加上奇校验位。

```txt
and al, 7fh ;最高位置  $"0"$  ，同时判断  $"1"$  的个数 jnp next ;个数已为奇数，则转向next or al,80h ;否则，最高位置  $"1"$    
next:
```

(5) JC/JB/JNAE 和 JNC/JNB/JAE，利用进位标志 CF，判断结果是否进位或借位CF标志是比较常用的一个标志，所以程序中经常利用这个条件转移指令。

【例2.42】 记录BX中“1”的个数。

```asm
xor al, al
again: test bx, 0ffffh ; 等价于 cmp bx, 0
je next
shl bx,1 ; 还可以用哪个（循环）移位指令实现?
jnc again
inc al
jmp again
next: ... ; al保存1的个数
```

这个指令除能判断 CF 是 0 或 1 外, 还能判断两个无符号数的大小, 见下面的介绍。

# 2. 用于比较无符号数高低

为了区别有符号数的大小, 无符号数的大小用高 (Above)、低 (Below) 表示, 需要利用 CF 确定高低、利用 ZF 标志确定相等 (Equal)。两数的高低分成 4 种关系: 低于 (不高于等于) 不低于 (高于等于)、低于等于 (不高于)、不低于等于 (高于); 也就分别对应 4 条指令: J (JNAE)、JNB (JAE)、JBE (JNA)、JNBE (JA)。

【例 2.43】比较无符号数大小, 将较大的存入 RESULT 主存单元。

```txt
cmp ax, bx ;比较ax和bx jnb next ;若  $a\mathbf{x}\geqslant \mathbf{b}\mathbf{x}$  ，转移到next xchg ax, bx ；若  $a\mathbf{x} <   b\mathbf{x}$  ，交换 next: mov result, ax
```

# 3. 用于比较有符号数大小

判断有符号数的大（Greater）、小（Less），需要组合OF、SF标志，并利用ZF标志确定相等与否。两数的大小分成4种关系：小于（不大于等于）、不小于（大于或等于）、小于等于（不大于）、不小于等于（大于）；也就分别对应4条指令：JL（JNGE）、JNL（JGE）、JLE（JNG）和JNLE（JG）。

【例 2.44】比较有符号数大小, 将较大的存入 RESULT 主存单元。

```latex
cmp ax, bx 比较ax和bx  
jnl next 若  $\mathbf{a}\mathbf{x}\geqslant \mathbf{b}\mathbf{x}$  ，转移到next  
xchg ax, bx 若  $\mathbf{a}\mathbf{x} <   \mathbf{b}\mathbf{x}$  ，交换  
next: mov result, ax
```

由上可见, 条件转移指令之前常有 CMP、TEST、加减运算、逻辑运算等影响标志的指令, 利用这些指令执行后的标志或其组合状态形成条件。

# 2.4.3 循环指令

循环是一种特殊的转移流程，当满足（或不满足）某条件时，反复执行一系列操作，直到不满足（或满足）条件为止。循环流程的条件一般是循环计数，在程序中用循环计数来控制循环次数。循环流程可以用前面条件转移指令来实现。8086 还设计了专门的循环指令用于控制循环流程，其格式为：

```txt
jcxz label ;  $\mathsf{CX} = 0$  ，则转移；否则顺序执行 loop label ;  $\mathsf{CX}\leftarrow \mathsf{CX} - 1$  ；若  $cx\neq 0$  ，循环：ip-ip+位移量，否则顺序执行 loopz/loope label ;  $\mathsf{CX}\leftarrow \mathsf{CX} - 1$  ；若  $cx\neq 0$  且  $zf = 1$  ，循环：ip-ip+位移量 ;否则，顺序执行 loopnz/loopne label ;  $\mathsf{CX}\leftarrow \mathsf{CX} - 1$  ；若  $cx\neq 0$  且  $zf = 0$  ，循环：ip-ip+位移量 ;否则，顺序执行
```

JCXZ指令在CX寄存器为0时，退出循环。

LOOP指令首先将计数值CX减1，然后判断计数值CX是否为0。CX不为0，则继续执行循环体内的指令；CX为0，表示循环结束，于是程序退出循环，顺序执行后面的指令。LOOPZ和LOOPNZ指令中要求同时ZF为1或0才进行循环，用于判断结果是否为0或相等，以便提前结束循环。

循环指令中的操作数 label 采用相对寻址方式，表示循环的目标地址是一个 8 位位移量。另外，循环指令不影响标志。

【例2.45】记录附加段中STRING字符串包含空格字符的个数。假设字符串长度为COUNT字节，结果存入RESULT单元。

```txt
mov cx, count ；设置循环次数  
mov si, offset string  
xor bx, bx ；bx清0，用于记录空格数  
jcxz done ；如果长度为0，则退出  
mov al, 20h  
again: cmp al, es:[si]  
jnz next ；zf=0，不是空格，转移  
inc bx ；zf=1，有空格，空格个数加1  
next: inc si  
loop again  
；字符个数减1，不为0继续循环  
done: mov result, bx ；保存结果
```

使用LOOP指令实现循环有三个要点：在CX中存放循环次数，LOOP指令的标号一般应在前面，要执行的循环程序段应写在标号和LOOP指令之前。为了防止CX初值为0导致循环次数出错，可以在循环之前使用JCXZ指令进行判断，典型的应用流程如图2-8所示。

另外，循环指令 LOOP 等效于如下两条指令：

```txt
dec cx ;计数器cx减1  
jnz again ;然后判断cx是否为0
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/e12bfa90ef88247d54fc74d9ac0f09d30d0a9a529e2a809c00ad9d17c174bc45.jpg)  
图2-8 循环指令的典型应用

为了顺序访问字符串中的每个字符, 本例程序使用 SI 寄存器间接寻址。首先, 将 SI 等于字符串首地址 (或末地址), 这样[SI]指向首个 (或最后一个) 字符; 然后通过增量 (或减量) SI, 就可以指向后 (或前) 一个字符。本例程序也可以采用寄存器相对寻址访问字符串, 需要将 SI 设置为 0 , 表示首个字符, 然后使用 STRING[SI]相对寻址。

一般来说，当需要有规律地访问数组元素时，必须使用寄存器间接寻址或者寄存器相对寻址。当算法比较复杂，或者访问两维数组时，可能要使用基址变址或者相对基址变址寻址方式

# 2.4.4 子程序指令

程序中有些部分可能要实现相同的功能，只是参数不一样，而且这些功能需要经常用到。这时用子程序实现这个功能是很合适的。使用子程序可以使程序的结构更清楚，程序的维护也更方便，也有利于大程序开发时多个程序员分工合作。

子程序通常是与主程序分开的、完成特定功能的一段程序。当主程序（调用程序）需要执行这个功能时，就可以调用该子程序（被调用程序），于是程序转移到这个子程序的起始处执行。当运行完子程序后，再返回调用它的主程序。子程序由主程序执行子程序调用指令CALL来调用；而子程序执行完后用子程序返回指令RET，返回主程序继续执行。CALL和RET指令均不影响标志位。

# 1.子程序调用指令CALL

CALL 指令用在主程序中实现子程序的调用。子程序和主程序可以在同一个代码段内，也可以在不同段内。因而，类似无条件转移 JMP 指令，子程序调用 CALL 指令可以分为段内用（近调用）和段间调用（远调用）；同时，CALL 目标地址也可以采用相对寻址、直接寻或间接寻址方式。但是，子程序执行结束是要返回的，所以 CALL 指令不仅要同 JMP 指令样改变 CS:IP 以实现转移，还要保留下一条要执行指令的地址，以便返回时重新获取它。保持 CS:IP 值的方法是压入堆栈，获取 CS:IP 值的方法是弹出堆栈（如图 2-9 所示）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/5c37cddf89d18c14e1c16bad234f74598bd126aa05535d912f2c42941c873007.jpg)  
图2-9 调用和返回指令的功能

# CALL指令的4种格式如下：

```txt
call label ;段内调用，相对寻址：sp←sp-2,ss：[sp]←ip ip←ip+16位位移量   
call r16/m16 ;段内调用，间接寻址：sp←sp-2,ss：[sp]←ip，ip←r16/口   
call far ptr label ;段间调用，直接寻址：sp←sp-2,ss：[sp]←cs sp←sp-2,ss：[sp]←ip ip←label偏移地址，cs←label段地址   
call far ptr mem ;段间调用，间接寻址：sp←sp-2,ss：[sp]←cs，sp←sp-2 ss：[sp]←ip，ip←[mem],cs←[mem+2]
```

根据过程伪指令（见第4章），汇编程序可以自动确定段内还是段间调用，也可以采用near ptr或far ptr操作符强制成为近调用或远调用。其过程同段内或段间转移一样。

# 2. 子程序返回指令 RET

子程序执行完后，应返回主程序中继续执行，该功能由 RET 指令完成。要回到主程序，只要获得离开主程序时，由 CALL 指令保存于堆栈的指令地址即可。根据子程序与主程序是否同处于一个段内，返回指令分为段内返回和段间返回。

RET指令的4种格式如下：

```txt
ret ；无参数段内返回：ip←ss:[sp]，sp←sp+2  
ret i16 ；有参数段内返回：ip←ss:[sp]，sp←sp+2，sp←sp+i16  
ret ；无参数段间返回：ip←ss:[sp]，sp←sp+2  
ret i16 ；cs←ss:[sp]，sp←sp+2  
ret ；有参数段间返回：ip←ss:[sp]，sp←sp+2  
; cs←ss:[sp]，sp←sp+2，sp←sp+i16
```

尽管段内返回和段间返回具有相同的汇编助记符，但汇编程序会自动产生不同的指令代码，也可以分别采用 RETN 和 RETF 表示段内和段间返回。返回指令还可以带有一个立即数 I16，则堆栈指针 SP 将增加，即  $\mathrm{SP} \gets \mathrm{SP} + \mathrm{I16}$  。这个特点使得程序可以方便地废除若干执行 CALL 指令以前入栈的参数。

【例2.46】利用子程序完成将AL低4位中的1位十六进制数转换成对应的ASCII码。

```txt
;主程序  
mov al,0fh ;提供参数al  
call htoasc ;调用子程序  
... ;子程序  
htoasc: and al,0fh ;只取al的低4位  
or al,30h ;al高4位变成3  
cmp al,39h ;是  $0\sim 9$  ，还是a~f  
jbe htoend  
add al,7 ;是  $\mathsf{a}\sim \mathsf{f}$  ，其ascii还要加上7（见表1.4）  
htoend: ret ;子程序返回
```

4 位二进制数对应一位十六进制数, 有 16 个数码:  $0 \sim 9$  和  $\mathrm{A} \sim \mathrm{F}$ , 依次对应的 ASCII 码是  $30 \mathrm{H} \sim 39 \mathrm{H}$  和  $41 \mathrm{H} \sim 46 \mathrm{H}$ , 所以十六进制数  $0 \sim 9$  只要加  $30 \mathrm{H}$  就转换为了 ASCII 码, 而对  $\mathrm{A} \sim \mathrm{F}$  (大写字母) 需要再加 7 。例如, 数码 “B” 加  $30 \mathrm{H}$  、再加 7 等于  $42 \mathrm{H}$ , 正是大写字母 B 的 ASCII 码  $(0 \mathrm{BH} + 30 \mathrm{H} + 7 = 42 \mathrm{H})$  。之所以再加 7 , 是因为大写字母 A 的 ASCII 码与数字 9 的 ASCII 码相隔 7 。

# 2.4.5 中断指令

在程序运行时，遇到某些紧急情况（如停电），或者一些重要错误（如溢出），当前程序应能够暂停，处理器中止当前程序运行，转去执行处理这些紧急情况的程序段。这种情况叫做“中断”（Interrupt），而转去执行的处理中断的子程序叫做“中断服务程序”或“中断处理程序”。当前程序被中断的地方称为“断点”。中断服务程序执行完后应返回原来程序的断点，继续执行被中断的程序。中断提供了又一种改变程序执行顺序的方法。处理器一般都具有处理中断的能力。

# 1. 8086的中断类型

8086 CPU 的中断系统具有 256 个中断, 每个中断用一个唯一的中断向量号标识。向量号也称为矢量号或类型号, 用 1 字节表示:  $0 \sim 255$ , 对应 256 个中断。8086 的中断可以分为外部中断和内部中断两类。

# （1）外部中断

外部中断是来自 8086 CPU 之外的原因引起的程序中断, 又分为可屏蔽中断和非屏蔽中断两种。

可屏蔽中断是指外部的中断请求可以在 CPU 的内部被屏蔽掉, 即 CPU 可以控制是否引起程序中断。标志寄存器中的中断允许标志 IF 就是用于控制可屏蔽中断的。

在系统复位后, 任何一个中断服务程序被执行后, 以及执行关中断指令 CLI 后, 都使 IF=0。这是 CPU 不让可屏蔽中断中止程序的情况, 被称为关中断状态。执行开中断指令 STI, 使 IF=1。这是 CPU 允许可屏蔽中断中止程序的情况, 被称为开中断状态。另外, 中断服务程序结束,执行中断返回指令 IRET, 将恢复进入该中断前的 IF 状态。

除可屏蔽中断外的其他中断都不受 IF 标志控制。可屏蔽中断的向量号由外部提供。

非屏蔽中断是指外部的这个中断请求不能在 CPU 的内部被屏蔽，CPU 必须执行它的处理程序。8086 为非屏蔽中断分配了中断向量号 02。IBM PC 中，利用它来处理奇偶校验出错、浮点运算出错等情况。

# （2）内部中断

内部中断是由于8086CPU内部执行程序引起的程序中断，也称为异常（Exception），分为4种情况。

除法错中断是指在执行除法指令时，若除数为0或商超过了寄存器所能表达的范围，则产生除法错中断。8086为它分配的向量号为0。

指令中断是指执行中断调用指令 INT n 就产生指令中断, 也称为软件中断, 它的向量号就是 n。INT n 指令为 2 字节指令 (机器码为 11001101-n-, 第 2 字节就是中断向量号 n), 但向量号为 3 的指令中断 (INT 3) 是 1 字节指令 (11001100), 较特殊, 常用做程序调试的断点中断调试程序中的 G 命令就是利用断点中断 (3 号中断) 中止被调试程序的。使用调试程序时, 如果在程序段最后加上一条 INT 3 指令, 就可以停止程序运行, 而不必设置断点。

溢出中断是指在执行溢出中断指令INTO时，若溢出标志OF为1，则产生溢出中断。它的向量号为4。

单步中断是指若单步标志 TF 为 1，则在每条指令执行结束后都产生单步中断。它的向量号为 1。调试程序中的 T 命令可以利用单步中断。

# 2. 8086的中断过程

中断服务程序可以被认为是一种特殊的子程序，可以被存放在主存的任何位置。中断服务程序的首（起始、入口）地址被安排在中断向量表中。

中断向量表设置在主存的最低 1KB 区域内, 物理地址为  $000 \mathrm{H} \sim 3 \mathrm{FFH}$  。向量表从 0 开始每 4 字节 (双字) 对应一个中断, 低字存放中断服务程序的偏移地址 IP, 高字存放其段地址 CS。向量号 n 的中断服务程序存放在中断向量表  $4 \times \mathrm{n}$  的物理地址, 如图 2-10 所示。

获得中断向量号  $\mathbf{n}$  之后，8086CPU对任何一个中断的处理过程都是一样的。

① 标志寄存器入栈保存：SP←SP-2，SS:[SP]←FLAGS。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/406914cc80986eaae2716e351a17965a62b4703d162a1011324636141e3157a0.jpg)  
图2-10 中断向量表结构

② 禁止新的可屏蔽中断和单步中断：  $\mathrm{IF} = \mathrm{TF}\leftarrow 0$  
(3) 断点地址入栈保存: SP←SP-2, SS: [SP]←CS; SP←SP-2, SS: [SP]←IP。  
④ 读取中断服务程序的起始地址：IP  $\leftarrow$  [n×4]，CS  $\leftarrow$  [n×4+2]。

中断时，为了保证中断服务程序正确返回原来的程序，要把被中断程序的断点处逻辑地址CS:IP压入堆栈保存，还要保存反映现场状态的标志寄存器FLAGS，然后将中断服务程序的入口地址送CS和IP寄存器转去执行中断服务程序。

中断服务程序执行完后返回原程序时，应恢复堆栈中保存的断点地址CS:IP及标志寄存器。中断返回指令IRET实现从中断服务程序返回原程序，其过程如下：

(1) 断点地址出栈恢复:  $\mathrm{IP} \leftarrow \mathrm{SS} : [\mathrm{SP}]$ ,  $\mathrm{SP} \leftarrow \mathrm{SP} + 2$ ;  $\mathrm{CS} \leftarrow \mathrm{SS} : [\mathrm{SP}]$ ,  $\mathrm{SP} \leftarrow \mathrm{SP} + 2$ 。  
② 标志寄存器出栈恢复：FLAGS←SS:[SP], SP←SP+2。

# 3. 8086的中断指令

中断调用指令的执行过程非常类似于子程序的调用，只不过要保存和恢复标志寄存器。计算机系统常利用它为用户提供硬件设备的驱动程序。IBM PC 系列微机中的基本输入/输出系统 BIOS 和操作系统 DOS 都提供了丰富的中断服务程序来让程序员调用。

<table><tr><td>int i8</td><td>;中断调用指令:产生i8号中断</td></tr><tr><td>iret</td><td>;中断返回指令:实现中断返回</td></tr><tr><td>into</td><td>;溢出中断指令:溢出标志of=1,则产生4号中断,否则顺序执行</td></tr></table>

# 2.5 处理机控制类指令

处理机控制类指令用来控制各种CPU的操作，如暂停、等待或空操作等。

# （1）空操作指令NOP

空操作指令不执行任何有意义的操作，但占用1字节存储单元，空耗一个指令执行周期。该指令常用于程序调试。

nop

例如，在需要预留指令空间时用NOP填充，代码空间多余时也可以用NOP填充，还可以用NOP实现软件延时。事实上，NOP就是XCHG AX,AX指令，它们的代码一样。

（2）段超越前缀指令SEG

在允许段超越的存储器操作数之前，使用段超越前缀指令，将不采用默认的段寄存器，是采用指定的段寄存器寻址操作数。

seg:

即cs：,ss：,ds：,es：，取代默认段寄存器

（3）封锁前缀指令 LOCK

封锁前缀指令是一个指令前缀，使得在这个指令执行时间内，8086处理器的封锁输出引有效，即把总线封锁，使别的控制器不能控制总线，直到该指令执行完后，总线封锁解除。CPU与其他处理机协同工作时，该指令可避免破坏有用信息。

lock

；封锁总线

（4）暂停指令HLT

暂停指令使 CPU 进入暂停状态，这时 CPU 不进行任何操作。当 CPU 发生复位或来自部的中断时，CPU 脱离暂停状态。

hlt

；进入暂停状态

暂停指令可用于程序中等待中断。当程序中必须等待中断时，可用 HLT 指令，而不必软件死循环。然后，中断使 CPU 脱离暂停状态，返回执行 HLT 的下一条指令。注意，该指在计算机中将引起所谓的“死机”，一般的应用程序不要使用。

（5）交权指令 ESC

交权指令 ESC 把浮点指令交给浮点处理器执行。

esc

6位立即数，reg/mem

；把浮点指令交给浮点处理器

为了提高系统的浮点运算能力, 8086 系统中可加入浮点运算协处理器 8087。但是, 80 的浮点指令是与 8086 的整数指令组合在一起的, 8086 主存中存储 8087 的操作码及其所需的作数。当 8086 发现是一条浮点指令时, 就利用 ESC 指令将浮点指令交给 8087 执行, 6 位立数即为浮点指令的操作码, REG/MEM 指示浮点指令的操作数。当操作数为寄存器时, 它的码也作为操作码; 如果为存储器操作数, CPU 读出这个操作数送给协处理器。例如:

wait 6, [si]

; 就是 32 位实数除法指令: fdiv dword ptr[si]

esc

; 就是 32 位整数加法指令: fadd st(0), st

实际编写程序时，一般采用易于理解的浮点指令助记符格式，详见第8章。

（6）等待指令WAIT

WAIT指令在8086的测试输入引脚为高电平无效时，使CPU进入等待状态，这时CPU不做任何操作；测试为低电平有效时，CPU脱离等待状态，继续执行后面的指令。

wait

；进入等待状态

浮点指令经由 8086 CPU 处理发往 8087，并与 8086 本身的整数指令在同一个指令序列而 8087 执行浮点指令较慢，所以 8086 必须与 8087 保持同步。8086 就是利用 WAIT 指令和试引脚实现与 8087 同步运行的。

本章详细介绍了除输入/输出指令和串操作类指令外，8086 所支持的 16 位指令系统。由指令较多，又各有特色，希望读者进行一下整理（总结），诸如各种寻址方式、指令支持的作数形式、指令对标志的影响、常见编程问题等。通过整理复习，形成指令系统的整体知识

建议读者应该重点掌握常用的指令如下：

MOV、XCHG、PUSH、POP、LEA

ADD、ADC、INC,SUB、SBB、DEC、NEG、CMP，MUL、IMUL、DIV、IDIV

AND、OR、XOR、NOT、TEST，SHL/SAL、SHR、SAR、ROL、ROR、RCL、RQ

JMP、JCC、LOOP、CALL、RET、INT

同时要熟悉一些特殊的指令、了解不常使用的指令的功能。

# 习题2

2.1 已知  $\mathrm{DS} = 2000 \mathrm{H}, \mathrm{BX} = 0100 \mathrm{H}, \mathrm{SI} = 0002 \mathrm{H}$ , 存储单元  $[20100 \mathrm{H}] \sim [20103 \mathrm{H}]$  中依次存放  $12 \mathrm{H}$  、  $34 \mathrm{H} 、 56 \mathrm{H} 、 78 \mathrm{H}, [21200 \mathrm{H}] \sim [21203 \mathrm{H}]$  中依次存放  $2 \mathrm{AH} 、 4 \mathrm{CH} 、 \mathrm{B7H} 、 65 \mathrm{H}$ , 说明下列每条指令执行后 AX 寄存器的内容。

(1) mov ax, 1200h  
(2) mov ax,bx  
(3) mov ax, [1200h]  
(4) mov ax, [bx]  
(5) mov ax, [bx+1100h]  
(6) mov ax, [bx+si]  
(7) mov ax, [bx][si+1100h]

2.2 指出下列指令的错误。

1 mov

cx, dl

(2) mov

ip, ax

(3) mov

es, 1234h

(4) mov

es,ds

(5) mov

al, 300

(6) mov

[sp], ax

(7) mov

ax, bx+di

(8) mov

20h, ah

2.3 已知数字  $0 \sim 9$  对应的格雷码依次为:  $18 \mathrm{H} 、 34 \mathrm{H} 、 05 \mathrm{H} 、 06 \mathrm{H} 、 09 \mathrm{H} 、 0 \mathrm{AH} 、 0 \mathrm{CH} 、 11 \mathrm{H} 、 12 \mathrm{H} 、 14 \mathrm{H}$ , 它存在于以 table 为首地址 (设为  $200 \mathrm{H}$  ) 的连续区域中。为如下程序段的每条指令加上注释, 说明每条指令的功能和执行结果。

```txt
lea bx, table mov al, 8 xlat
```

2.4 什么是堆栈？它的工作原则是什么？它的基本操作有哪两个？对应哪两种指令？

2.5 已知  $\mathrm{SS} = 2200\mathrm{H}$ ， $\mathrm{SP} = 00\mathrm{BOH}$ ，画图说明执行下面指令序列时，堆栈区和 SP 的内容如何变化？

```asm
mov ax, 8057h  
push ax  
mov ax, 0f79h  
push ax  
pop bx  
pop [bx]
```

2.6 给出下列各条指令执行后 AL 值，以及 CF、ZF、SF、OF 和 PF 的状态。

```txt
mov al, 89h  
add al, al  
add al, 9dh  
cmp al, 0bch  
sub al, al  
dec al  
inc al
```

2.7 设 X、Y、Z 均为双字数据，分别存放在地址为 X、X+2、Y、Y+2、Z、Z+2 的存储中，它们的运算结果存入 W 单元。阅读如下程序段，给出运算公式。

```txt
mov ax, x  
mov dx, x+2  
add ax, y  
adc dx, y+2  
add ax, 24  
adc dx, 0  
sub ax, z  
sbb dx, z+2  
mov w, ax  
mov w+2, dx
```

2.8 分别用一条汇编语言指令完成如下功能。把 BX 寄存器和 DX 寄存器的内容相加，结果存入 DX 寄存器。

(2) 用寄存器 BX 和 SI 的基址变址寻址方式把存储器的 1 字节与 AL 寄存器的内容相加, 并结果送到 AL 中。  
（3）用 BX 和位移量 0B2H 的寄存器相对寻址方式把存储器中的一个字和 CX 寄存器的内容加，并把结果送回存储器中。  
(4) 用位移量为  $0520 \mathrm{H}$  的直接寻址方式把存储器中的一个字与数  $3412 \mathrm{H}$  相加, 并把结果送该存储单元中。  
（5）把数  $0\mathrm{A}0\mathrm{H}$  与AL寄存器的内容相加，并把结果送回AL中。

2.9 设 X、Y、Z、V 均为 16 位带符号数，分别存放在 X、Y、Z、V 存储单元中，阅读以程序段，得出它的运算公式，并说明运算结果存于何处。

```asm
mov ax, x  
imul y  
mov cx, ax  
mov bx, dx  
mov ax, z  
cwd  
add cx, ax  
adc bx, dx  
sub cx, 540  
sbb bx, 0  
mov ax, v  
cwd  
sub ax, cx  
sbb dx, bx  
idiv x
```

2.10/指出下列指令的错误。

(1) XCHG [SI], 30H (2) POP CS (3) SUB [SI], [DI]  
(4) PUSH AH (5) ADC AX, DS (6) ADD [SI], 80H  
(7)SHL [SI],1 (8)ROR DX,AL

2.11 给出下列各条指令执行后的结果，以及状态标志 CF、OF、SF、ZF、PF 的状态。

```txt
mov ax, 1470h and ax, ax
```

```asm
or ax, ax  
xor ax, ax  
not ax  
test ax, 0f0f0h
```

2.12 假设例题 2.34 的程序段中， $\mathrm{AX} = 08\mathrm{H}$ ， $\mathrm{BX} = 10\mathrm{H}$ ，请说明每条指令执行后的结果和各个标志位的状态。

2.13 编写程序段完成如下要求。

（1）用位操作指令实现AL（无符号数）乘以10。

(2) 用逻辑运算指令实现数字  $0 \sim 9$  的 ASCII 码与非压缩 BCD 码的互相转换。

（3）把DX.AX中的双字右移4位。

2.14 已知 AL=F7H（表示有符号数-9），分别编写用 SAR 和 IDIV 指令实现的除以 2 的程序段，并说明各自执行后所得的商是什么？

2.15 指令指针 IP 是通用寄存器还是专用寄存器？有指令能够直接赋值吗？哪类指令的执行会改变它的值？

2.16 控制转移类指令中有哪三种寻址方式？

2.17 什么是短转移 short jump、近转移 near jump 和远转移 far jump？什么是段内转移和段间转移？8086 有哪些指令可以实现段间转移？

2.18 8086的条件转移指令的转移范围有多大？实际编程时，如何处理超出范围的条件转移？

2.19 假设  $\mathrm{DS} = 2000\mathrm{H}$ ， $\mathrm{BX} = 1256\mathrm{H}$ ， $\mathrm{SI} = 528\mathrm{FH}$ ，位移量 TABLE=20A1H，[232F7H]=3280H，[264E5H]=2450H，试问执行下列段内间接寻址的转移指令后，转移的目的地址是什么？

(1)JMP BX

(2) JMP TABLE[BX]

(3) JMP [BX][SI]

2.20 判断下列程序段跳转的条件。

(1)

```txt
xor ax, 1e1eh je equal
```

(2)

```txt
test al, 10000001b  
jnz there
```

(3)

```txt
cmp cx, 64h  
jb there
```

2.21 设置  $\mathrm{CX} = 0$  ，则LOOP指令将循环多少次？例如：

```txt
mov cx,0 delay: loop delay
```

2.22 假设AX和SI存放的是有符号数，DX和DI存放的是无符号数，请用比较指令和条件转移指令实现以下判断：

（1）若  $\mathrm{DX} > \mathrm{DI}$  ，转到ABOVE执行。  
（2）若  $\mathrm{AX} > \mathrm{SI}$  ，转到GREATER执行。  
（3）若  $\mathrm{CX} = 0$  ，转到ZERO执行。  
（4）若AX-SI产生溢出，转到OVERFLOW执行。  
（5）若  $\mathrm{SI} \leqslant \mathrm{AX}$ ，转到 LESS_EQ 执行。  
（6）若  $\mathrm{DI}\leqslant \mathrm{DX}$  ，转到BELOW_EQ执行。

2.23 有一个首地址为 ARRAY 的 20 个字的数组，说明下列程序段的功能。

```txt
mov cx, 20  
mov ax, 0  
mov si, ax  
sum-loop:add ax, array[si]  
add si, 2  
loop sum_loop  
mov total, ax
```

2.24 按照下列要求，编写相应的程序段。

(1) 起始地址为 string 的主存单元中存放有一个字符串 (长度大于 6), 把该字符串中的第 1 和第 6 个字符 (字节量) 传送给 DX 寄存器。

(2) 从主存 buffer 开始的 4 字节中保存了 4 个非压缩 BCD 码, 现按低 (高) 地址对低 (高) 位的原则, 将它们合并到 DX 中。

(3) 编写一个程序段, 在 DX 高 4 位全为 0 时, 使  $AX = 0$ , 否则使  $AX = -1$  。

（4）有两个64位数值，按“小端方式”存放在两个缓冲区buffer1和buffer2中，编写程序完成buffer1-buffer2功能。

(5) 假设从 B800h: 0 开始存放有 100 个 16 位无符号数, 编程求它们的和, 并把 32 位的和存在 DX.AX 中。

(6)已知字符串 string 包含有 32KB 内容,将其中的 “$” 符号替换成空格。  
（7）一个100字节元素的数组的首地址为array，将每个元素减1（不考虑溢出）存于原处。  
(8) 统计以“$”结尾的字符串 srting 的字符个数。

2.25 对下面要求，分别给出3种方法，每种方法只用一条指令。

（1）使  $\mathrm{CF} = 0$

（2）使  $\mathrm{AX} = 0$

（3）同时使  $\mathrm{AX} = 0$  和  $\mathrm{CF} = 0$

2.26 参照图 2-11, 分析调用序列, 画出每次调用及返回时的堆栈状态。其中 CALL 前是该令所在的逻辑地址。另外, 段内直接调用指令的机器代码的字节数为 3 , 段间直接调用指令则为字节。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-13/3770c117-deda-44f2-b0b0-05a8493812f4/c58f38403b471b96d3492264c117103ae2ff8ddf896b2a11a2094e5d35095175.jpg)  
图2-11 习题2.26示意图

2.27 已知 AX、BX 分别存放的是 4 位压缩 BCD 表示的十进制数，请说明如下子程序的功和出口参数。

add al,bl

aaa

xchg al, ah

```txt
adc al, bh  
daa  
xchg al, ah  
ret
```

2.28 AAD 指令是用于除法指令之前，进行非压缩 BCD 码调整的。实际上，处理器的调整过程是： $\mathrm{AL} \leftarrow \mathrm{AH} \times 10 + \mathrm{AL}$ ， $\mathrm{AH} \leftarrow 0$ 。如果指令系统没有 AAD 指令，请用一个子程序完成这个调整工作。

2.29 解释如下有关中断的概念。

（1）内部中断和外部中断

（2）单步中断和断点中断

（3）除法错中断和溢出中断

（4）中断向量号和中断向量表

2.30 试比较 INT n 和段间 CALL 指令、IRET 和段间 RET 指令的功能。