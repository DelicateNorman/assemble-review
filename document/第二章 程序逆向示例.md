# 逆向工程分析技术

鲁宏伟

luhw@hust.edu.cn

# 第二章

# 一个简单程序的逆向分析

本章结合一个具体的二进制文件示例，带着大家体会一下分析程序的过程。

- 这里准备了一个简单的程序，程序的目标是通过对其进行逆向分析，获取需要输入的字符串，了解 CTF（Capture The Flag）比赛的应该比较熟悉，该示例就是一个比赛的题目，目标是获取程序中隐藏的“Flag”。

# 观察程序的行为

- 在分析一个程序之前，需要首先对程序的运行环境，比如操作系统（Windows 或 Linux，再或者 Android）以及 32 位程序还是 64 位程序。  
- 不同操作系统平台下运行的程序文件结构有很大的不同，我们可以通过查看文件结构了解程序运行的平台。  
例如，运行在 Windows 平台的 exe 文件，通常被称为 PE 文件，而运行在 Linux 平台的 exe 文件则称为 ELF 文件，而 Android 程序则可以直接通过程序的后缀进行判断。

• 本章的示例是一个 Windows 程序。对于这个一个程序文件, 如何判断它是 32 位程序还是 64 位程序呢。  
- 32位Windows系统，一个64位程序是不能运行的，这样个通过系统的提示，就可以判断程序的类型。如果是64位操作系统，则可以通过反汇编工具查看程序中对应指令使用的寄存器进行判断。  
- 有些工具会分别提供 32 位和 64 位分析版本, 比如 IDA Pro 中 32 位版本程序为 ida.exe , 而 64 位程序为 ida64.exe 。对于一个 64 位程序,直接用 ida.exe 打开时, 工具会给出相应的提示。

• 先来运行一下程序, 这是一个 Windows 控制台程序 (Console Application), 需要先运行 cmd 程序, 然后运行该程序 (程序文件名为 Experient-1.exe)。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/dd1c5816dfedb16c4cdc642226db64db3e815da6a76fdff417da9cd59b3efe66.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/3b5ea8c10ed5864760d7b113ee1011ae41a4a6f17293769f509b430ea6504306.jpg)

# 静态分析

• 观察了程序的行为，接下来需要弄清楚应该输入什么内容，才会出现输入正确的提示。  
- 这是一个二进制文件，我们可以尝试用二进制文件编辑工具打开这个文件，比如用 Visual

Studio 2010 的二进制编辑器打开文件，注意打开文件时，需要选择二进制编辑器，否则会直接运行该程序。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/c8e0a075d4c3d42129204efa8fbc150b448d312dc0d6a31c209a75cfa86ebde5.jpg)

- 要充分理解程序的逻辑，需要弄清楚文件的完整结构，这不是我们这里的重点，因为对这样一个程序，可以直接利用现有的工具对它进行分析。  
- 二进制文件反汇编工具有很多，其中 IDA Pro 被认为是非常强大的工具之一。以下的分析都是基于该工具完成的。

启动ida.exe，然后选择打开示例文件

Experient- 1.exe ,

弹出图 2.5 所示的窗

口。窗口中，显示了

三种文件格式的选

择，其中第一种格式

提示我们这是一个

80386 PE 文件。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/91e59a1cf4267c5850dca642ccee37fb7e4e35111dc272be701134d7f335369c.jpg)

# 寻找 main 函数

- 我们在学习 C 语言的时候，已经知道每一个控制台应用程序都有一个唯一的函数 main()，为什么这里显示的却不是 main 函数呢？  
• 事实上，main 函数只是从 C 语言的视角看是程序的入口，但当我们运行该程序时，是由系统中的其他函数（名称为“start”）调用 main 函数的，所以从汇编语言中看，main 并不是程序的真正入口。  
- 尽管如此，我们在分析程序时，还是需要从 main 函数入手。  
- 问题来了，如何能够找到这个函数呢？

# 寻找 main 函数

- 通常情况下，在开发程序时，编译器会产生一些对应的符号信息，同时没有特殊处理的程序中，高版本的 IDA Pro 能够自动识别一些标准的库函数。因而，在用 IDA Pro 打开程序时，通常情况下，弹出的第一个窗口就是程序入口  
然而，本章要分析的目标程序 Experient-1.exe，打开时弹出的第一个窗口显示的却不是 main 函数，

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/ebc44b53336eebd3e30a1535526687bdfcd06d7af8c592734cce84033ad74222.jpg)

# 寻找 main 函数

- 在 IDA Pro 的界面中，最左侧窗口是“Function window”，列举了程序中所包含的所有函数名。通常情况下，IDA 无法识别的函数名称其前缀为 sub，后面是该函数在二进制文件的偏移地址。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/55f30fa62d2a97961247671972414acb7f8bad93dc8b48733d5de49165634697.jpg)

# 寻找 main 函数

- 在 Functions window 中搜索 “main”, 却没有找到包含 “main” 的函数名。产生这种结果的原因可能是程序设计者对函数名做了混淆处理。  
- 这种情况下，如何查找程序对应的 main 函数呢？  
- 一种方法是顺着 start 函数中的jmp 指令，一步步地寻找。  
- 点击图中的函数名“sub_4EAA60”，会直接跳转并弹出该函数代码窗口。然后，顺着调用的路径逐一点击，去寻找可能的 main 函数程序指令代码。  
然而，随着路径的深入，我们会发现分支越来越多，使得确定 main 函数相关指令变得异常困难

# 寻找 main 函数

- IDA Pro 提供了获取程序 CFG（Control Flow Graph）的工具，能够帮助我们获取完整的函数调用关系图。  
- "Xrefs graph to..."指的是调用该函数的父函数以及“祖先”，而“Xrefs graph from..."指的是该函数调用的子函数以及“子孙”。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/a9fa51556def35241497bc1472e144f188ef1b5049bf62ce38432ba87510f715.jpg)

# 寻找 main 函数

- 示例中的函数不是特别多的情况下，已经让初次接触逆向分析的同学感到头疼了吧！  
- IDA 提供的这个工具能够对 CFG 进行放大显示，这样能够看清楚图中的函数名称以及调用关系。但即便如此，众多的函数中，哪个才是 main 函数呢？

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/9e3cdd6cd1d9c7d85af3cb2c9851c567073adc25e219961ef7dbed5dff0a3526.jpg)

# 寻找 main 函数

- 追踪到 sub_4EA730，我们发现它竟然直接调用了十几个函数，这使得我们定位 main 函数陷入了困境。这意味着这种寻求 main 函数的方法不是一种可行的方法。  
- 程序运行后，会显示字符串“Please Input:”，根据常识，这个显示输入的代码应该是在main函数中的。如果能够在反汇编的程序代码中找到这个字符串，就能够定位main函数。

# 寻找 main 函数

- 在 IDA Pro 中通过热键 “shift+F12”, 弹出窗口 “Strings window”, 窗口中列举了程序代码中所有的字符串, 按 “CTR+F” 搜索 “Please Input:”, 可以定位到该字符串出现的偏移地址

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/1f05aef95812be7f1529af1baf54853df0d368e1b2394bb48242097ff4e647e3.jpg)

# 寻找 main 函数

- 点击图中的字符串 “Please Input:”, 即可跳转到引用该字符串的位置。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/6e37793bd10a46348358a01522fa489aa4a0add6346321b105e125d02f0d09e7.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/52b1a5b95591736d9327446466fa52fda620ade7587c6fc055fbd2722e370c0a.jpg)

# 寻找 main 函数

- 图中，“.rdata”表示字符串定义在汇编程序代码的只读数据段。点击图中④处的函数名，即可直接跳转到引用该字符串的程序代码

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/4f7635302d93d3c0e5ccf6642ab2be3f38e74f18e75db59e4f4b40c28751a9c4.jpg)

# main 函数分析

- 为了获取 flag，需要对函数的运行逻辑进行分析。面对图中的汇编代码，虽然指令不是特别复杂，但从可读性而言，如果能够将其进一步反编译成 C 语言代码，会更有利于对程序的运行逻辑进行分析。  
- 幸运的是，IDA Pro 中包含了 Hex-Rays 反编译工具，可以方便地将汇编语言代码反编译成 C 代码

# main 函数分析

- 回到函数 sub_4A19B0，在函数体内部按“Tab”键，却提示反编译失败，失败的原因是“positive sp value has been found”，发现了“正”的sp值，这里sp指的是栈的相对偏移地址。  
• 事实上，如果我们查看一下这个函数的尾部代码，在偏移地址 .text:004A1A93 有行红色的标记。通常情况下，IDA Pro 出现红色标记，并提示“sp-analysis failed”，预示着反汇编出现了异常。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/ac0d91934784b13f143e60c3343df28f5fd084883dbd68d4228442b98533d164.jpg)

# main 函数分析

- 稍后，我们再来想办法修复这个错误。现在，反编译失败，使得我们只能以汇编语言指令为基础进行分析，但由于程序设计者特意对函数名进行了混淆，使得初次接触逆向分析的读者来说，理解这些汇编代码有点困难。  
- 为了很好地理解汇编语言代码的含义，根据汇编指令的观察，可以尝试编写一段简单的 C 代码，模拟其中的提示，对其进行编译后，再查看其反汇编代码。将二者进行对照，或许能够理解程序中的代码。

代码2.1  
```c
include<stdio.h>   
#include<string.h>   
char in_str[32]  $\equiv$  "";   
char format[32]  $=$  "s";   
void main(){ char flag[]  $\equiv$  "123456"; int i, len; printf_s.format("Please Input:"); scanf("%s",in_str,31); len  $\equiv$  strlen(in_str); for(i=0;i<len;i++){ if(!(in_str[i]  $\equiv$  flag[i])) { printf("Input Error!"); return; } printf("Input OK!");   
}
```

# main 函数分析

- 现在我们查看一下代码 2.1 反汇编

后的部分汇编代码。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/89b2f0b25598e4e02b82a5fbb6e3835ec949df2a45d0055ec141ca69dffd2779.jpg)

# main 函数分析

- 对比图中的代码，基本上能够判断出来，函数 sub_48CD46 和 sub_48COEE 对应的应该是 printf_s 和 scanf_s。

```csv
xor eax,ebp   
mov [ebp+var_4],eax   
mov eax,ds:dword_4020F4   
mov cx,ds:word_4020F8 1调用printf_s前push两个参数   
mov dl,ds:byte_4020FA   
push offset aPleaseInput; "Please Input:"   
push offset Format  $\text{巧} \% \mathrm { s } ^ { \text{巧} }$    
mov [ebp+var_C],eax   
mov [ebp+var_8],cx   
mov [ebp+var_6],dl   
call ds:printf_s   
push 1Fh   
push offset byte_40338C 2调用scanf_s前push三个参数   
push offset aS  $\text{巧} \% \mathrm { s } ^ { \text{巧} }$    
call ds:scanf s   
mov eax,offset byte_40338C
```

# main 函数分析

- 为了便于后面的分析，我们可以利用 IDA Pro 提供的工具修改一下两个函数名：鼠标右键点击需要修改的函数名称，选择“Rename”即可进行修改

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/86e8ab64f71681e5a28db923847506e057a7bc7bccb52e4add4508fbf1f95f2f.jpg)

# main 函数分析

# - 函数和变量名称修改后的结果

.text:004A19D8

.text:004A19DD

.text:004A19E2

.text:004A19E7

.text:004A19EA

.text:004A19EC

.text:004A19F1

.text:004A19F6

.text:004A19FB

.text:004A19FE

.text:004A1A03

.text:004A1A08

.text:004A1A0B

.text:004A1A0E

.text:004A1A12

.text:004A1A14

.text:004A1A18

push offset aPleaseInput; "Please Input:" push offset unk_5F31E0

call printf_s 修改名字

add esp, 8

push 1Eh

push offset in_str

push offset a5

call scanf_s

add esp, 0Ch

push offset in_str

call sub 48A9A6

add esp, 4

mov [ebp+var_8], eax

cmp [ebp+var_8], 1Eh

```bash
jg short loc_4A1A1A

cmp [ebp+var_8], 0Ah

jge short loc_4A1A30

这个函数功能是？

eax是调用

sub_48A9A6返回的值

# main 函数分析

- 为了便于理解，把 unk_5F3068 修改为“in_str”，实际上，它对应于需要输入的“flag”。可以推断出函数 sub_48A9A6 应该是获取输入字符串 in_str 的长度。  
- 对程序的逻辑进一步分析，接下来是对字符串长度进行检测，如果大于30（1Eh）或者小于10（0Ah），就退出，也就是说“flag”的长度应该在10和30之间。

```asm
.text:004A1A03   
.text:004A1A08   
.text:004A1A0B   
.text:004A1A0E   
.text:004A1A12   
.text:004A1A14   
.text:004A1A18   
.text:004A1A1A   
.text:004A1A1A loc_4A1A1A:   
.text:004A1A1A   
.text:004A1A1F   
.text:004A1A24   
.text:004A1A27   
.text:004A1A29   
.text:004A1A2E   
.text:004A1A30;   
.text:004A1A30   
.text:004A1A30 loc_4A1A30:   
.text:004A1A30   
.text:004A1A35   
.text:004A1A37   
.text:004A1A3C   
.text:004A1A3D
```

```asm
call str_len  
add esp, 4  
mov [ebp+var_8], eax  
cmp [ebp+var_8], 1Eh  
jg short loc_4A1A1A  
cmp [ebp+var_8], 0Ah  
jge short loc_4A1A30  
; CODE XREF: sub_4A19B0+62↑j  
push offset unk_5B25CC  
call sub_48A6DB  
add esp, 4  
push 0  
call sub_48C274  
jmp short loc_4A1A7E  
; CODE XREF: sub_4A19B0+68↑j  
push offset in_str  
push 1Eh  
mov eax, dword_5F3088  
push eax  
call sub_48E5BF
```

# main 函数分析

- 以下重点分析偏移地址 text:004A1A30 到 text:004A1A7E 之间的代码。  
• 注意到图 2.21 中④，函数 sub_48E5BF 的输入分别是 dword_5F3088、1Eh 和 in_str（按照 C 调用约定，函数调用时，应该自右向左将参数压入栈中）。  
- 那么这个函数的作用是什么呢?

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/4a8186d2f4ce97121abe3aba371734ae03aef42e17d58c9bcb7096457b89a950.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/e44fe1f6e7274533a60aff1b533cb8a7d670851c90f5c38f64cb58c04b292d91.jpg)

# main 函数分析

- 跟踪一下函数 sub_48E5BF（鼠标左键点击该函数名），会跳转到函数 sub_5479E0，然后在该函数体内按“Tab”键，显示其伪代码。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/602fcea413b019a3e004d3d531e364a7431893b7c18664cb270db0a4404bb34d.jpg)

# main 函数分析

- 这段代码确认了前面的判断, 即函数 sub_48E5BF 仅仅是将 in_str 的内容复制到变量 dword_5F3088 中, 然后对 dword_5F3088 中的内容 (相当于 in_str) 进行分析

.text:004A1A42  
.text:004A1A45  
.text:004A1A4A  
.text:004A1A4D  
.text:004A1A53  
.text:004A1A57  
.text:004A1A5A  
.text:004A1A5C  
.text:004A1A61  
.text:004A1A66  
.text:004A1A69  
.text:004A1A6B  
.text:004A1A70  
.text:004A1A70 loc_4A1A70:  
.text:004A1A70  
.text:004A1A75  
.text:004A1A76  
.text:004A1A7B

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/d51800cdbe29f244c6e74371a6ee0cc7ced0b01ff7370d88a30715fc2c456276.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/598da89136d65925bcf43bfb3da1e2bbbbd44c3a080e2e96ac3a428bbcc90777.jpg)

# main 函数分析

- 图中对输入的第 8 个字符的值进行判断, 如果是字符 A , 则跳转到 .text:004A1A70 继续进行处理 (图中⑤), 否则执行到 .text:004A1A6B退出

.text:004A1A42  
.text:004A1A45  
.text:004A1A4A  
.text:004A1A4D  
.text:004A1A53  
.text:004A1A57  
.text:004A1A5A  
.text:004A1A5C  
.text:004A1A61  
.text:004A1A66  
.text:004A1A69  
.text:004A1A6B  
.text:004A1A70  
.text:004A1A70 loc_4A1A70:  
.text:004A1A70  
.text:004A1A75  
.text:004A1A76  
.text:004A1A7B

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/c6885c8a70e73762bfefcc8737d3f3e099d2cfb20d19e75c9edd3a2e20b7ff93.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/4dba924c30a2fc6f842a9f774b66db8ebff7ddce62bf05fda3ab1b39978728be.jpg)

# main 函数分析

- 图中的代码实际上就是把 dword_5F3088 作为参数传递给函数 sub_48D3A4 进行处理, 所以下面重点分析该函数。点击该函数名, 然后中间的连接可以跳转到 sub_49DBD0 , 在函数体内按 “Tab” 键, 显示其伪代码

.text:004A1A42  
.text:004A1A45  
.text:004A1A4A  
.text:004A1A4D  
.text:004A1A53  
.text:004A1A57  
.text:004A1A5A  
.text:004A1A5C  
.text:004A1A61  
.text:004A1A66  
.text:004A1A69  
.text:004A1A6B  
.text:004A1A70  
.text:004A1A70 loc_4A1A70:  
.text:004A1A70  
.text:004A1A75  
.text:004A1A76  
.text:004A1A7B

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/512b99dabb294e760f557ba51568ecaebf2cbe9a6b8e27631c42a941a7b1ce0e.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/6ded6eab06cbfaf67660f79d6fed236eef663a2237f5876f4b2efe5e3223a9b3.jpg)

# main 函数分析

- 点击该函数名, 然后中间的连接可以跳转到 sub_49DBD0 , 在函数体内按 “Tab” 键, 显示其伪代码。变量 a1 即为 dword_5F3088

```txt
1 int __cdecl sub_49DBD0(int a1)
2 {
3 unsigned int i; // [esp+D0h] [ebp-8h]
4 sub 48D7B4(&unk 5F6007); 1 将a1的第8个字符改为35 (#)
5 *(_BYTE *) (a1 + 7) = 35;
6 for (i = 0; i < str_len(a1); ++i)
7 *(_BYTE *) (i + a1) ^= 0x1Fu; 2 将数组a1的值逐一与1Fh做异或
8 return sub_48D935();
10}
```

• 继续跟踪函数 sub_48D935 的伪码（鼠标左键点击函数名），sub_48D935(1, a1, xmm0_4_0)  $\rightarrow$  sub_4EA470(a1, result,_XMM0_4)。  
- 通过分析 sub_4EA470 的伪码，我们会发现 sub_48D935 没有再对

# main 函数分析

• 继续跟踪函数 sub_48D935 的伪码（鼠标左键点击函数名），sub_48D935(1, a1, xmm0_4_0)  $\rightarrow$  sub_4EA470(a1, result,_XMM0_4)。  
通过分析sub_4EA470的伪码，我们会发现sub_48D935没有再对  
dword_5F3 int __usercall sub_4EA470@<eax>(char a1@<zf>,int result@<eax>，int_XMM0_4@<xmm0>；  
2{int v4; // [esp+0h] [ebp-8h]void *retaddr; // [esp+8h] [ebp+0h]  
5if（!a1）至少从表面上看，没有对result参数做什么处理  
7{v4 = result;asm{bndstx[esp+eax+8+var_8],bnd0}sub_48E0D8(retaddr,0);result  $=$  v4;asm{bndldxbnd0,[esp+eax+4+var_8]}  
12直接返回  
14return result;

# main 函数分析

- 分析到这里，我们只是知道输入的第 8 个字符必须是 ‘A’，长度要在  $10 \sim 30$  之间，其次就是对输入的字符串做了一次异或运算（在此之前，将第 8 个字符替换为 ‘#’）。  
- 根据异或运算的特点，对异或运算后的字符串再做一次同样的异或操作，就能够还原该字符串，然而，“flag”究竟应该是什么，仅靠这些信息是不够的。似乎陷入了困境！

# dword_5F3088 分析

- 根据前述的分析，关键在于 dword_5F3088。现在，重新回到前面的代码⑤处，需要知道除了该处对该变量的处理，是否还有其他我们之前没有分析到的地方对它做了一些处理。  
- IDA Pro 提供了对显示变量或者函数交叉引用列表的功能。图 2.23 中的代码⑤处右键点击变量名 dword_5F3088，弹出引用该变量的列表（窗口）

# dword_5F3088 分析

- IDA Pro 提供了对显示变量或者函数交叉引用列表的功能。图中的代码⑤处右键点击变量名 dword_5F3088，弹出引用该变量的列表（窗口）

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/bd44f46bb61b00a3e37c1e98dabad202148b0a3e499ceea5423485350353ddc9.jpg)

# dword_5F3088 分析

• 注意到图中“引用3”实际上就是main函数（sub_sub_4A19B0），前面已经分析过了，所以应重点关注“引用1”（sub_495810）和“引用2”（sub_49DC80）。点击“引用1”，跳转到引用处的函数体，按“Tab”键弹出其伪码（图2.18），函数sub_48D935已经在图2.24中进行过分析，没有对变量做什么处理，因而可以忽略

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/0d93e38368b8f03a84bcb93750a17e352d229537cf65d604bab9e7c25a9d78ab.jpg)

# dword_5F3088 分析

- 点击“引用1”，跳转到引用处的函数体，按“Tab”键弹出其伪码，函数sub_48D935已经在前面进行过分析，没有对变量做什么处理，因而可以忽略

```txt
1 int sub_495810()
2 {
3     int v0; // ecx
4
5         sub_48D7B4(&unk_5F6007);
6         dword_5F3088 = sub_48B0B3(30);
7         return sub_48D935(v0);
8}
```

# dword_5F3088 分析

下面分析“引用2”，类似地可以得到函数sub_49DC80的伪码  
- 在图中有两个小于 128 的整数, 为了更方便地分析, 可以修改其显示方式

```c
int __cdecl sub_49DC80(int a1)
{
    int v1; // ecx
    unsigned int i; // [esp + E8h] [ebp - 14h]
    sub_48D7B4(&unk_5F6007);
    if (a1)
        {
            for (i = 0; i < sub_48A9A6(a1); ++i)
                *(BYTE*) (i + a1) ^= 0x1Cu;
            if (!sub_48DB42(a1, dword_5F3088))
                {
                    sub_48B4AA(&unk_5F31E0, 111);
                    sub_48B4AA(&unk_5F31E0, 107);
                }
            }
        }
return sub_48D935(v1);
}
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/f0047ef67537fac85f4ad6a396ac410df2bc0698398bad07774be5bfeccc702b.jpg)

# - 选择“char”得到图中的结果

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/64a2f5b446efe492622d93e92274710c0f21554e2820b7abc7430a1533103530.jpg)

# dword_5F3088 分析

图中，注意到对输入变量 a1（实际上是个 char*）做了一次异或处理，然后调用函数 sub_48DB42 对 a1 和 dword_5F3088 进行处理，如果函数返回值为 0，会调用后面的函数 sub_48B4AA，从字符 ‘o’ 和 ‘k’ 来看，该函数应该类似于 printf_s 的操作。

重点来了，函数 sub_48DB42 对两个参数做了什么处理？

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/b0d79b4b6fdb73225acfe1977f525e677ab0c9944596b68321a80d315530cab9.jpg)

# dword_5F3088 分析

# 跟踪这个函数

sub_48DB42  $\rightarrow$  sub_547DE0，分析函数 sub_547DE0 的伪码，其核心的代码段如图所示

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/7cd81aac2a22e4ee40e9a284e5eece8589aa8d795579f48f72eeb484c117482c.jpg)

# dword_5F3088 分析

通过分析图中的核心代码，尽管程序设计者为了迷惑分析者对代码进行了一些处理，我们依然能够判断出来，该函数的作用就是对两个char型指针变量（对应两个字符串）进行比较，查看其是否相同，相同则返回0，否则返回1

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/c9b9f0656fcdf5dff16115930c7f9ff6bb0a944c1817a122ca58800d96b536f2.jpg)

1

# a1分析

- 为了弄清楚 a1 的源头，可以对函数 sub_49DC80 的调用进行回溯，由此可以得到：  
- sub_49DC80(int a1)←sub_48DACA(int a1)←sub_49CEB0()

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/af457189fe2acec7eb9926ab7812d5976f1ce4305341e965c973d558a1e94424.jpg)

# a1 分析

- sub_49DC80(int a1)  $\leftarrow$  sub_48DACA(int a1)  $\leftarrow$  sub_49CEB0()  
- 下图显示了变量 a1 的源头，它源于一个字符串常量 aThisIsAnExample，点击图中的常量名，可以看到它实际上是字符串 'This is an example'。那么，它是否我们要寻找的 flag 呢？显然不是，因为它的第 8 个字符为空字符，而非 'A'，而且我们从前面的分析已经知道在对 a1 和变量 dword_5F3088 进行比较时，还对二者进行了异或运算

```c
1 int sub_49CEB0()
2 {
3     int v1; // [esp+0h] [ebp-E8h]
4         1该字符串常量就是a1的源头
5         sub_48D7B4(&unk_5F6007);
6         sub_48DACA((int)aThisIsAnExample);
7         return sub_48D935(v1);
8}
```

# 获取 flag

• 通过前面的分析, 我们知道了经过处理后的字符串 dword_5F3088 要等于常量字符串 aThisIsAnExample1 (即 'This is an example') , 那么只要按照以下步骤反向处理就能够得到目标字符串 flag :

√ Step1：将 'This is an example' 与 0x1C 异或;  
√ Step2：上述结果与0x1F进行异或；  
√ Step3：将上述结果的第8个字符替换为“A”。

# 编写脚本

- 直接利用 IDA Pro 提供的脚本工具完成这一操作。  
- IDA Pro 提供了两种处理脚本的方式，一种是打开预先编写的脚本，另一种是通过脚本编辑窗口临时编写脚本。考虑到我们要处理的工作比较简单，这里采用第二种方式

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/9a098256eb618963760d515a206096894ef30f062adafa02fb810cb13565672a.jpg)

# 编写脚本

- 考虑到我们要处理的工作比较简单，这里采用第二种方式

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/8e70a7f2eda8d8a1e3fc45b90b29d4b5a27b2e30e887860960846f7e3c6ea5b5.jpg)

# 编写脚本

- IDA Pro 选择了两种编写脚本的语言, 一种是 IDC , 另一种是 Python 。前者是一种类似 C 语言的脚本, 后者是比较流行的脚本语言。这里采用

Python 脚本, 如图所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/170365b61bb45fd7c5fd63239c454d4304f49deea03586d217c3b8942b408b08.jpg)

# 编写脚本

- 点击图中的“Run”，可以在IDA Pro左下角看到“Output window”窗口，显示运行结果

Output window

1 计算结果

WkjpAjpAbmAf{bnsof

- 现在，我们在提示中输入得到的结果：WkjpAjpAbmAf{bnsof，得到下图的结果，没任何提示，为什么？

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/d2690824f02de2027078d779f633fbcca0b9e4bba69f86a8050354da3d76c2b4.jpg)

# 解决反编译失败问题

- 重新回到函数 sub_4A19B0 的位置，之所以反编译失败，是因为在函数结尾处提示“sp-analysis failed”，即“sp 分析失败”。  
- 要理解失败的原因，需要先弄清楚函数调用时“栈平衡”的概念。

# 解决反编译失败问题

- 栈是程序中一块十分重要的内存空间，程序在加载到系统中时，操作系统会根据需要为其进程分配一块临时的内存空间，用以实现进程内函数调用时参数的传递，以及保存函数内局部变量的值，X86 处理器采用 bp 和 sp（32 位环境下对应为 ebx 和 esp）维持栈的操作。  
- 在函数调用前后，需要保障两个寄存器的值不变，这就是所谓的“栈平衡”。  
- 影响 sp 值的操作主要是 push、pop 以及 add sp, imm（立即数）这些指令。

# 解决反编译失败问题

- 要弄清楚为什么会出现“sp分析失败”，需要分析函数内相关指令对sp的值产生了哪些影响，所以需要在“IDA View”窗口中显示出sp值的变化（缺省情况下，不会显示这些内容），这需要在IDAOption窗口中进行设置。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/f4cbe82e302701d5c9eb19895f8189ea2623c8d01c8f5d3f98efd6224cb62b56.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/f17cfdcb80585a123d07d324f8b739b94c0422e7a4a47a4e14c36cfaef57ae25.jpg)

# 解决反编译失败问题

- 勾选“Stack pointer”，为了后续分析，这里将“Number of opcode...”设置为6，这样在“IDA View”窗口能够显示栈指针的变化以及指令对应的机器码（opcode）

.text:004A19B0  
.text:004A19B0  
.text:004A19B  
.text:004A19Bv  
.text:004A19B0  
.text:004A19B0  
.text:004A19B1  
.text:004A19B3  
.text:004A19B9  
.text:004A19BA  
.text:004A19BB

esp的相对值实际上应该是负值

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/ffd55b032d4078dd2e1cb9a05e989c725002a93db2e1a70220464c437f0114b3.jpg)

指令的机器码

00055  
004 8B EC  
004 81  
0D0 53  
0D4 56  
0D8 57

t:004A1A7E 0E0 33 C0

.text:004A1A80 0E0 5F  
.text:004A1A81 0DC 5E  
.text:004A1A82 0D8 5B  
.text:004A1A83 0D4 81 C4 CC 00 00 00  
.text:004A1A89 008 3B EC  
.text:004A1A8B 008 E8 A5 BE FE FF  
.text:004A1A90 008 8B F5  
.text:004A1A92 -C4 5D  
.text:004A1A93 -C8 C3  
.text:004A1A93

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/1199c721337789c01aa38fdb3f0ff56c029aa36363292ce304bbd563db637ac1.jpg)

# 解决反编译失败问题

- 导致 esp 相对值为正值的原因与前面出现的影响 esp 值的一些指令有关。为了能够恢复其栈平衡，从而能够将程序反编译成 C 伪码，需要消除这种不平衡。  
- 需要分析一下哪些与 esp 操作的指令可能导致栈平衡的破坏  
• 注意到汇编代码中, 每次执行 call 指令前会有若干 push 操作进行参数传递, 完成 call 指令后会有一条 add esp, imm (立即数), 其中 imm 的值与 push 指令的个数有关, 因为每执行一条 push 指令, esp-4 (注意这是 32 位程序), 所以 imm 的值等于  $4^{*} n, n$  为 push 指令的个数

# 解决反编译失败问题

• 注意到，在执行 call sub_48C274 指令后没有对应的 add 指令，但调用前有一条 push 指令，这就会导致破坏栈平衡。  
- 可以在不修改程序文件长度的情况下去掉 push 指令。注意到 push 0 对应的机器码为 16 进制的 6A00，采用 IDA Pro 提供的“补丁”工具将该指令修改为空指令（机器码为  $0 \times 90$ ）

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/94b6268c9a701609b0640dce06fb5f39e1edbf8439d26e4e550d2838341a70de.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/57a4b0741210eaa72f135650fb6037f746167acf62ddda0b81702395a741d581.jpg)

# 解决反编译失败问题

# - 去掉几处 push 指令后，我们发现错误提示消失了

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/03ab30cc7f738a71f87fd7b8f8cb1f5301a37a417b8c9153db171e9471150046.jpg)

# 动态分析

- 如果能够采用动态分析方法对程序行为进行跟踪，在结合静态分析方法能够够提高分析效率，快速地完成分析的目标。

# 选择调试器

- 首先需要在“Debugger”窗口中选择一种调试器，这里我们选择“Local Windows debugger”。  
- 注意，IDA 似乎不支持中文路径下的文件调试，所以需要把需要分析的程序放在英文路径下。

# 跟踪程序

- 我们的目标是要分析“main”函数，如果是能够快速定位到该函数，可以直接在函数内部设置断点。如果不能定位到该函数，就需要从IDA分析出来的入口（start）处设置断点，逐步地进行跟踪。  
- 多数调试器设置断点的方法都差不多，对 IDA 而言，就是在指令左侧的圆点处鼠标左键点击一下，该行指令标红，就表示添加了断点，可以在程序中设置多个断点。  
- 对该示例，我们将断点设置在偏移地址 .text:004A19D8 处，按“F9”或者在“Debugger”菜单中选择“Start process”开始运行程序。

# 跟踪程序

- 对该示例，我们将断点设置在偏移地址 .text:004A19D8 处，按“F9”或者在“Debugger”菜单中选择“Start process”开始运行程序。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/9504ef63-04f5-4cc3-a1e9-7582f4914786/2876eebcefeed0267cbc36c334c6f0206621e0c445b98f98c0dd7f34de498abc.jpg)

# 跟踪程序

• 可以通过快捷键“F7”（可以进入到调用的函数内部）和“F8”（逐条指令执行）对程序进行跟踪。  
- 当我们执行完 .text:001519E2 处的指令 “call sub_13CD46”, 控制台显示 “Please Input:” 的提示, 意味着 sub_13CD46 的作用相当于 printf 或 printf_s;  
• 执行完地址 .text:001519F6 处的 “call sub_13C0EE” 后, 程序停止, 等待输入, 意味着 sub_13C0EE 的作用相当于 scanf 或 scanf_s; 参考前面的分析, 在不知道具体 flag 的时候, 输入 “1234567890”, 回车, 然后执行完指令 “call sub_13A9A6” 后, 观察到 eax 的为 10 (0Ah), 说明 sub_13A9A6 返回的是输入字符串的长度。

# 后记

# 思考

- 本章结合静态和动态分析方法，最终找出了目标程序的 flag。  
- 从学习的角度，还有一个问题，需要搞清楚：函数 sub_49CEB0 是在哪里被调用进而来初始化与 dword_5F3088 进行比较的变量 a2 的？