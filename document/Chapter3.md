# 第3章 汇编语言程序格式

与高级语言源程序的编辑、编译和连接过程类似, 汇编语言程序的开发也是先利用某种编辑器编写汇编语言源程序 (*.asm), 然后经汇编得到目标模块文件 (*.obj), 连接后形成可执行文件 (*.exe)。

一般程序设计语言的源程序除了程序主体外, 还有相应的变量、类型、子程序等说明部分。汇编语言源程序不只是由指令系统中的指令组成, 一般还有存储模型、主存变量、子程序、宏及段定义等很多不产生 CPU 动作的说明性工作, 并在程序执行前由汇编程序完成处理, 这些工作由说明性 (Directive) 语句完成, 又被称为伪指令。与之相对应, 使 CPU 产生动作、并在程序执行时才处理的语句被称为硬指令或真指令。汇编语言源程序中仅有硬指令是不够的, 也不完整, 所以我们需要进一步系统地学习伪指令。

CPU 的指令集是由处理器本身确定的，相应的代码必须在相应系列以上的机器上运行。伪指令则与机器无关，但与汇编程序的版本有关。不同的汇编程序版本所支持的 CPU 指令集和伪指令都可能有所不同。一般来说，汇编程序的版本越高，支持的硬指令越多，具有的伪指令越丰富，功能更加强大。本章以微软宏汇编程序 MASM 6.x 为蓝本，学习汇编语言源程序的格式、常用伪指令与操作符，同时介绍汇编语言源程序的汇编、连接、运行过程，以及它的修改和调试方法。

# 3.1 汇编语言程序的开发

本节从一个示例出发, 说明汇编语言源程序的一般格式以及汇编、连接和调试的全过程,即汇编语言程序的一般开发方法。

# 3.1.1 汇编语言程序的语句格式

像其他程序设计语言一样，汇编语言对其语句格式、程序结构以及开发过程等有相应的要求，它们本质上相同、方法上相似、具体内容各有特色。

汇编语言源程序由语句序列构成, 每条语句一般占一行, 每行不超过 132 个字符 (MASM 6.0 开始可以是 512 个字符)。语句有相似的两种, 一般都由分隔符分成的 4 部分组成。

(1) 执行性语句——表达处理器指令，汇编后对应一条指令代码，格式如下：

标号：处理器指令助记符 操作数，操作数

(2) 说明性语句——表达汇编程序命令，指示如何进行汇编，格式如下：

名字 伪指令助记符 参数，参数， 注释

# 1. 标号与名字

执行性语句中，“:”前的标号表示处理器指令在主存中的逻辑地址，主要用于指示分支、

循环等程序的目的地址, 可有可无。说明性语句中的名字可以是变量名、段名、子程序名等,反映变量、段和子程序等的逻辑地址。标号采用 “:” 分隔处理器指令, 名字采用空格或制表符分隔伪指令, 据此也分开了两种语句。

标号和名字是符合汇编程序语法的用户自定义的标识符（Identifier）。标识符（也称为符号Symbol）一般最多由31个字母、数字及规定的特殊符号（如_、$、?、@）组成，不能以数字开头（与高级程序语言一样）。在一个源程序中，用户定义的每个标识符必须是唯一的，还不能是汇编程序采用的保留字。保留字（Reserved Word）是编程语言本身需要使用的各种具有特定含义的标识符，也被称为关键字（Key Word）；汇编程序中主要有处理器指令助记符、伪指令助记符、操作符、寄存器名以及预定义符号等。

例如，MSG、VAR2、BUF、NEXT、AGAIN是合法的用户自定义标识符，8VAR、AX、MOV、BYTE是不符合语法（非法）的标识符，原因是：8VAR以数字开头，其他是保留字。

在默认情况下, 汇编程序不区别包括保留字在内的标识符字母大小写。换句话说, 汇编语言是大小写不敏感的。例如, 对于寄存器名 AX, 还可以书写成 ax 等。使用 string 变量名,还可以 String、STRING 等形式出现, 它们表达同一个变量。本书在文字说明和语句时通常采用小写字母形式。

# 2. 助记符

助记符（Mnemonics）是帮助记忆指令的符号，反映指令的功能。处理器指令助记符可以是任何一条处理器指令，表示一种处理器操作。同一系列的处理器指令常会增加，不同系列处理器的指令系统不尽相同。伪指令助记符由汇编程序定义，表达一个汇编过程中的命令，随着汇编程序版本增加，伪指令会增加，功能也会增强。例如，程序中使用最多数据传送指令，其助记符是“MOV”。第2章中的处理器指令介绍了对应的助记符。

汇编语言源程序中使用最多的字节变量定义伪指令, 其助记符是 “DB” (或 “BYTE”, 取自 Define Byte), 功能是在主存中分配若干的存储空间, 用于保存变量值, 该变量以字节为单位存取。例如, 可以用 DB 伪指令定义一个字符串, 并使用变量名 STRING 表达其在主存的逻辑地址:

```perl
string db 'Hello, Everybody!', 0dh, 0ah, $$
```

其中, 0DH 和 0AH 表达回车换行 (其作用相当于 C 语言的 “\n”), 字符串最后的一个 “$”是 9 号 DOS 调用要求的字符串结尾字符。

变量名 STRING 包含段基地址和偏移地址, 如可以用一个 MASM 操作符 OFFSET 获得其偏移地址, 保存到 DX 寄存器中, 汇编语言指令如下:

```txt
mov dx, offset string ; DX获得STRING的偏移地址
```

MASM 操作符（Operator）是对常量、变量、地址等进行操作的关键字。例如，进行四则运算的操作符（也称为运算符）与高级语言一样，依次是符号+、-、*和/。

# 3. 操作数和参数

处理器指令的操作数表示参与操作的对象，可以是一个具体的常量，也可以是保存在寄存器的数据，还可以是一个保存在存储器中的变量。在双操作数的指令中，目的操作数写在“,”前，还用来存放指令操作的结果；对应地，“,”后的操作数就称为源操作数。

例如，在指令“MOV DX, OFFSET STRING”中，“DX”是寄存器形式的目的操作数，

“OFFSET STRING” 经汇编后转换为一个具体的偏移地址, 则是常量形式的源操作数。

伪指令的参数可以是常量、变量名、表达式等,可以有多个,参数之间用“,”分隔。例如,在"Hello, Everybody!", 0DH, 0AH, "$" 中,表示字符串"Hello, Everybody!"、“两个常数0DH 和 0AH 以及一个字符 “$”。

# 4. 注释

语句中“;”后的内容是注释, 通常是对指令或程序片断功能的说明, 是为了程序便于阅读而加上的, 不是必须有的。必要时, 一个语句行也可以由 “;” 开始作为阶段性注释。汇编程序在翻译源程序时将跳过该部分, 不对它们做任何处理。建议大家一定要养成书写注释的良好习惯。

语句的 4 个组成部分要用分隔符分开。标号后的 “:”、注释前的 “;” 以及操作数间和参数间的 “,” 都是规定采用的分隔符, 其他部分通常采用空格或制表符作为分隔符。多个空格和制表符的作用与一个相同。另外, MASM 也支持续行符 “\”, 表示本行内容与上一行内容属于同一个语句。注释可以使用英文书写。在支持中文的编辑环境中也可以使用中文进行程序注释, 但注意这些分隔符必须使用英文标点, 否则无法通过汇编。

良好的语句格式有利于编程, 尤其是源程序阅读。在本书的汇编语言源程序中, 标号和名字从首列开始书写, 通过制表符对齐各语句行的助记符, 助记符后用空格分隔操作数和参数部分 (多个操作数和参数, 按照语法要求使用 “,” 分隔), 利用制表符对齐注释部分。

# 3.1.2 汇编语言的源程序框架

汇编程序为汇编语言制定了严格的语法规范，如语句格式、标识符定义、保留字、注释符等。同样，汇编程序也为源程序书写设计了框架结构，包括数据段、代码段等的定义、程序起始执行的位置、汇编结束的标示等。

对应存储空间的分段管理, 用汇编语言编程时常将源程序分成代码段、数据段或堆栈段。需要独立运行的程序必须包含一个代码段, 并指示程序执行的起始位置。需要执行的可执行性语句必须位于某一个代码段内。说明性语句通常安排在数据段, 或根据需要位于其他段。通常, 程序还需要一个堆栈段 (操作系统也会提供默认的堆栈段, 但容量较小)。

下面给出在屏幕上显示一段信息的汇编语言源程序, 分别用两种格式书写。

# 1. 简化段定义的源程序框架

MASM 各版本支持多种汇编语言源程序格式。本书使用 MASM 6.x 版本的简化段定义 (Simplified Segment Definition), 引出一个简单的源程序框架。其典型格式如下:

```txt
.model small ; 定义程序的存储模式 (SMALL 表示小型模式)  
.stack ; 定义堆栈段 (默认是 1KB 空间)  
.data ; 定义数据段  
; 数据定义  
.code ; 定义代码段  
startup ; 程序起始点, 并设置 DS 和 SS 内容  
; 主程序代码  
_exit 0 ; 程序终止点, 返回 DOS (0 是返回值)  
; 子程序代码
```

end

；汇编结束

在简化段定义的源程序格式中，以“.”开始的伪指令说明程序的结构。首先，必须具有存储模型伪指令.MODEL。随后，.STACK、.DATA 和.CODE 依次定义堆栈段、数据段和代码段，一个段的开始自动结束上一个段。在代码段中，首先由 STARTUP 伪指令指明程序的起始执行点，同时为程序的数据段、代码段和堆栈段设置相应的段寄存器值。最后用 EXIT 伪指令返回 DOS 操作系统，程序执行终止（详见 3.3 节）。

# 【例 3.1】信息显示程序。

类似经典的 C 语言程序: 显示 “Hello, Everybody!”, 下面用汇编语言也显示一段信息。首先需要在数据段给出这个字符串, 用字节定义伪指令 DB 实现:

；数据段

string db 'Hello, Everybody!', 0dh, 0ah, '$' ; 定义要显示的字符串

接着，需要在代码段编写显示字符串的程序：

；代码段

```txt
mov dx, offset string ; 指定字符串在数据段的偏移地址  
mov ah, 9  
int 21h ; 利用DOS功能调用显示信息
```

采用简化段定义的源程序框架，只需将数据定义书写在数据段定义伪指令.DATA后，在代码段的 STARTUP 和 EXIT 之间填入程序代码，就形成了一个汇编语言源程序：

```asm
. model small
. stack
. data
string db 'Hello, Everybody!', 0dh, 0ah, '$'
. code
. startup
mov dx, offset string
mov ah, 9
int 21h
. exit 0
end
```

由于 MASM 5.0/5.1 不支持 STARTUP 和 EXIT 伪指令, 如果读者采用 MASM 5.0/5.1 版本的汇编程序, 请将上述例 3.1 的源程序中 3 个标记处的语句分别修改如下:

(注1)

```txt
START: mov ax, @data 设置数据段的段地址 DS
mov ds, ax
```

(注2)

```txt
mov ax, 4c00h ; 返回 DOS  
int 21h
```

(注3)

end start

; 汇编结束, 程序起始点为标号 START 处

除特别说明为 MASM 6.x 新引入的功能外，为适应 MASM 5.0/5.1，本书采用简化段定义格式的源程序都可以修改为这种形式。

# 2. 完整段定义的源程序框架

MASM 5.0 为简化汇编语言编程引入简化段定义，MASM 5.0 以前版本则采用完整段定义。

义（）

<table><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>

这是一个名为XYZ的特定定义集，它于XYZ中么，名为ASSUME伪指令加可以指定  
例如，上述程序中的ASSUME伪指令有CS、DS、SS依次指向名为CODE、DATA。  
STACK思想段，将每次设置它们的代码段，直接指向地址，然后，ASSUME伪指令并不  
与DS区域，而是程序开始先用性选择命令名DS数值为DATA内容地址，这样后续程序可调  
到DATA段中的位置，程序执行停止，利用DOS系统号功能调用返回DOS值  
位  
线，即，页面的值会自动显示END写器程序开始执行位置是START  
口空白的指令，

这师，例31的信自：学书要学文要教文义义义为

<table><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></table>

end start

对比这两种格式的源程序，简化段格式显得简洁明快、易于掌握，引入存储模式更使得程序方便地与其他微软开发工具组合；完整段格式虽显烦琐，但可以提供更多的段属性，有时是必须采用的。3.3节将详细介绍这两种段定义格式。

本章（以及第  $4 \sim 5$  章）例题程序将只给出数据段的变量定义、主程序和子程序代码等部分，而不给出源程序框架（除非与之不同，需要特别表示），以便将注意力集中于编程本身（而不是被烦琐的程序格式所困惑）。读者只要套入源程序框架，就可以编辑成一个汇编语言源程序文件，但本书主要采用简化段定义的源程序框架。

大多数读者是从高级语言开始熟悉计算机程序设计的，虽然汇编语言不是高级语言，但它们都是程序设计语言，有许多本质上相同或相通的地方。所以，学习过程中不妨做些简单对比，这样既可以巩固高级语言的知识，也有利于熟悉汇编语言。通过汇编语言，读者还可以进一步加深对高级语言的理解。

# 3.1.3 汇编语言程序的开发过程

开发汇编语言程序需要编辑、编译（汇编）、连接等步骤，如图 3-1 所示。但首先需要安装开发软件。安装 MASM 6.x 完全版，需要在 DOS（或 Windows 的 MS-DOS 模拟环境）下，运行其 setup.exe 程序实现，通常选择在 MS-DOS/Microsoft Windows 操作系统下使用。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8b40df69-e6a2-4f52-8e5b-e888c9e9fb8e/5e2f78e87d4f90fe91e8a308711c825b5dd8720fdae75725fe529059b2849156.jpg)  
图3-1 可执行文件的开发过程

本书的汇编语言程序开发基于微软公司的MASM 6.x版本，可以采用最后一个独立发布的MASM 6.11版本，还可以升级为MASM 6.15。实践本书编程，主要使用汇编程序ml.exe（及ml.err）和连接程序link.exe等，没有必要安装完整的MASM程序。读者可以自行组建开发环境，建议参考本书的MASM软件包（ml615.zip）如下配置有关文件：

（1）主程序目录（如D:\ML615）配置MASM6.15的基本文件

ml.exe——汇编程序。  
ml.err——汇编错误信息文件。  
link.exe 连接程序。  
$\clubsuit$  lib.exe 子程序库管理文件。

如果使用MASM6.15版本的汇编程序ml.exe（及ml.err），需从Visual  $\mathrm{C} + + 6.0$  中抽取。连接程序link.exe和子程序库管理文件lib.exe则取自MASM6.11版本。

(2) 主目录含有作者创建的文件

dos.bat——进入模拟MS-DOS环境（command.com）的当前目录（如D:\ML615）。

win.bat——进入Windows控制台（cmd.exe）的当前目录（如D:\ML615）。  
- make.bat——生成 CodeView 调试信息的汇编快捷操作批处理文件（用于 SMALL、COMPACT、MEDIUM、LARGE 和 HUGE 存储模式，生成 EXE 文件），进入 CodeView 调试程序的批处理文件 cy.bat 和展开各种帮助文件的批处理文件 qh.bat。  
• example.asm——模板源程序文件（MASM 6.x 适用，简化段定义格式，SMALL 存储模式），并含有模板文件对应的列表文件 example.lst、模块文件 example obj 和可执行文件 example.exe，以方便调试等使用。  
• exampleasm——模板源程序文件（MASM 5.x/6.x 适用，完整段定义格式）。  
• exampleb.asm——模板源程序文件（MASM 5.x 适用，简化段定义格式，SMALL 存储模式）。  
• examplec.asm——模板源程序文件（MASM 6.x 适用，简化段定义格式，TINY 存储模式）。  
• `exampleled.asm——模板源程序文件（MASM 6.x 适用，32 位 Windows 应用程序）》。  
$\diamond$  io. inc—I/O 子程序库声明文件。  
io.lib-I/O子程序库。

# （3）HELP目录

HELP 目录下包括: 快速帮助文件 qh.exe, 以及 MASM 宏汇编语言、汇编程序 ML、连接程序 LINK、调试程序 CV 等帮助文件。

(4) BIN32 子目录配置 32 位汇编语言开发文件

• link exe——连接程序（与 DOS 环境的连接程序不同）。  
$\Lsh$  kernel32.lib——Windows核心导入库文件。  
$\text{念}$  user32.lib——Windows用户界面导入库文件。  
mspdb60.dll 和 msdis110.dll——动态连接库。

BIN32子目录的文件需抽取自Visual  $\mathrm{C} + + 6.0$  ，用于配合32位Windows汇编语言程序（见第6章）的开发。

有了上述 MASM 软件开发包，在 32 位 Windows 操作系统的资源管理器中双击其中的批处理文件 dos.bat（或 win.bat），就可以打开模拟 MS-DOS 窗口（控制台），并进入主目录 (D:\ML615)。接着，在提示符下输入命令：

ML 文件名.assistant

即可快速完成一个汇编语言程序的开发。注意：用户编写的源程序应该保存在主目录下进行汇编连接，开发完成后可以再保存在其他目录（如progs子目录保存本书的例题程序）。

当然，程序的开发实际上包括编辑、汇编（编译）和连接等步骤，详述如下。

# 1. 进入模拟 DOS 环境

MASM 以 MS-DOS 操作系统为平台。DOS 虽然相对比较简单，但允许程序员访问任意资源，便于实践和实现，符合本课程的教学要求。读者可以使用 MS-DOS 启动机器运行于实地址方式，但作者建议使用 32 位 Windows 的模拟 MS-DOS 环境。模拟 DOS 环境虽不是真正的 DOS 平台，但兼容绝大多数 DOS 应用程序，完全满足我们的教学，同时可以借助 Windows 的强大功能和良好保护。

在Windows操作系统的图形界面下，需要首先进入模拟DOS环境，通常的操作方法是：

选择“开始”  $\rightarrow$  “运行”，在打开的对话框中输入“command”命令。注意，模拟DOS环境执行的是Windows所在文件夹的SYSTEM32子文件夹下的command.com文件。打开的窗口标题中包含“Command Prompt”或“command.com”。所以，为了避免与其他同名文件混淆，建立DOS模拟环境时最好给出完整的路径，如输入“%SystemRoot%\system32\command.com”。其中，“%SystemRoot%”表示Windows操作系统所在文件夹（如Windows/7为WINDOWS，Windows2000为WINNT）。

通常, 人们习惯用鼠标单击来逐步展开 “开始”  $\rightarrow$  “程序”  $\rightarrow$  “附件”  $\rightarrow$  “命令提示符”,或者选择 “开始”  $\rightarrow$  “运行”, 在弹出的对话框中输入 “cmd” 命令, 打开一个酷似 DOS 的命令行窗口, 实际上是 32 位 Windows 的控制台窗口, 执行 Windows 所在文件夹 SYSTEM32 子文件夹下的 cmd.exe 文件。虽然 32 位控制台与模拟 DOS 环境的基本功能、操作和界面一致, 但执行的文件不同, 其实质不同。相对来说, cmd.exe 支持中文的输入和输出, 功能更强, 打开的窗口标题包含 “命令提示符” 或 “cmd.exe”。

特别注意, 本书主要的应用程序基于 MS-DOS 模拟环境 (command.com), 不要在 32 位控制台环境 (cmd.exe) 下运行, 虽然很多时候是正确的。这是因为, 利用 DOS 功能调用编写的程序虽然可以在 32 位控制台环境下执行, 但不保证一定正确; 同样, 使用 32 位控制台 API 函数编写的程序也不保证一定在模拟 DOS 环境下执行正确。

# 2. 进入MASM开发目录

操作系统以目录（Directory）形式管理磁盘上的文件（Windows 为了使普通用户容易理解，使用了文件夹这个通俗的说法表示专业术语目录）。当我们指明某个文件时，为了区别于同名的其他文件，有必要说明该文件所在分区、根目录、各级子目录。上述分区和目录就是该文件的路径（Path），DOS 中利用“\”分隔各级目录。例如，在硬盘 D 分区根目录 ML615 的 PROGS 子目录下的文件 LT301.ASM，需要表示如下：

```batch
D:\ML615\PROGS\lt301.asm
```

文件的完整路径称为 “绝对路径”。这种指明文件的方法保证了唯一性, 但有些烦琐,所以经常使用 “相对路径” 指明文件。采用相对路径首先必须明确相对的位置, 即当前所在的目录, 简称当前目录 (Current Directory)。实际上, 在闪烁的 DOS 提示符 “_” 前的路径就是当前目录所在位置。假如, D 分区当前目录是根目录 ML615, 则指明上述 lt301.asm 文件可以表示如下:

```batch
PROGS\1t301.asm
```

再如，PROGS 为当前目录，指明 ML615 目录下的 ml.exe 文件表示如下：

```txt
..ml.exe
```

这里的“.”表示当前目录的上级目录。另外，经常使用“\”表示当前分区的根目录，用一个“.”表示当前目录。

那么, DOS 下如何改变当前目录呢? 这就要用到 DOS 内部命令 CD (Change Directory)。例如, 进入模拟 DOS 后, 可以首先输入分区字母加一个 “:”, 从而进入需要的当前磁盘分区, 然后输入 CD 命令, 并用空格隔开需要进入的当前目录。

D;

```txt
CD \ml615
```

为了操作方便，可以定制一个进入 MASM 目录（假设在 D:\ML615）的 MS-DOS 快捷

方式。以 Windows XP 操作系统为例，只要新建一个快捷方式，让其执行 command.com 文件，并展开其属性中的程序对话框，将“工作目录”文本框改为“D:\ML615”。双击这个快捷方式，就直接进入了 MS-DOS 环境的“D:\ML615”目录。

在本书建议的软件包中有一个批处理文件 dos.bat，在资源管理器下双击之，也能启动模拟 DOS 环境，并快速进入 MASM 目录。批处理文件 DOS.BAT 的内容可以是：

```batch
@echo off  
%SystemRoot%\system32\command.com  
@echo on
```

第 1 行命令表示不显示下面各行信息。第 2 行执行操作系统所在根目录提供的 command.com 文件进入模拟 DOS 环境窗口，并将 dos.bat 文件所在的目录（默认是 D:\ML615）作为当前目录。第 3 行命令表示以后输入的命令将显示出来。

最后说明在 64 位 Windows 操作系统下如何开发和运行 16 位 DOS 应用程序。在使用 64 位 Windows 操作系统的计算机中, 虽然仍然存在控制台窗口, 但也是 64 位的, 执行的程序名称还是 cmd.exe, 兼容 32 位应用程序。64 位 Windows 不兼容 16 位 DOS 应用程序, 所以操作系统中不存在 command.com 文件。运行 16 位 DOS 应用程序需要使用虚拟机软件模拟 DOS 环境, 如简单的 DOSBox 模拟器 (免费软件) 或者功能强大的 VMware 虚拟机 (商业软件)。在 64 位 Windows 操作系统平台, 开发和运行 16 位 DOS 应用程序的具体建议如下:

(1) 16 位汇编语言程序的开发可以进入 64 位 Windows 控制台窗口进行。使用批处理文件 win.bat 启动控制台窗口、并进入该文件所在的当前目录。win.bat 文件只是将 dos.bat 文件中的 command.com 用 cmd.exe 替代即可。  
(2) 16 位汇编语言程序的运行可以进入 DOSBox 模拟器中进行。下载最新 DOSBox 软件 (目前是 0.74 版), 请访问 DOSBox 官网 www.dosbox.com, Windows 环境对应的安装软件是 DOSBox0.74-win32-installer.exe。安装后, 所在目录包含使用手册等文档。启动 DOSBox 后,可以使用挂接命令 MOUNT 将机器上某个分区目录装载到模拟 DOS 中使用, 如

```txt
MOUNT D: D:\ML615  
D:
```

这两个命令将 D:\ML615 挂接在模拟 DOS 的 D 分区, 然后进入 D 分区。此时可以执行 DOS 命令 (如 CD、DIR 等命令) 以及 D:\ML615 目录下的可执行文件。

如果希望每次启动 DOSBox, 自动运行挂接命令, 可以依次选择 “开始” → “程序” → “DOSBox-0.74” → “Options” → “DOSBox 0.74 Options” (即打开 DOSBox 配置文件, 是用户计算机的本地应用程序数据目录 DOSBox\dosbox-0.74.conf 文件), 将上述两个命令复制到配置文件的最后 [autoexec] 字段, 然后保存即可。

注意: DOSBox 是 DOS 模拟器, 不支持中文目录名和文件名; 64 位 Windows 中没有调试程序 debug.exe, 需事先在汇编语言主目录复制好该文件; 如果希望在 DOSBox 模拟器中开发 16 位 DOS 应用程序 (不仅仅是运行), 需要使用 MASM 6.11 版本的汇编程序 (ml.exe), 因为 DOSBox 不支持 MASM 6.15 的汇编程序。

# 3. 源程序的编辑

源程序文件的形成（编辑）可以通过任何一个文本编辑器，当然功能完善的编辑软件会提高编程效率。例如，可以使用Windows提供的记事本（Notepad）、DOS中的全屏幕文本

编辑器 EDIT 甚至 Microsoft Word, 也可以使用其他程序开发工具中的编辑环境, 如 Visual C++ 或 Turbo C 的编辑器。一些专注于各种源程序文件编写的文本编辑软件也非常好用, 值得推荐, 如 UltraEdit32。

本书推荐使用记事本 notepad2.exe。建议在其“设置”菜单中使用“文件关联”命令将汇编语言程序 ASM 文件与其建立关联（以后双击 ASM 程序就可以打开该记事本），还可以在“查看”菜单中选择使用汇编程序语法高亮方案和语法高亮配置（便于区别助记符、数据等）。另外，在“查看”菜单选中“行号”，这样记事本可以给程序标示行号，以便出现错误时能够根据提示的行号快速定位到错误语句。

源程序文件是无格式文本文件，注意保存为纯文本类型，MASM 要求其源程序文件要以 ASM 为扩展名。

任何一个编辑器的使用方法都大致相同，这里不再叙述。假定用户已经正确地将例 3.1 的源程序输入编辑器（注释部分不需录入），并以 lt301.asm 为文件名存入 MASM 目录中。

为了便于操作, 应将源程序文件保存在 ML615 目录下, 开发过程中生成的各种文件也自然存放于此, 以避免指明文件路径的麻烦和出现找不到文件的错误。开发完成后的程序可以移动到另一个目录下保存。为了便于管理, 本书中的源程序文件的命名规则是: lt 表示例题, xt 表示习题, 第 1 位数字表示程序所在章号, 后 2 位数字表示例题或习题序号, 数字后的字母表示同一个程序的不同形式。

# 4. 源程序的汇编

汇编是将源程序翻译成由机器代码组成的目标模块文件的过程。MASM 6.x 提供的汇编程序是 ml.exe。进入已建立的程序所在目录，输入如下命令及相应参数，即可完成源程序的汇编：

```batch
ML /c lt301.asm
```

如果源程序中没有语法错误，MASM 将自动生成一个目标模块文件（lt301 obj），否则给出相应的错误信息。这时应根据错误信息，重新编辑修改源程序后，再进行汇编。注意，仅利用 ML 实现源程序的汇编，参数 “/c”（小写字母 c）不能省略，否则 ML 将自动调用连接程序 link.exe 进行连接。

# 5. 目标文件的连接

连接程序能把一个或多个目标文件和库文件合成一个可执行文件（EXE、COM 文件）。

在程序目录下有了 lt301 obj 文件, 输入如下命令可实现目标文件的连接:

```txt
LINK lt301 obj
```

如果不带文件名, 连接程序 LINK 将提示输入 OBJ 文件名, 还会提示生成的可执行文件名及列表文件名, 一般采用默认文件名就可以。如果没有严重错误, LINK 将生成一个可执行文件 (lt301.exe), 否则提示相应的错误信息。这时需要根据错误信息重新修改源程序后再汇编、链接, 直到生成可执行文件。

连接程序的一般格式如下：

```txt
LINK [/参数选项] OBJ 文件列表 [EXE 文件名, MAP 文件名, 库文件][; ]
```

连接程序可以将多个模块文件连接起来，形成一个可执行文件；多个模块文件用“+”分隔。给出 EXE 文件名就可以替代与第一个模块文件名相同的默认名。给出 MAP 文件名将创建连接映像文件，否则不生成映像文件。库文件是指连接程序需要的子程序库等。“[ ]”

中的文件名是可选的，如果没有给出，则连接程序还将提示，通常用回车表示接受默认为避免频繁的键盘操作，可以用“:”表示采用默认名，连接程序就不再提示输入内容。参数可以显示LINK的所有参数选项。

事实上，ML汇编程序可以自动调用LINK连接程序（ML表示MASM和LINK），汇编和连接的依次进行，只要在命令行中输入不带“/c”参数的ML命令即可。例如：

```batch
ML1t301.asm
```

上面介绍了通常采用的ML命令行格式。实际上，汇编程序ml.exe可以使用其他参用“?”或“/help”选项可以看到它的所有参数。ml.exe的命令行格式如下：

```txt
ML [/参数选项]文件列表 [/LINK 连接参数选项]
```

ML允许汇编和连接多个程序形成一个可执行文件，常用参数选项如下（注意，参考小写敏感的）：

AT—允许TINY存储模型（创建一个COM文件）。  
只汇编源程序，不进行自动连接（这里是小写的字母c）。  
F1文件名——创建一个汇编列表文件（扩展名.1st）。  
$\diamond$  Fr文件名——创建一个可在PWB下浏览的SBR源浏览文件。  
$\diamond$  Fo文件名——根据指定的文件名生成模块文件，而不是采用默认名。  
$\Leftrightarrow$  Fe文件名——根据指定的文件名生成可执行文件，而不是采用默认名。  
Fm文件名——创建一个连接映像文件（扩展名.map）。  
路径名——设置需要包含进（INCLUDE）源程序的文件的所在路径。  
$\downarrow / \mathrm{Sa}$  ——在生成的列表文件中，列出由汇编程序产生的指令。  
Sn 在创建列表文件时不产生符号表。  
Zi—生成模块文件时，加入调试程序 CodeView 需要的信息。  
$\diamondsuit$  Zs——只进行句法检查，不产生任何代码。  
Link——传递给连接程序LINK的参数。

# 6. 列表文件

列表文件（List File）是一种文本文件，含有源程序和目标代码，对学习汇编语言进行设计和发现错误很有用。创建列表文件，可以输入如下命令：

```txt
ML/F1/5a lt301.asm
```

该命令除产生模块文件 lt301 obj 和可执行文件 lt301.exe 外，还将生成列表文件 lt301.lst 用“/Sa”选项，如果源程序具有 startup、.exit 伪指令及流程控制伪指令.if、.while 等，列表文件中得到相应的硬指令，否则列表文件只给出上述伪指令。lt301.lst 如下所示：

```csv
1021.aa
Page 1-1
model small
stack
0900 data
0900 48 65 6C 6C 6F 2C 45 76 string db 'Hello,Everybody!',0dh,0ah,
65 72 79 62 6F 6A
79 2B 21 6D 8A 2A
0900 code
startup
: startup
```

<table><tr><td>0000</td><td>BA----R *</td><td>mov</td><td colspan="3">dx, dgroup</td><td></td></tr><tr><td>0003</td><td>8EDA *</td><td>mov</td><td colspan="3">ds, dx</td><td></td></tr><tr><td>0005</td><td>8CD3 *</td><td>mov</td><td colspan="3">bx, ss</td><td></td></tr><tr><td>0007</td><td>2BDA *</td><td>sub</td><td colspan="3">bx, dx</td><td></td></tr><tr><td>0009</td><td>D1E3 *</td><td>shl</td><td colspan="3">bx, 001h</td><td></td></tr><tr><td>000B</td><td>D1E3 *</td><td>shl</td><td colspan="3">bx, 001h</td><td></td></tr><tr><td>000D</td><td>D1E3 *</td><td>shl</td><td colspan="3">bx, 001h</td><td></td></tr><tr><td>000F</td><td>D1E3 *</td><td>shl</td><td colspan="3">bx, 001h</td><td></td></tr><tr><td>0011</td><td>FA *</td><td>cli</td><td colspan="3"></td><td></td></tr><tr><td>0012</td><td>8ED2 *</td><td>mov</td><td colspan="3">ss, dx</td><td></td></tr><tr><td>0014</td><td>03E3 *</td><td>add</td><td colspan="3">sp, bx</td><td></td></tr><tr><td>0016</td><td>FB *</td><td>sti</td><td colspan="3"></td><td></td></tr><tr><td>0017</td><td>BA0000R</td><td>mov</td><td colspan="3">dx, offset string</td><td></td></tr><tr><td>001A</td><td>B409</td><td>mov</td><td colspan="3">ah, 9</td><td></td></tr><tr><td>001C</td><td>CD21</td><td>int</td><td colspan="3">21h</td><td></td></tr><tr><td></td><td></td><td colspan="4">exit 0</td><td></td></tr><tr><td>001E</td><td>B84C00 *</td><td>mov</td><td colspan="3">ax, 04c00h</td><td></td></tr><tr><td>0021</td><td>CD21 *</td><td>int</td><td colspan="3">021h</td><td></td></tr><tr><td></td><td></td><td colspan="4">end</td><td></td></tr><tr><td>LT301.ASM</td><td colspan="5">Symbols2-1</td><td></td></tr><tr><td colspan="6">Segments and Groups:</td><td></td></tr><tr><td colspan="2">Name</td><td>Size</td><td>Length</td><td>Align</td><td>Combine</td><td>Class</td></tr><tr><td colspan="2">DGROUP.</td><td>GROUP</td><td></td><td></td><td></td><td></td></tr><tr><td colspan="2">_DATA.</td><td>16Bit</td><td>0014</td><td>Word</td><td>Public</td><td>&#x27;DATA&#x27;</td></tr><tr><td colspan="2">STACK.</td><td>16Bit</td><td>0400</td><td>Para</td><td>Stack</td><td>&#x27;STACK&#x27;</td></tr><tr><td colspan="2">.Text.</td><td>16Bit</td><td>0023</td><td>Word</td><td>Public</td><td>&#x27;CODE&#x27;</td></tr><tr><td colspan="7">Symbols:</td></tr><tr><td colspan="2">Name</td><td>Type</td><td>Value</td><td>Attr</td><td></td><td></td></tr><tr><td colspan="2">@CodeSize.</td><td>Number</td><td>0000h</td><td></td><td></td><td></td></tr><tr><td colspan="2">@DataSize.</td><td>Number</td><td>0000h</td><td></td><td></td><td></td></tr><tr><td colspan="2">@Interface.</td><td>Number</td><td>0000h</td><td></td><td></td><td></td></tr><tr><td colspan="2">@Model.</td><td>Number</td><td>0002h</td><td></td><td></td><td></td></tr><tr><td colspan="2">@Startup.</td><td>LNear</td><td>0000</td><td>&#x27;_TEXT</td><td></td><td></td></tr><tr><td colspan="2">@code.</td><td>Text</td><td></td><td>&#x27;_TEXT</td><td></td><td></td></tr><tr><td colspan="2">@data.</td><td>Text</td><td></td><td>DGROUP</td><td></td><td></td></tr><tr><td colspan="2">@fardata? .</td><td>Text</td><td></td><td>FAR_BSS</td><td></td><td></td></tr><tr><td colspan="2">@fardata.</td><td>Text</td><td></td><td>FAR_DATA</td><td></td><td></td></tr><tr><td colspan="2">@stack.</td><td>Text</td><td></td><td>DGROUP</td><td></td><td></td></tr><tr><td colspan="2">string.</td><td>Byte</td><td>0000</td><td>&#x27;_DATA</td><td></td><td></td></tr><tr><td colspan="2">0Warnings</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td colspan="2">0 Errors</td><td></td><td></td><td></td><td></td><td></td></tr></table>

列表文件有两部分内容。在第一部分中, 最左列是数据或指令在该段从 0 开始的相对偏移地址, 向右依次是指令的机器代码和汇编语言语句。机器代码后有字母 “R” 表示该指令的立即数/位移量现在不能确定或只是相对地址, 将在程序连接或进入主存时才能定位。带有符号 “*” 的处理器指令是由前面一条伪指令产生的, 采用 “/Sa” 选项的列表文件罗列,否则只有伪指令本身。如果程序中有错误 (Error) 或警告 (Warning), 也会在相应位置提示。

列表文件的第二部分是标识符使用情况。对段名和组名给出它们的名字（Name）、尺寸（Size）、长度（Length）、定位（Align）、组合（Combine）和类别（Class）属性；对符号给出它们的名字、类型（Type）、数值（Value）和属性（Attr）。采用简化段定义格式，有许多汇编系统的预定义标识符，如“@data”等。

另外，汇编连接过程中也可以生成映像文件（MapFile）。

映像文件也是一种文本文件，含有每个段在存储器中的分配情况。创建映像文件可以输入如下命令：

ML /Fm lt301.asm

该命令除产生 lt301 obj 和 lt301.exe 文件外，还将生成映像文件 lt301a.map，如下所示：

```txt
Start Stop Length Name Class  
00000H 00022H 00023H _TEXT CODE  
00024H 00037H 00014H DATA DATA  
00040H 0043FH 00400H STACK STACK  
Origin Group  
0002: 0 DGROUP  
Address Publics by Name  
Address Publics by Value  
Program entry point at 0000: 0000
```

映像文件中先给出了该程序各逻辑段的起点（Start）、终点（Stop）、长度（Length）、段名（Name）和类别（Class），然后是段组（Group）位置和组名，最后提示程序开始执行的逻辑地址。注意，这里的起点、终点和段地址是以该程序文件开头而言的相对地址，而实际的绝对地址需要在程序进入主存后确定。

由于涉及变量、标号和逻辑段属性等内容（本章后续部分将逐渐展开），读者可以在学习相关内容后再回头阅读并理解列表文件和映像文件的含义。

# 7. 可执行程序的运行

开发结束生成的可执行文件是 DOS 的一个应用程序，像 DOS 的外部命令一样在 DOS 环境输入文件名就可以运行。注意，在 Windows 下双击该文件运行，可能看不到运行结果，屏幕上只是一闪。所以，在 Windows 图形界面下，运行模拟 DOS 环境（或 Windows 控制台）的可执行文件，需要首先进入模拟 DOS（或控制台）环境，然后在命令行提示符下输入文件名（可以省略扩展名），按 Enter 键：

1t301.exe

DOS 的命令分成内部命令和外部命令。DOS 的内部命令随着 DOS 启动进入主存, 所以进入 DOS 环境后, 只要输入 DOS 内部命令的关键字加上需要的参数, 就可以直接使用 DOS 的内部命令, 如改变目录 CD、文件列表 DIR、文件拷贝 COPY、清除屏幕 CLS、中止 DOS 环境 EXIT 等常用命令。利用帮助命令 HELP 可以查看所有的内部命令和使用方法, 也可以用命令加 “/?” 参数查询该命令的使用方法。

DOS 的外部命名以文件形式保存在磁盘上，当需要执行这些文件时，需要先输入绝对路径或相对路径，然后输入文件名；其次，用空格分隔输入的参数。如果没有指明路径，DOS 将在当前目录下查找该文件；如果没有找到，则在事先设置的搜索路径中依次找到；如果仍然没有找到，则将显示“XX”不是内部或外部命令，也不是可运行的程序或批处理文

件”（'XX' is not recognized as an internal or external command, operable program or batch file.）。使用内部命令 PATH 可以查看和设置当前的搜索路径。所以，如果指明的路径不正确，虽然文件存在但却会提示没有，或者执行了另外一个同名的文件。

DOS 支持扩展名为 .com 和 .exe 的可执行文件格式。批处理文件使用扩展名 .bat, 实际上是纯文本文件, 其中编辑有依次执行的可执行文件名。如果执行 DOS 外部命令时没有输入扩展名, 则 DOS 依次以 .bat、.com 和 .exe 为扩展名, 先查找到哪个文件, 就执行哪个文件。

# 8. 可执行程序的调试

初学编程, 难免会出现各种错误。首先遇到的问题, 可能是汇编 (编译) 不过、提示各种错误 (Error) 或警告 (Warning) 信息, 这是因为书写了不符合语法规则的语句, 导致汇编 (编译) 程序无法翻译, 称为语法错。常见的语法错误原因有符号拼写错误、多余的空格、遗忘的后缀字母或前导 0、不正确的标点、太过复杂的常量或表达式等。初学者也常因为未能熟练掌握指令功能, 导致操作数类型不匹配、错用寄存器等原因出现指令的语法错误, 当然还会因为算法流程、非法地址等出现逻辑错误或者运行错误。根据提示的语句行号和错误原因可以进行修改。注意, 汇编 (编译) 程序只能发现语法错误, 而且提示的错误信息有时不甚准确, 尤其当多种错误同时出现时。应特别留心第一个引起错误的指令, 因为后续错误可能因其产生, 修改了这个错误, 就可能纠正了后续错误。

程序如果有错误，可以通过阅读源程序、查看列表文件等进行静态排错。对于难以发现的逻辑错误和运行错误，常常需要在调试程序下执行程序，通过程序的动态执行过程发现错误，即动态排错。学习过程中，利用调试程序可以比较直观地查看指令的功能和程序执行过程。在软件开发环境中，调试程序是不可或缺的一部分，实际应用中多用于排除难以发现的运行错误，尤其是底层汇编语言级的调试程序。

MS-DOS 提供 debug.exe 调试程序, 本书前 5 章内容主要针对 8086 指令系统, 可以使用 DEBUG 调试程序。但 DEBUG 功能简单, 只支持 16 位 8086 微处理器的整数指令和 8087 协处理器的浮点指令, 不支持源程序级的调试。因此, 附录 B 介绍了 MASM 配套的源代码调试程序 CodeView 4.10, 可用于调试具有 32 位指令的 DOS 应用程序, 以及进行源程序级调试。从第 3 章开始的源程序都可以利用 CodeView 进行调试, 第  $1 \sim 2$  章的指令学习也可以利用 CodeView, 只是比 DEBUG 略麻烦。

为了让调试程序方便进行源程序级调试，汇编时需要增加参数“/Zi”，连接命令增加参数“/CO”。为了方便操作，本书软件包中编辑有一个批处理文件make.bat，已经将汇编和连接以及需要参数事先设置好，文件内容如下：

```batch
@echo off
rem make.bat,for assembling and linking 16-bit programs (.exe)
ml /c / F1/ Sa /Zi %1.asm
if errorlevel 1 goto terminate
    link/CO % 1,obj;
if errorlevel 1 goto terminate
    dir % 1.*;
;terminate
@echo on
```

REM 开头表示这是一个注释行。汇编和连接命令中使用 “%1” 代表输入的第一个文件

名（扩展名已经表示出来，所以不需要输入英文句号及扩展名）。汇编和连接过程中没有错误，将在当前目录生成列表文件、目标文件和可执行文件等文件，并使用文件列表DIR命令进行了显示。如果汇编或连接有错误，“if-goto”命令将跳转到 terminate位置，结束处理。

# 3.1.4 DOS系统功能调用

使用编程语言进行程序设计，程序员需要利用其开发环境提供的各种功能，如函数、程序库。如果这些功能无法满足程序员的要求，还可以直接利用操作系统提供的程序库，否则只有自己编写特定的程序。汇编语言作为一种低级程序设计语言，汇编程序通常并没有为其提供任何函数或程序库，所以必须利用操作系统的编程资源。显然，这是进行程序设计尤其是采用汇编语言进行程序设计必须掌握的一个重要方面。DOS（和ROM-BIOS）提供给程序员的编程资源是以中断调用方法使用的各种子程序，Windows则以应用程序接口API形式提供动态连接库DLL。

中断是一种增强处理器功能的机制，中断调用是借助中断机制改变程序执行顺序的方法。类似汇编语言的子程序调用（对应高级语言的函数调用）。8086 CPU 支持 256 个中断，每个中断用中断编号区别，即中断 0～中断 255。中断调用指令“INT I8”实现调用 I8 号中断服务程序的功能。DOS 系统主要分配 21H 号中断，用于程序员调用 DOS 操作系统功能。

调用DOS操作系统（和ROM-BIOS）功能的一般方法如下：

① 在AH寄存器中设置系统功能调用号，说明选择的功能。  
② 在指定寄存器中设置入口参数，以便按照要求执行功能。  
(3) 用中断调用指令 “INT  $21 \mathrm{H}$ ” (或 ROM-BIOS 的中断类型号) 执行功能调用。  
④ 根据出口参数分析功能调用执行情况。

实际上, 这类似汇编语言调用子程序 (或高级语言调用函数) 的一般步骤。根据功能不同, 有些没有入口参数或出口参数, 有些入口参数或出口参数可能较复杂, 并且可能有特殊要求。表 3-1 列出了本书主要使用的基本 DOS 功能调用。

表 3-1 DOS 基本功能调用 (INT 21H)  

<table><tr><td>子功能号</td><td>功能</td><td>入口参数</td><td>出口参数</td></tr><tr><td>AH=0FH</td><td>从标准输入设备输入一个字符</td><td></td><td>AL=输入字符的 ASCII 码</td></tr><tr><td>AH=02H</td><td>向标准输出设备输出一个字符</td><td>DL=字符的 ASCII 码</td><td></td></tr><tr><td>AH=09H</td><td>向标准输出设备输出一个字符串</td><td>DS:DX=字符串地址</td><td></td></tr><tr><td>AH=0AH</td><td>从标准输入设备输入一个字符串</td><td>DS:DX=缓冲区地址</td><td></td></tr><tr><td>AH=0BH</td><td>判断键盘是否有键按下</td><td></td><td>AL=0,无; AL=FFH,有</td></tr><tr><td>AH=4CH</td><td>程序执行终止</td><td>AL=返回代码</td><td></td></tr></table>

# 1.字符输出（02H号DOS功能）

该功能执行后，会在显示器当前光标位置显示给定的字符，且光标右移一个字符位置。例如，用02H号DOS系统功能调用在显示器输出一个字符：

mov ah, 82h (1) 设置功能号：ah←02h  
mov d1, 3 （2）提供入口参数：d1←‘?’（引号表示字符的ASCII码）  
int 21n (3) DOS 功能调用：显示

进行字符输出时，当提供响铃字符（ASCII码为07H）、退格字符（08H）、回车字符（0DH）

和换行字符（0AH）时，这个功能调用可以自动识别并能进行相应处理；按 Ctrl+Break 或 Ctrl+C 组合键，则退出。

# 2. 字符串输出（09H号DOS功能）

使用 09H 号 DOS 功能要事先将欲显示的字符串保存在主存, 设置入口参数 DS:DX 等于该字符串在主存中的首地址, 注意字符串必须应以 '$' (24H) 结束, 可以输出回车 (ODH) 和换行 (OAH) 字符产生回车和换行的作用。

例如，用 09H 号 DOS 系统功能调用在显示器输出一个字符串：

```txt
string db 'Hello, Everybody!', 0dh, 0ah, '$' ; 在数据段定义要显示的字符串
mov ah, 09h ; (1) 设置功能号: AH←09H
mov dx, offset string ; (2) 提供入口参数: DX←字符串的偏移地址
int 21h ; (3) DOS 功能调用: 显示
```

# 3. 字符输入（01H号DOS功能）

调用此 DOS 功能时, 若无键按下, 则会一直等待, 直到按键后才读取该键值, 并使用 AL 保存出口参数、即输入字符的 ASCII 编码。例如, 判断按键是 Y 还是 N (大写):

```txt
getkey: mov ah, 1 ; (1) 设置功能号：AH←01H  
int 21h ; (3) DOS 功能调用：等待按键  
cmp al, 'y' ; (4) 分析出口参数：AL←按键的 ASCII 码  
je yeskey ; 是 Y?  
cmp al, 'n'  
je nokey ; 是 N?  
jne getkey ; 不是 Y 或 N，继续输入
```

# 4. 字符串输入（0AH号DOS功能）

使用 OAH 号 DOS 功能要事先在主存设置用于保存输入字符串的缓冲区，并严格按照如下要求：缓冲区第 1 字节事先填入最多欲接收的字符个数（包括回车符，可以是  $1 \sim 255$ ），第 2 字节将存放实际输入的字符个数（不包括回车符），从第 3 字节开始存放输入的字符串。实际输入的字符数多于定义数时，多出的字符被丢掉。注意，扩展 ASCII 码（如功能键等）占两个字节，第 1 个为 0。

执行该功能调用时，用户按键，最后回车确认。本调用可执行全部标准键盘编辑命令；用户按回车键结束输入，如按 Ctrl+Break 或 Ctrl+C 组合键，则中止。

例如，用 0AH 号 DOS 系统功能调用从键盘输入一个字符串：

```txt
buffer db 81 ; 定义缓冲区，第1字节填入可能输入的最大字符数  
db 0 ; 第2字节将用于存放实际输入的字符数  
db 81 dup (0) ; 第3字节开始用于存放输入的字符串  
...  
mov ah, 0ah ; (1)设置功能号：ah←0ah  
mov dx, seg buffer ; (2)提供入口参数：伪指令seg取得buffer的段地址  
mov ds, dx ; 设置数据段ds（若程序在此之前已设定，此处可省去）  
mov dx, offset buffer  
int 21h ; (3)DOS功能调用：等待按键，并回车确认
```

# 5. 按键判断（OBH号DOS功能）

按键判断功能仅判断当前是否有按下的键, 设置出口参数 AL 后退出。如果  $\mathrm{{AL}} = 0$  ,说明当前没有按键；如果  $\mathrm{{AL}} = \mathrm{{FFH}}$  ,说明当前已经按键。

例如，按任意键继续的程序片段：

... 提示“按任意键继续”
getkey: mov ah, 0bh (1) 设置功能号：AH←0BH
int 21h (3) DOS 功能调用：判断按键否
or al, al (4) 分析出口参数：AL=0?
jz getkey ; AL=0，没有按键，继续等待

按键判断功能调用不循环等待按键, 即使有键按下, 缓冲区仍然保留键值并且没有被清空, 必要时必须用字符输入功能取走键值, 清空键盘缓冲区。

说明, 程序运行需要与用户进行交互, 但操作系统往往只提供对字符 (串) 的输入输出,不能直接实现诸如十进制、十六进制等数据形式的输入或输出。为此, 本书作者精心编制了一个输入/输出子程序库 io.lib, 配合一个声明文件 io.inc。汇编语言程序员只要利用源文件包含伪指令 INCLUDE 声明, 并将这两个文件复制在当前目录下, 就可以使用子程序调用指令CALL 调用其中的子程序, 执行其功能, 详见附录 F。

# 3.2 参数、变量和标号

前面通过一个简单的示例, 给出了汇编语言源程序的一般格式, 下面详细讨论它的每一部分。本节学习的主要是语句中的名字 (主要是变量名)、标号、参数 (包括操作数) 部分,并引出相关的伪指令和运算符。

# 3.2.1 数值型参数

在源程序语句格式的 4 个组成部分中, 参数是指令的操作对象 (在学习硬指令时被称为操作数), 参数之间用 “,” 分隔。参数根据指令不同可以没有, 可以有 1 个、2 个或多个。在汇编语言程序中, 指令参数有数值型, 其主要形式是常数和数值表达式; 指令参数还有地址型, 主要形式是标号和名字 (变量名、段名、过程名等)。硬指令的操作数有立即数、寄存器和存储单元。其中, 立即数要用数值型参数表达, 存储单元应该用地址型参数 (存储器操作数) 表达。

# 1. 常数

常数（常量）表示一个固定的数值，又分为如下几种形式。

(1) 十进制常数——由  $0 \sim 9$  数字组成, 以字母 D 或 d 结尾; 在默认情况下, 后缀可以省略, 如 100、255D。汇编语言对大小写不敏感, D 和 d 通用, 下同。  
(2)十六进制常数——由  $0 \sim 9, \mathrm{~A} \sim \mathrm{F}$  组成，以字母  $\mathrm{H}$  或  $\mathrm{h}$  结尾。以字母  $\mathrm{A} \sim \mathrm{F}$  开头的十六进制数，前面要用 0 表达，以避免与其他符号混淆，如  $64 \mathrm{H} 、 0 \mathrm{FFh} 、 0 \mathrm{B800H}$  。  
(3) 二进制常数——由 0 或 1 两个数字组成, 以字母 B 或 b 结尾, 如 01101100B。  
(4) 八进制常数——由  $0 \sim 7$  数字组成, 以字母 Q 或 q 结尾, 如  $144 \mathrm{~Q}$  。

各种进制的数据以后缀字母区分，默认不加后缀字母的是十进制数。但MASM提供基数控制.RADIX伪指令可以改变默认进制。

⑤ 字符串常数——用英文缩略号括起来的单个字符或多个字符，其数值是每个字符对应的 ASCII 码的值，如 'd' = 64H、'AB'、'Hello, Everybody!'.  
(6) 符号常数——利用一个标识符表达的一个数值。常数若使用有意义的符号名来表示,可以提高程序的可读性, 同时更具有通用性。MASM 提供等价机制, 用来为常量定义符号名, 符号定义伪指令有等价 EQU 和等号=伪指令。其格式为:

符号名 equ数值表达式

符号名 equ<字符串>

符号名 =数值表达式

等价伪指令 EQU 给符号名定义一个数值，或定义成另一个字符串，这个字符串甚至可以为一条处理器指令。例如：

doswritechar equ 2

carriagereturn =13

calldos equ <int 21h>

应用上述符号定义，下列左边的程序段可以写成右侧的等价形式：

mov ah, 2 ; mov ah, doswritechar

mov dl, 13 ; mov dl, carriagereturn

int 21h ; calldos

EQU 用于数值等价时不能重复定义符号名, 但 “=” 允许有重复赋值。例如:

$X = 7$  同样  $\mathsf{X}$  EQU7是正确的

$X = X + 5$  ；但是XEQU  $X + 5$  是错误的

另外，从MASM6.0开始还引入了EQUTEXT伪指令只用于定义字符串常量。

# 2. 数值表达式

数值表达式一般是指由运算符（MASM 统称为操作符 Operator）连接的各种常数所构成的表达式。汇编程序在汇编过程中计算表达式，最终得到一个数值。由于在程序运行之前，就已经计算出了表达式，所以程序运行速度没有变慢，然而程序的可读性却增强了。

MASM 6.x 支持多种运算符，见表 3-2。

表 3-2 运算符  

<table><tr><td>运算符类型</td><td>运算符号及说明</td></tr><tr><td>算术运算符</td><td>+(加),-(减),*(乘),/(除),MOD(取余)</td></tr><tr><td>逻辑运算符</td><td>AND(与),OR(或),XOR(异或),NOT(非)</td></tr><tr><td>移位运算符</td><td>SHL(逻辑左移),SHR(逻辑右移)</td></tr><tr><td>关系运算符</td><td>EQ(相等),NE(不相等),GT(大于),LT(小于),GE(大于等于),LE(小于等于)</td></tr><tr><td>高低分离符</td><td>HIGH(高字节),LOW(低字节),HIGHWORD(高字),LOWWORD(低字)</td></tr></table>

(1) 算术运算符——实现加、减、乘、除、取余的算术运算。其中 MOD 也称为取模, 它是除法之后的余数, 如  $19 \bmod 7 = 5$  。

mov ax,3\*4+5

；等价于mov ax,17

加“+”和减“-”运算符还可以用于地址表达式。除加、减外，其他运算符的参数必须是整数。

② 逻辑运算符——实现按位相与、相或、异或、求反的逻辑运算。例如：

or al,03h AND 45h ；等价于 or al,01h

③ 移位运算符——实现对数值的左移、右移的逻辑操作，移入低位或高位的是0。格式为：

数值表达式 SHL/SHR移位次数

例如：

mov al, 0101b shl (2*2) ; 等价于 mov al, 01010000b

逻辑和移位运算符与指令助记符相同，并有类似的运算功能。汇编程序能够根据上下文判断它们是指令还是运算符，前者进行代码翻译，后者汇编时计算其数值。

④ 关系运算符——用于比较和测试符号数值，MASM 用 FFFFH（补码-1）表示条件为真，用 0000H 表示条件为假。例如：

mov bx，((port1t5)and20)or((portge5)and30）；当port<5时，汇编结果为movbx，20，否则汇编结果为movbx，30

⑤ 高低分离符——取数值的高半部分或低半部分。

HIGH、LOW 从一个字数值或符号常量中得到高、低字节，例如：

mov ah, high 8765h ; 等价于 mov ah, 87h

从MASM 6.0引入的HIGHWORD、LOWWORD取一个符号常量（不能是一般的常数的高字或低字部分。

除上面介绍的运算符外，MASM 中还有其他运算符。

虽然 MASM 对各种运算符的优先级有规定，但建议采用 “( )” 显式表达，这样可以极大地提高程序的可阅读性。

# 3.2.2 变量定义伪指令

变量定义（Define）伪指令为变量申请固定长度的存储空间，并可以同时将相应的存储单元初始化。该类伪指令是最经常使用的伪指令，其汇编格式为：

袁量名 伪指令 初值表

① 变量名为用户自定义标识符，表示初值表首元素的逻辑地址，即用这个符号表示地址，常称为符号地址。变量名可以没有，在这种情况下，汇编程序将直接为初值表分配空间，无符号地址。设置变量名是为了方便存取所指示的存储单元。  
② 初值表是用 “,” 分隔的参数, 主要由数值常数、表达式或 “?”、“DUP” 组成。其中 “?” 表示初值不确定, 即未赋初值; 重复初值可以用 “DUP” 进行定义。DUP 的格式为:

重复次数 dup（重复参数）

(3) 变量定义伪指令有 DB、DW、DD、DF、DQ、DT，它们根据申请的主存空间单分类，下面逐一介绍。

# 1. 定义字节单元伪指令

字节定义伪指令 DB，用于分配 1 字节或多字节单元，并可以将它们初始化为指定值。初值表中每个数据一定是字节量（Byte），可以是  $0 \sim 255$  的无符号数或是  $-128 \sim +127$  倍号数，也可以是字符串常数。例如：

data X DB 'A', -5 DB 2DUP(100),?

；数据段

Y DB 'ABC'

图 3-2(a)为上述语句汇编后在存储器中的分配情况（假设偏移地址从 0 开始）。其中，2 DUP(100)定义了 2 字节数据；而“?”定义的字节数据没有确定，所以图中用一横线表示。利用这些变量的汇编指令示例如下：

```txt
mov al, x ; 此处X表示它的第1个数据，故AL←'a'  
dec x+1 ; 对X为起始的第2个数据减1，故成为-6  
mov y, al ; 现在Y这个字符串成为'aBC'
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8b40df69-e6a2-4f52-8e5b-e888c9e9fb8e/ce5d31bb0972bce67ead57c463a71986a9533189ac375654d6ae320921565a03.jpg)  
图3-2 数据定义的存储形式

# 2. 定义字单元伪指令

字定义伪指令 DW 用于分配一个或多个字单元, 并可以将它们初始化为指定值。初值表中的每个数据一定是字量 (Word), 一个字单元可用于存放任何 16 位数据, 如一个段地址、一个偏移地址、两个字符、0~65535 之间的无符号数或-32768～+32767 之间的带符号数。例如:

```txt
.data ;数据段 count dw 8000h,?, 'ab' maxint equ 64h number dw maxint array dw maxint dup(0)
```

图 3-2(b)为上述语句汇编后在存储器中的分配情况。其中, 'AB'也是按“高对高、低对低”原则存放, 为  $4142 \mathrm{H}$ ; 符号常量 MAXINT 等于  $64 \mathrm{H}$ , 并不占用存储空间。

在 1.6.4 节的存储器寻址方式中提到位移量可以用符号表示, 现在补充定义如下:

```txt
wnum equ 5678h ; 定义wnum为常量 count dw 20h ; 定义count为变量，假设它在数据段的偏移地址为10h
```

这样，如下各指令的功能见注释部分：

```asm
mov ax, [bx+si+wnum] ; 等价于 mov ax, [bx+si+5678h]  
mov ax, count ; 等价于 mov ax, [0010h]  
mov ax, [si+count] ; 相同于 mov ax, count[si]  
; 等价于 mov ax, [si+10h]  
lea bx, count ; 等价于 lea bx, [0010h]  
mov bx, offset count ; 等价于 mov bx, 0010h
```

从上面的指令看到, 变量实际表达的是主存地址, 而且具有属性。仅使用变量名或者加一个常量是直接寻址, 再加一个寄存器是寄存器相对寻址, 加两个寄存器则是基址变址相对

址方式利用后面介绍的OFFSET操作符可以获得这个变量的偏移地址。

# 3 定义双字单元伪指令

双字定义伪指令 DD 用于分配一个或多个双字单元，并可以初始化为指定值。初值表中每个数据是一个 32 位的双字量（Double Word），可以是有符号或无符号的 32 位整数，也可以用来表达 16 位段地址（高位字）和 16 位偏移地址（低位字）的远指针。例如：

```txt
vardd dd 0, ?, 12345678h  
farpoint dd 00400078h
```

# 4. 其他数据定义伪指令

① 定义3字伪指令DF——为一个或多个6字节变量分配空间及初始化。6字节常用在32位CPU中表示一个48位远指针（16位段选择器：32位偏移地址）。  
② 定义4字伪指令DQ——为一个或多个8字节变量分配空间及初始化。8字节变量可以表达一个64位整数。  
③ 定义10字节伪指令DT——为一个或多个10字节变量分配空间及初始化。

从MASM 6.0开始，变量定义伪指令DB、DW、DD、DF、DQ、DT被建议使用新的表达形式，依次为BYTE、WORD、DWORD、FWORD、QWORD、TBYTE，对应的两指令功能相同，前者只是为了与老版本兼容而被保留下来。另外，还有SBYTE、SWORD、SDWORD指令也用于定义字节、字和双字单元的存储空间，但是它们专门用于带符号数的定义和初始化，将在第5章学习它们的使用。

【例3.2】数据定义语句的综合应用示例。

```txt
；数据段  
bvar db 16  
wvar dw 4\*3  
dvar dd 4294967295 ;即  $2^{32} - 1 =$  ffffffffh  
qvar dq ?  
db 1,2,3,4,5  
tvar dt 2345  
abc db 'a'，'b'，'c'  
msg db 'hello',13,10,'s'  
bbuf db 12 dup('month')  
dbuf dd 25 dup(?)  
calldos equ <int21h>；代码段  
mov bl,bvar  
mov ax,word ptr dvar[0] ;取双字到dx.ax  
mov dx,word ptr dvar[2]  
mov dx,offset msg  
mov ah,09h  
calldos
```

【例 3.3】定义一个缓冲区, 包含  $33 \mathrm{H} 、 34 \mathrm{H} 、 35 \mathrm{H}$  和  $36 \mathrm{H}$  四个字节字符, 把这四个数据依次复制 20 次, 存入接着的存储区, 最后显示出复制结果。

```txt
；数据段 source db 33h,34h,35h,36h ;在数据区定义4个字符数据
```

```txt
target db 80 dup(?)；紧接着分配复制数据空间  $4\times 20 = 80$    
；代码段  
mov si, offset source；si=源缓冲区首地址  
mov di, offset target；di=目的缓冲区首地址  
mov cx, 80；cx=80个字符  
again1: mov al, [si]；从源缓冲区取1个字符（寄存器间接寻址）  
mov [di], al；传送到目的缓冲区  
inc si；指向下1个字符位置  
inc di  
loop again1；重复传送80次  
mov di, 0  
again2: mov dl, target[di]；从目的缓冲区取1个字符（寄存器相对寻址）  
mov ah, 2  
int 21h；显示1个字符  
inc di  
cmp di, 80  
jb again2
```

# $\sqrt{5}$  定位伪指令

用数据定义伪指令分配的数据是按顺序一个接一个存放在数据段中的。有时，用户希望能够控制数据的偏移地址，如使数据对齐可以加快数据的存取速度。MASM 提供了几个这样的伪指令。

（1）ORG参数（使它后面的数据或指令从参数指定的地址开始）

ORG伪指令是将当前偏移地址指针指向参数表达的偏移地址。例如：

```txt
org 100h org  $\$ +10$
```

在汇编语言程序中,“$”表示当前偏移地址值。例如。在偏移地址100H单元开始定义“DW1,2,$+4,$+4”,那么在104H单元的值为10sH。106H单元的值为10AH。又如

```txt
array db 12,34,56 len equ $-array
```

那么，len的值就是array变量所占的字节数。

（2）EVEN（使它后面的数据或指令从偶地址开始）

EVEN 伪指令使当前偏移地址指针指向偶数地址，即若原地址指针已指向偶地址，则不做调整；否则将地址指针加 1，使地址指针偶数化。EVEN 可以对齐字量数据。

（3）ALIGN  $n$  （使它后面的数据或指令从  $\pmb{n}$  的整数倍地址开始）

ALIGN 伪指令是将当前偏移地址指针指向  $n$  （ $n$  是 2 的乘方）的整数倍的地址，即若原地址指针已指向  $n$  的整数倍地址，则不做调整；否则将指针加以  $1 \sim n - 1$  中的一个数，使地址指针指向下一个  $n$  的整数倍地址。例如：

```txt
align 4
```

可以使下一个偏移地址开始于双字边界，即对齐了双字边界。

ALIGN 伪指令中的  $n$  值是 2 的乘方 (2, 4, 8, …), 且小于所在段的定位属性值。例如:

```txt
data segment  
data01 db 1,2,3  
even
```

```txt
；完整段定义默认采用PARA节定位属性，其值为16；DATA01的偏移地址为0000H；等价于ALIGN2
```

```txt
data02 dw 5 ; DATA02 的偏移地址为 0004H
align 4
data03 dd 6 ; DATA03 的偏移地址为 0008H
org $+10h
data04 db 'ABC' ; DATA04 的偏移地址为 001CH
data ends
```

ORG、EVEN 和 ALIGN 指令也可在代码段使用，用于指定随后指令的偏移地址。

# 3.2.3 变量和标号的属性

在汇编语句的四个组成部分中，第一部分是标号或名字，是由用户自定义的标识符，指向存储单元，分别表示其存储内容的逻辑地址。标号指示硬指令的地址，变量名指示所定义变量的开始地址，段名指示相应段的起始地址，子程序名指示相应子程序的起始地址等。所以，这些标号和名字一经定义便具有以下两类属性。

(1) 地址属性: 标号和名字对应存储单元的逻辑地址, 包括段地址和偏移地址。  
(2) 类型属性: 标号、子程序名的类型可以是 NEAR (近) 和 FAR (远), 分别表示段内或段间; 变量名的类型可以是 BYTE (字节)、WORD (字) 和 DWORD (双字) 等。

在汇编语言程序设计中，名字和标号的属性非常重要，因此MASM提供有关的操作符，以方便对它们的操作。

# 1. 地址操作符

地址操作符取得名字或标号的段地址和偏移地址两个属性值。例如,“[ ]”表示将括起的表达式作为存储器地址指针;符号“$”表示当前偏移地址;段前缀的“:”也是一种地址操作符,表示采用指定的段地址寄存器。另外,还有两个经常应用的地址操作符:

```txt
offset 名字/标号 ;返回名字或标号的偏移地址seg 名字/标号 ;返回名字或标号的段地址
```

把字节变量 ARRAY 的段地址和偏移地址送入 DS 和 BX，就可用下列指令序列实现：

```txt
mov ax,seg array mov ds,ax mov bx,offset array ；等价于lea bx，array
```

在前面学习的加、减运算符同样可以用于地址表达式。例如:

```txt
mov cl, array+4 ；等效于mov cl, array[4]，这里的“4”表示4字节单元
```

程序设计中还经常利用 OFFSET 计算一段数据或代码的长度（字节数）。例如，主程序开始有一个 start 标号，最后一个指令后有一个 done 标号，则 offset done-offset start 将得到主程序的以字节为单位的长度。

# 2. 类型操作符

类型操作符对名字或标号的类型属性进行有关设置。该类运算符有如下 3 种。

(1) 类型名 PTR 名字/标号（使名字或标号具有指定的类型）

PTR 操作符中的 “类型名” 可以是 BYTE、WORD、DWORD、FWORD、QWORD、TBYTE, 或者是 NEAR、FAR, 还可以是由 STRUCT、RECORD、UNION 和 TYPEDEF 定义的类型。例如:

```txt
mov al, byte ptr w_var ; w_var 是一个字变量，byte ptr 使其作为 1 字节变量
```

jmp far ptr n_label ; n_label 是一个标号, far ptr 使其作为段间转移

PTR 操作符可以临时改变名字或标号的类型。

(2) THIS 类型名（创建采用当前地址，但为指定类型的操作数）

利用 THIS 说明的操作数具有汇编时的当前逻辑地址,但具有指定的类型。类型名同 PTR 操作符中的类型一样。例如:

```txt
b_var equ this byte 按字节访问变量b_var，但与变量w_var的地址相同  
w_var dw 10 dup(0) 按字访问变量w_var  
f_jump equ this far 用f_jump为段间转移（f_jump label far）  
n_jump: mov ax, w_var 用n_jump为段内近转移，但两者指向同一条指令
```

MASM 中还有一个 LABEL 伪指令，其功能等同于 “EQU THIS”。

(3) TYPE 名字/标号（返回一个字量数值，表明名字或标号的类型）

表3-3给出了各种类型的返回数值。例如，对字节、字和双字变量依次返回1、2和4，对短、近和远转移依次返回FF01H、FF02H和FF05H。

表 3-3 类型的返回数值  

<table><tr><td>类型</td><td>返回数值</td><td>类型</td><td>返回数值</td></tr><tr><td>变量</td><td>该变量类型的每个数据占用的字节数</td><td>标号</td><td>距离属性值</td></tr><tr><td>结构</td><td>每个结构元素占用的字节数</td><td>寄存器</td><td>该寄存器具有的字节数</td></tr><tr><td>常数</td><td>0</td><td>-</td><td>-</td></tr></table>

这样，在上例的定义下就有：

```txt
mov ax, type w_var ; 汇编结果为 mov ax,2  
mov ax, type njump ; 汇编结果为 mov ax,@ff@2n (near 标号)
```

另外，操作符 SIZEOF 和 LENGTHOF 具有类似 TYPE 的功能。分别返回整个变量占用的字节数和整个变量的数据项数（即元素数）。实际上，SIZEOF 返回值 = LENGTHOF 返回值 × TYPE 返回值。

注意, 从 MASM 5.x 就支持 SIZE 和 LENGTH 操作符。LENGTH 对于变量定义使用 DUP 的情况, 返回分配给该变量的元素数, 其他情况为 1 。SIZE 返回 LENGTH 与 TYPE 的乘积。对于  $-128 \sim +127$  字节范围内的转移, MASM 5.x 需要用 SHORT 操作符指定才作为短转移, 但在 MASM 6.x 中不需要指定就是短转移。

【例3.4】 属性及其应用。

```txt
;数据段  
v_byte equ this byte ;v_byte是字节类型的变量，但与变量v_word地址相同  
v_word dw 3332h, 3735h ;v_word是字类型的变量  
target dw 5 dup(20h) ;分配数据空间 \(2 \times 5 = 10\) 字节  
crlf db 0dh, 0ah, '\\(  
flag db 0  
n_point dw offset s_label ;取得标号s_label的偏移地址；代码段  
mov al, byte ptr v_word ;用ptr改变v_word的类型，否则与al寄存器类型不匹配  
dec al  
mov v_byte, al ;对v_word的第1字节操作，原来是32h，现在是31h  
n_label:cmp flag,1  
jz s_label ;flag单元为1，则转移inc flag
```

```asm
jmp n_label ; 短转移  
s_label: cmp flag, 2  
jz next ; flag 单元为 2，则转移  
inc flag  
jmp n_point ; 段内的存储器间接寻址，转移到标号 s_label 处  
next: mov ax, type v_word ; 汇编结果为 mov ax, 2  
mov cx, lengthof target ; 汇编结果为 mov cx, 5  
mov si, offset target  
wAgain: mov [si], ax ; 对字单元操作  
inc si ; si 指针加 2  
inc si  
loop w_again ; 循环  
mov cx, sizeof target ; 汇编结果为 mov cx, 0ah  
mov al, ';'  
mov di, offset target  
b_again: mov [di], al ; 对字节单元操作  
inc di ; di 指针加 1  
loop b_again ; 循环  
mov dx, offset v_word ; 显示结果：1357????????????<nl>
mov ah, 9  
int 21h
```

# 3.3 程序段的定义和属性

8086分段管理存储器，完整的8086汇编语言程序也是按照逻辑段组织的。本节将详细讲述源程序格式的每个组成部分，其重点就是段的定义和属性。

# 3.3.1 DOS 的程序结构

首先简单了解 DOS 操作系统的两种可执行程序结构。

# 1. EXE 程序

利用程序开发工具，通常将生成 EXE 结构的可执行程序（扩展名为.exe 的文件）。它可以有独立的代码、数据和堆栈段，还可以有多个代码段或多个数据段，程序长度可以超过 64KB，执行起始处可以任意指定。

规则的 EXE 文件在磁盘上由两部分组成: 文件头和装入模块。装入模块就是程序本身。文件头则由连接程序生成, 包含文件的控制信息和重定位信息, 供 DOS 装入 EXE 文件时使用。实际上, 大型 EXE 文件还可能包含一个附加部分, 此部分由开发者用连接程序以外的工具附加到程序末尾, 不属于装入模块, 也不直接装入主存, 仅供程序本身使用。

当 DOS 装入或执行一个程序时, DOS 确定当时主存最低的可用地址作为该程序的装入起始点。此点以上的区域称为程序段。在程序段内偏移 0 处, DOS 为该程序建立一个程序段前缀控制块 PSP (Program Segment Prefix), 占 256 (=100H) 字节; 而在偏移  $100 \mathrm{H}$  处才装入程序本身, 如图 3-3 所示。

EXE 程序的加载需要重新定位:

(1) DS 和 ES 指向 PSP 段地址, 而不是程序的数据段和附加段, 所以需在程序中根据实际的数据段改变 DS 或 ES。  
(2) CS: IP 和 SS: SP 是由连接程序确定的值, 指向程序的代码段和堆栈段。如果不指定堆栈段, 则 SS=PSP 段地址, SP=100H, 堆栈段占用 PSP 中部分区域。所以有时不设堆栈段也能正常工作。但为了安全起见, 程序应该设置足够的堆栈空间。

程序一旦装载成功，就可以开始执行 CS：IP 指向的程序第一条指令。

# 2. COM 程序

COM 程序是一种将代码、数据和堆栈段合一的结构紧凑的程序，所有代码、数据都在一个逻辑段内，不超过  $64 \mathrm{KB}$  。在程序开发时，需要满足一定要求并采用相应参数才能正确生成 COM 结构的程序。

COM 文件存储在磁盘上是主存的完全影像, 不包含重新定位的加载信息, 与 EXE 文件相比, 其加载速度更快, 占用的磁盘空间也少。

尽管 DOS 也为 COM 程序建立程序段前缀 PSP, 但由于两种文件结构不同, 所以加载到主存后各段设置并不完全一样, 如图 3-4 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8b40df69-e6a2-4f52-8e5b-e888c9e9fb8e/5cdabcfefd83ff8641e517bb281ed1131ea5e67be4ecf95d8e1610adddd5f84a.jpg)  
图3-3 EXE程序的内存映像

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8b40df69-e6a2-4f52-8e5b-e888c9e9fb8e/95f43df89e8bcc55a61ae06b90114d11ca7903ab574954313f8f8cfc6045d33f.jpg)  
图3-4 COM程序的内存映像

(1) 所有段地址都指向 PSP 的段地址。  
(2) 程序执行起点是 PSP 后的第一条指令, 即  $\mathrm{IP} = 100 \mathrm{H}$ ; 也就是说, COM 程序的第一条指令必须是可执行指令, 即程序的起始执行处是程序头。  
(3) 堆栈区设在段尾（通常为 FFFEH），在栈底置 0000 字。

# 3.3.2 简化段定义的格式

根据 3.1.2 节的简化段定义源程序框架，下面详述各部分。

# 1. 存储模型伪指令

存储模型决定一个程序的规模，也确定进行子程序调用、指令转移和数据访问的默认属性。当使用简化段定义的源程序格式时，必须有存储模型.MODEL 语句，其格式为:

.model 存储模型[, 语言类型][, 操作系统类型][, 堆栈选项]

. MODEL 语句说明程序采用的存储模型（Memory Model）等内容，必须位于所有段定

义语句之前。MASM有7种存储模型。

(1) TINY（微型模型）——用微型模型编写汇编语言程序时，所有的段地址寄存器都被设置为同一个值。这意味着代码段、数据段、堆栈段都在同一个段内，不大于 64 KB，访问操作数或指令都只需要使用 16 位偏移地址。

微型模型是MASM 6.0才引入的，比较特殊，用于创建COM类型程序。

(2) SMALL (小型模型) ——在小型模型下, 一个程序至多只能有一个代码段和一个数据段, 每段不大于  $64 \mathrm{KB}$  。这里的数据段是指数据段、堆栈段和附加段的总和, 它们公用同一个段基址, 总长度不可超过  $64 \mathrm{KB}$ , 因此小模型下程序的最大长度为  $128 \mathrm{KB}$  。

由于只有一个不大于  $64 \mathrm{KB}$  的代码段和一个不大于  $64 \mathrm{KB}$  的数据段, 所以访问操作数或指令都只需要使用 16 位偏移地址。这意味着诸如指令转移、程序调用及数据访问等都是近属性 (NEAR), 即小型模型下的调用类型和数据指针默认分别为近调用和近指针。

一般的程序（如本书的绝大多数程序示例和习题）都可用这种模型。

(3) COMPACT（紧凑模型）——代码段被限制在一个不大于 64 KB 的段内，而数据段则可以有多个，超过 64 KB。这种模型下的调用类型默认仍为近调用，而数据指针默认为远（FAR）指针，这是因为必须用段地址来区别多个数据段。

紧缩方式适合于数据量大但代码量小的程序。

(4) MEDIUM (中型模型) ——与紧凑模型互补的模型。中型模型的代码段可以超过 64KB, 有多个, 但数据段只能有一个不大于  $64 \mathrm{KB}$  的段。这种模型下的数据指针默认为近指针, 但调用类型默认为远 (FAR) 调用, 因为要利用段地址区别多个代码段。

中型模型适合于数据量小而代码量大的程序。

(5) LARGE（大型模型）——允许的代码段和数据段都有多个，都可以超过  $64 \mathrm{KB}$ ；但全部的静态数据（不能改变的数据）仍限制在  $64 \mathrm{KB}$  内。大型模型下的调用类型和数据指针默认分别为远调用和远指针。

大型模型是较大型程序通常采用的存储模型。

(6) HUGE (巨型模型) ——与大型模型基本相同, 只是静态数据不再被限制在  $64 \mathrm{KB}$  内。

(7) FLAT (平展模型) ——创建一个 32 位的程序, 只能运行在 32 位 x86 CPU 上。该语句前要使用 32 位 x86 CPU 的处理器说明伪指令 (详见 5.3 节)。DOS 下不能使用 FLAT 模型,而编写 32 位 Windows 应用程序时必须采用 FLAT 模型。

在 DOS 下用汇编语言编程时, 可根据程序的不同特点选择前 6 种模型, 一般可以选用 SMALL 模型。另外, TINY 模型将产生 COM 程序, 其他模型产生 EXE 程序, FLAT 模型只能用于 32 位程序中。当与高级语言混合编程时, 两者的存储模型应该一致。

完整的MODEL语句还可以选择“语言类型”，如C语言、Pascal语言等，表示采用指定语言的命名和调用规则，将影响PUBLIC、EXTERNAL等伪指令。操作系统类型默认和唯一支持的就是os_dos（DOS）。堆栈选项默认是NEARSTACK，表示堆栈段寄存器SS等于数据段寄存器DS，FARSTACK则表示SS不等于DS。通常采用默认值。

# 2. 简化段定义伪指令

简化的段定义语句书写简短, 语句.CODE、.DATA 和 STACK 分别表示代码段、数据段和堆栈段的开始, 一个段的开始自动结束前面的一个段。采用简化段定义指令之前, 必须有存储模型语句.MODEL。

```txt
.stack [大小]
```

堆栈段伪指令 STACK 创建一个堆栈段，段名是“stack”，其参数指定堆栈段所占存储区的字节数，默认是 1KB（即 1024=400H 字节）。

```txt
.data data?
```

数据段伪指令 DATA 创建一个数据段，段名是 “_DATA”，用于定义具有初值的变量，当然也允许定义无初值的变量。无初值变量可以安排在另一个段中，用 DATA?伪指令创建，它建立的数据段名是“_BSS”。使用 DATA?伪指令是在程序运行时才分配空间，所以可以减小形成的 EXE 文件，并与其他语言保持最大的兼容性。另外，CONST 伪指令用于建立只读的常量数据段（段名为“CONST”），FARDATA 和 FARDATA?伪指令分别用于建立有初值和无初值的远调用数据段。

```txt
.code [段名]
```

.CODE 伪指令创建一个代码段，它的参数指定该代码段的段名。如果没有给出段名，则采用默认段名。在 TINY、SMALL、COMPACT 和 FLAT 模型下，默认的代码段名是“_TEXT”；在 MEDIUM、LARGE 和 Huge 模型下，默认的代码段名是“模块名.Text”。

另外，使用简化段定义，各段名称和其他用户所需的信息可以使用MASM预定义的符号，这些符号主要有：

① @CODE——表示.CODE伪指令定义的段名。  
(2) @ DATA——表示由.DATA、.DATA?等定义的数据段的段名。  
③ 其他——如@ CURSEG 当前段名、@ STACK 堆栈段名、@ CODESIZE 代码段规模和@ DATASIZE 数据段规模等。

一个源程序中可以出现多个简化段定义伪指令，如多处写有 DATA。但实际上，汇编程序 MASM 将它们组织在一起连续存放在定义的缓冲区。

# 3. 程序开始伪指令

STARTUP 伪指令按照给定的 CPU 类型，根据 MODEL 语句选择的存储模型、操作系统和堆栈类型，产生程序开始执行的代码，同时指定程序开始执行的起始点。在 DOS 下，STARTUP 语句还将初始化 DS 值，调整 SS 和 SP 值。例如，在 SMALL 存储模型下，对应 8086 CPU，STARTUP 语句将被汇编成如下启动代码：

```txt
mov dx, dgroup ; dgroup表示数据段组的段地址  
mov ds, dx ; 设置ds  
mov bx, ss  
sub bx, dx  
shl bx, 1  
shl bx, 1  
shl bx, 1  
shl bx, 1  
cli ; 关中断  
mov ss, dx ; 调整ss=ds，这是small模型的规定  
add sp, bx ; 移动了ss段地址，所以sp也需要相应调整  
sti ; 开中断
```

在小型模型下，. STARTUP 语句主要设置了数据段 DS 值，同时按照存储模型要求使堆栈段 SS=DS；为了保证堆栈区域不变，栈顶指针 SP 也需要相应地调整，即加上数据段所占

字节数大小, 可对照前面图 3-2 来理解。显然, 如果不使用 STARTUP 语句, 可以用下面 2 条指令代替 (没有调整堆栈 SS:SP):

```txt
start: mov ax, @data ; @data 表示数据段的段地址  
mov ds, ax ; 设置 ds
```

注意, 连接程序会根据程序起始点正确地设置 CS:IP, 根据程序大小和堆栈段大小设置 SS:SP 值, 但没有设置 DS、ES 值。所以, 程序使用了数据段 (和附加段), 就必须在程序中明确给 DS (和 ES) 赋值。正像 STARTUP 语句所完成的那样。

# 4. 程序终止伪指令

EXIT 语句产生终止程序执行返回操作系统的指令代码。它的可选参数是一个返回的数码, 通常用 0 表示没有错误。

_exit [返回数码]

例如，.EXIT 0 对应的代码为：

```txt
mov ax, 4c00h  
int 21h
```

这是利用了 DOS 功能调用的 4CH 子功能（返回 DOS 功能：AH=4CH）实现的，它的入口参数是 AL=返回数码。

. STARTUP 和 .EXIT 语句是 MASM 6.0 才引入的，大大简化了汇编语言程序的复杂度。利用 MASM 5.x 可以采用它的等效指令代码。

# 5. 汇编结束伪指令

END 伪指令指示汇编程序 MASM 到此结束汇编过程。源程序的最后必须有一条 END 语句, 可选的标号用于指定程序开始执行点, 如 start, 连接程序据此设置 CS:IP 值。

```txt
end [标号]
```

简化段定义格式引入存储模型，方便编写源程序。在小型程序中，通常采用 SMALL 模型；为了得到更短小的程序，可以创建 COM 程序。利用 MASM 6.x 的简化段定义格式，可以非常容易地创建一个 COM 程序。此时要采用 TINY 模型；源程序只设置代码段，不能设置数据、堆栈等其他段；程序必须从偏移地址  $100 \mathrm{H}$  处开始执行；数据安排在代码段中，但不能与可执行代码相冲突，通常在程序最后。

【例 3.5】COM 程序实现按任意键后响铃。

```asm
.model tiny
.code
.startup
mov dx, offset string
mov ah, 9
int 21h
mov ah, 01h
int 21h
mov ah, 02h
mov d1, 07h
int 21h
.export 0
string db 'Press any key to continue!'
end
```

# 3.3.3 完整段定义的格式

根据3.1.2节的完整段定义源程序框架，下面详述各部分。

# 1. 完整段定义伪指令

完整段定义由 SEGMENT 和 ENDS 这一对伪指令实现，格式如下：

段名 segment [定位] [组合] [段字] ['类别']

.

；语句序列

段名 ends

SEGMENT 伪指令定义一个逻辑段的开始，ENDS 伪指令表示一个段的结束。段定义指令后的 4 个关键字用于确定段的各种属性，堆栈段要采用 stack 组合类型，代码段应具有 'code' 类别，其他为可选属性参数。如果指定，顺序必须如上，否则采用默认参数。

(1) 段定位（Align）属性——指定逻辑段在主存储器中的边界，该关键字如下。

BYTE: 段开始为下一个可用的字节地址（xxxx xxxxB），属性值为1。  
WORD：段开始为下一个可用的偶数地址（xxxxxx0B），属性值为2。  
$\diamond$  DWORD：段开始为下一个可用的4倍数地址（xxxxxx00B），属性值为4。  
PARA：段开始为下一个可用的节地址（xxxx0000B），属性值为16。  
PAGE：段开始为下一个可用的页地址（0000000B），属性值为256。

简化段定义伪指令的代码和数据段默认采用WORD定位,堆栈段默认采用PARA定位。例如，lt301a.exe程序的代码段从14C4:0000H开始，到14C4:0022H结束，则下一个可用单元的地址为14C4:0023H。对于后面采用WORD定位的数据段，因为要求从偶数地址开始，所以应该是14C4:0024H（物理地址为14C64H）。因为段地址的低4位必须是0000B，所以将物理地址低4位取0，作为数据段地址，则数据段开始的逻辑地址为14C6:0004H。此例中，数据段开始的偏移地址为0004H。

完整段定义伪指令的默认定位属性是 PARA, 其低 4 位已经是 0 , 所以默认情况下数据段的偏移地址从 0 开始。

(2) 段组合（Combine）属性——指定多个逻辑段之间的关系。通常，在大型程序的开发中，要分成许多模块，然后用连接程序形成一个可执行文件。在其他模块中，可以具有同名或/和同类型的逻辑段，通过段组合属性可以进行合理的合并。组合的关键字如下。

• PRIVATE: 本段与其他段没有逻辑关系, 不与其他段合并, 每段都有自己的段地址。这是完整段定义伪指令默认的段组合方式。  
• PUBLIC: 连接程序把本段与所有同名同类型的其他段相邻地连接在一起, 然后为所有这些段指定一个共同的段地址, 即合成一个物理段。这是简化段定义伪指令默认的段组合。  
STACK: 堆栈的一部分, 连接程序将所有 STACK 段按照与 PUBLIC 段的同样方式进行合并。这是堆栈段必须具有的段组合。  
• COMMON: 连接程序把所有同名同类型逻辑段指定同一个段地址, 这样后面的同名同类型段将覆盖前面的段, 主要用于共享数据。  
(3) 段字（Use）属性——为支持 32 位段而设置的属性。16 位 x86 CPU 默认 16 位段，即 USE16；而汇编 32 位 x86 CPU 指令时，默认采用 32 位段，即 USE32，但可以使用 USE16

指定标准的16位段。编写运行于实地址方式（8086工作方式）的汇编语言程序，必须采用16位段。

④ 段类别（Class）属性——当连接程序组织段时，将所有的同类别段相邻分配。段类别可以是任意名称，但必须位于单引号中；大多数MASM程序使用‘code’、‘data’和‘stack’来分别指名代码段、数据段和堆栈段，以保持所有代码和数据的连续。

# 2. 指定段寄存器伪指令

段定义伪指令 SEGMENT 说明各逻辑段的名字、起止位置及属性，而指定段寄存器伪指令 ASSUME 是说明各逻辑段的种类的，其格式为：

```txt
assume 段寄存器：段名[，段寄存器名：员名，-]
```

ASSUME 伪指令通知 MASM 用指定的段寄存器来寻址对应的逻辑段, 即建立段寄存器与段的默认关系。在明确了程序中各段与段寄存器之间的关系后, 汇编程序会根据数据所在的逻辑段, 在需要时自动插入段超越前缀。这是 ASSUME 伪指令的主要功能。

ASSUME 伪指令并不为段寄存器设定初值，连接程序LINK将正确设置CS:IP和SS:SP。由于数据段通常都需要，所以在源程序框架中，首先为DS赋值：如果使用附加段，还要赋值ES。

ASSUME 伪指令的段名参数，可以是：

以段定义伪指令设置的段名。  
以GROUP伪指令设置的组名.  
保留字NOTHING（表示取消指定的段落存在与同  
用SEG操作符返回的段地址.

# 3. 段组伪指令

MASM汇编程序允许程序员定义多个同类段（代码段、数据段、堆段段）伪指令GROUP把多个同类段合并为一个64KB物理段。用组级组态位组（GROUP伪指令的格式为：

```txt
组名 group
```

定义段组后，段组内各段统一为一个段地址。各段定义的变量和标号的偏移地址相对于段组基地址计算。OFFSET 操作符取变量和标号相对于段组的偏移地址。如果没有段组，则取得相对于段的偏移地址。OFFSET 后可以跟段组中的某个段名，表示该段最后 1 字节后面字节相对于段组的偏移地址。

【例3.6】将两个数据段data1和data2合并在一个datagroup组

```txt
stackseg segment stack  
db 256 dup(?)  
stackseg ends  
data1 segment word public 'const'  
const1 dw 100  
data1 ends  
data2 segment word public 'vars'  
var1 dw ?  
data2 ends  
datagroup group data1, data2  
codeseg segment para public 'code'
```

```txt
assume cs: codeseg, ds: datagroup, ss: stackseg  
start: mov ax, datagroup  
mov ds, ax ; ds 赋初值对该组寻址  
mov ax, const1 ; ax=100  
mov var1, ax ; var1=100  
mov ax, offset var1 ; ax=2  
mov ax, offset data1 ; ax=2  
mov ax, offset data2 ; ax=4  
assume ds:data2  
mov ax, data2  
mov ds, ax  
mov ax, var1 ; ax=100  
mov ax, offset var1 ; ax=2  
mov ax, 4c00h  
int 21h  
codeseg ends  
end start
```

GROUP 伪指令的作用与具有 PUBLIC 组合属性的同名段一样。段名还可以有 “SEG 变量名/标号名” 表示形式。

# 4. 段顺序伪指令

在源程序中，通常按照便于阅读的原则或个人习惯书写各个逻辑段。但是段在主存中的实际顺序是可以设置的，MASM 具有如下伪指令：

,seq ，按照源程序的各段顺序

.dosseg .按照其他微软的程序设计语言使用的标准DOS规定

. alpha

完整段定义格式中，默认按照源程序各段的书写顺序安排（即.SEG）；采用 MODEL 伪指令的简化段定义格式按.DOSSEG 规定的标准 DOS 程序顺序；代码段、数据段、堆栈段。

【例3.7】 将堆栈区设置在数据段中。

要求: 写出适当的段定义, 数据段 DSEG 起始于字边界, 连接时将与同名逻辑段连接成一个物理段, 它的类别名为 'data'。将 200 个字容量的堆栈初始化在 DS:100H 中, 堆栈指针 SP 指向栈顶; 随后, 将 100 个字的数组 ARRAY 定义在数据段。代码段 CSEG 将数据段的 100 个字压入自设的堆栈中。

```txt
dseg segment word public 'data' org 100h ；设定堆栈段起始段内偏移地址 dw 200 dup(?)   
topsp equ this word ；定义栈顶指针   
array dw 100 dup(5868h)   
dseg ends   
cseg segment 'code' assume cs:cseg, ds:dseg, ss:dseg; dseg 既是数据段又是堆栈段   
start: mov ax, dseg mov ds, ax mov ss, ax ；数据段与堆栈段具有相同的段地址
```

```txt
mov sp, offset topsp mov cx, 100 xor si, si again: push array[si] inc si inc si loop again mov ah, 4ch int 21h cseg ends end start
```

本程序进行连接时，连接程序将报告“无堆栈段”警告信息，可不必理会它。

需要说明的是，采用简化段定义格式的源程序同样具有段定位、组合、类别及段组等属性。表3-4给出了SMALL存储模型下的设置。

表3-4small模型的段属性  

<table><tr><td>段定义伪指令</td><td>段名</td><td>定位</td><td>组合</td><td>类别</td><td>组名</td></tr><tr><td>.CODE</td><td>.Text</td><td>WORD</td><td>PUBLIC</td><td>&#x27;CODE&#x27;</td><td></td></tr><tr><td>_DATA</td><td>_DATA</td><td>WORD</td><td>PUBLIC</td><td>&#x27;DATA&#x27;</td><td>DGROUP</td></tr><tr><td>_DATA?</td><td>_BSS</td><td>WORD</td><td>PUBLIC</td><td>&#x27;BSS&#x27;</td><td>DGROUP</td></tr><tr><td>_STACK</td><td>STACK</td><td>PARA</td><td>STACK</td><td>&#x27;STACK&#x27;</td><td>DGROUP</td></tr></table>

.MODEL伪指令除了设置程序采用的存储模型外，还具有如下语句的作用：

```csv
DGROUP GROUP_DATA, _BSS, STACK  
ASSUME CS: _TEXT, DS: DGROUP, SS: DGROUP
```

简化段定义格式与完整段定义格式的作用是一样的，只是简化段定义格式将段属性进行了隐含和简化。另外，本节介绍的完整段定义等伪指令也可以用在MODEL伪指令后的简化段格式源程序中。

# 3.4 复杂数据结构

类似高级语言中的用户自定义复合类型数据，MASM 中也允许将若干个相关的单个变量作为一个组来进行整体数据定义，然后通过相应的结构预置语句为变量分配空间。除了具有定义简单数据结构的伪指令（DB、DW 等），MASM 还有结构、联合与记录等复杂数据结构的定义伪指令。

# 3.4.1 结构

结构（Structure）是把各种不同类型的数据组织到一个数据结构中，便于处理某些变量。

# 1. 结构类型的说明

结构类型的说明使用一对伪指令 STRUCT (MASM 5.x 是 STRUC, 功能相同) 和 ENDS,其格式为:

```txt
结构名 struct
```

结构名 ends

例如，下述语句段说明了学生成绩结构：

```txt
student struct sid dw sname db 'abcdefgh' math db 0 english db 0   
student ends
```

结构说明中的数据定义语句给定了结构类型中所含的变量，称为结构字段，相应的变量名称为字段名。结构中可以有任意数目的字段，各字段长度可以不同，可以独立存取，可以有名或无名，可以有初值或无初值。

# 2. 结构变量的定义

结构说明只是定义了一个框架，并未分配主存空间，必须通过结构预置语句分配主存并初始化。结构预置语句的格式为：

变量名 结构名<字段初值表>

其中，初值表要用“<>”括起来，是采用“,”分隔的与各字段类型相同的数值（或空）。汇编程序将以初值表中的数值的顺序初始化对应的各字段，初值表中为空的字段将保持结构说明中指定的初值。另外，结构说明中使用DUP操作符说明的字段不能在结构预置语句中初始化。例如，对应上述结构说明，可以定义如下结构变量：

```txt
stu1 student<1, 'zhang', 85, 90>  
stu2 student<2, 'wang', ->  
student 100 dup(<>)
```

100个结构变量空间

# 3. 结构变量及其字段的引用

引用结构变量，只要直接书写结构变量名；要引用其中的某个字段，则采用“.”操作符，其格式是“结构变量名.结构字段名”。例如：

mov stu1.math, 95

；试行指令后，将math域的值更新为95

【例3.8】 结构的应用。

定义含有100个PERSON结构数组的数据段，结构中包括编号（number）、姓名（name）、性别（sex）和出生日期（birthday），要求在程序中对编号依次赋值为  $001\sim 100$

```txt
person;数据段  
person struct  
number dw 0  
pname db '-----'  
sex db 0  
birthday db 'mm/dd/yyyy'  
person ends  
array person 100 dup<>；结构预置语句分配100个空白结构；代码段  
mov bx, offset array  
mov ax, 1  
sub si, si  
mov cx, length array；CX一结构变量的个数（100）
```

```txt
mov dx, type array ; DX←结构所占的字节数  
mov [bx+si].person.number, ax ; 在没有变量名时要采用结构名引用其字段  
inc ax  
add si, dx  
loop again
```

# 3.4.2 记录

记录（Record）提供直接按名访问字或字节中的若干位的方法，记录中的基本存储单位是二进制位。

# 1. 记录类型的说明

记录类型的说明采用伪指令 RECORD，其格式为：

记录名 record 位段[, 位段…]

记录名给出了说明的记录类型，位段（也称为字段）表示构成记录的数据结构。记录中位段的格式如下：

位段名: 位数[=表达式]

其中, 位数说明该位段所占的二进制位个数 (1~16), 表达式给该位段赋初值, 可以省略。整个记录的长度为  $1 \sim 16$  位, 记录长度小于 8 位时, 汇编成 1 字节; 长度为  $9 \sim 16$  位时, 汇编成 1 个字。位段从低位 (右) 对齐, 不用的位为 0 。例如, 说明一个人的出生年 (YEAR)、性别 (SEX) 和婚姻状态 (MARRIAGE) 的记录如下:

```javascript
person record year:4, sex:1=0, marriage:1=1
```

汇编程序将用 1 字节的低 6 位表达这个记录。其中, MARRIAGE 在  $\mathrm{D}_{0}$  位, SEX 在  $\mathrm{D}_{1}$  位, YEAR 在  $\mathrm{D}_{2} \sim \mathrm{D}_{5}$  位。

# 2. 记录变量的定义

说明了记录类型，就可以定义记录变量，这样汇编程序才进行存储分配。其格式为：

记录变量名 记录名<段初值表>

位段初值表为各个位段赋初值，规则同结构的字段初值表。例如：

```txt
zhang person <1000b,1,0> ；该字节值为00100010b=22h wang person <1001b,，0> ；该字节值为00100100b=24h
```

# 3. 记录变量的引用和记录操作符

记录变量通过它的变量名直接引用，表示它的字节或字值。例如：

```txt
mov al, zhang ; al←22h
```

记录位段名是一个特殊的操作符，表示该位段移位到最低位  $\mathrm{D}_{0}$  的移位次数。例如：

```txt
mov bl, year ; bl←2
```

“WIDTH 记录名/记录位段名” 操作符返回记录或记录位段所占的位数。例如:

```txt
mov cl, width person ; cl←6
```

“MASK 记录位段名”操作符返回一个 8 位或 16 位数值, 其中对应该位段的个位为 1 ,其余位为 0 。例如:

```txt
mov dl, mask sex ; dl←00000010b=02h
```

MASM 中的复杂数据结构还有 “联合 UNION”。联合用于为不同的数据类型赋予相同的存储地址, 以达到共享的目的。另外, MASM 提供了 “类型定义 TYPEDEF” 伪指令, 用

于创建一个新数据类型，即为已定义的数据类型取一个同义的类型名。

本章基于汇编语言源程序结构，详细介绍了基本的MASM伪指令和操作符。MASM中还有流程控制伪指令、过程伪指令、宏指令、列表伪指令及条件伪指令等，因为涉及汇编语言程序设计，我们将在后继章节中详细学习（见附录C）。与处理器硬指令一样，伪指令和操作符也很多，也建议读者应该重点掌握常用的。

本章应重点掌握的伪指令为：.MODEL、.CODE、.DATA、.STACK、END，=、EQU, DB、DW、DD。本章应重点掌握的操作符为：+、-, DUP、?, OFFSET、PTR。

# 习题3

3.1 伪指令语句与硬指令语句的本质区别是什么? 伪指令有什么主要作用?

A13.2 什么是标识符？汇编程序中标识符怎样组成？  
3.3 什么是保留字？汇编语言的保留字有哪些类型？并举例说明。  
3.4 汇编语句有哪两种? 每个语句由哪四部分组成?  
3.5 汇编语言程序的开发有哪 4 个步骤? 分别利用什么程序完成? 产生什么输出文件?

3.6 区分下列概念：

(1) 变量和标号 (2) 数值表达式和地址表达式 (3) 符号常量和字符串常量

3.7 假设 myword 是一个字变量, mybyte1 和 mybyte2 是 2 个字节变量, 指出下列语句中的错误原因。

(1) mov byte ptr [bx], 1000  
(2) mov bx, offset myword[si]  
(3) cmp mybyte1, mybyte2  
(4) mov al, mybyte1+mybyte2  
(5) sub al, myword  
(6) jnz myword

3.8 OPR1 是一个常量，问下列语句中两个 AND 操作有什么区别？

and al, opr1 and 0feh

3.9 给出下列语句中，指令立即数（数值表达式）的值：

(1) mov al, 23h and 45h or 67h  
(2) mov ax,  $1234 \mathrm{~h} / 16 + 10 \mathrm{~h}$  
(3) mov ax, not (65535 xor 1234h)  
(4) mov al, low 1234h or high 5678h  
(5) mov ax, 23h shl 4  
(6) mov ax, 1234h shr 6  
(7) mov al, 'a' and (not('a'- 'a'))  
(8) mov al, 'h' or 00100000b  
(9) mov ax, (76543 lt 32768) xor 7654h

3.10 画图说明下列语句分配的存储空间及初始化的数据值：

(1) byte_var db 'abc', 10, 10h, 'ef', 3 dup(-1, ?, 3 dup(4))