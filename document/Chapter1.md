# 第1章 汇编语言基础知识

程序设计语言是开发软件的工具，其发展经历了由低级语言到高级语言的过程。汇编语言是一种面向机器的低级程序设计语言。汇编语言以助记符形式表示每条计算机指令，每条指令对应着计算机硬件的一个具体操作。利用汇编语言编写的程序与计算机硬件密切相关，程序员可直接对处理器内的寄存器、主存储器的存储单元及外设的端口等进行操作，从而有效地控制硬件。利用汇编语言编写的程序具有执行速度快、占用存储空间小的特点，这是高级语言无法替代的优势。所以，计算机专业人员应该熟悉汇编语言，并掌握其程序设计方法。

本章介绍使用汇编语言进行程序设计需要了解的基本知识，并引出有关基本概念。首先，介绍计算机系统的一般知识，包括计算机系统的硬件、软件及程序设计语言的发展，特别说明了汇编语言的特点和应用场合。其次，简述计算机中数据的表示，如二进制数和十六进制数、BCD码和ASCII码、补码和反码、二进制数运算等。然后，认识Intel80x86系列微处理器和以其为核心的微机系统。最后，展开8086微处理器的结构和数据寻址，作为第2章学习的重要基础。

# 1.1 计算机系统概述

计算机系统分为硬件和软件两大部分。硬件（Hardware）是计算机系统的机器部分，是计算机工作的物质基础。软件（Software）是为了运行、管理和维护计算机而编制的各种程序的总和，广义的软件还应该包括与程序有关的文档。利用汇编语言所编写的程序是软件，但是每条汇编语言指令都使计算机某个具体硬件部件产生相应的动作，因此，利用汇编语言进行程序设计体现了计算机硬件和软件的结合。

# 1.1.1 计算机的硬件

源于冯·诺依曼设计思想的计算机由五大部件组成：控制器、运算器、存储器、输入设备和输出设备。控制器是整个计算机的控制核心；运算器是对信息进行运算处理的部件；存储器是用来存放数据和程序的部件；输入设备将数据和程序变换成计算机内部能够识别和接受的信息方式，并把它们送入存储器中；输出设备将计算机处理的结果以人们能接受的或其他机器能接受的形式送出。

现代计算机在很多方面都对冯·诺依曼计算机结构进行了改进, 如五大部件演变为三个硬件子系统: 处理器、存储系统和输入/输出系统。处理器 (Processor) 也被称为中央处理单元 (Central Processing Unit, CPU), 包括运算器和控制器, 是计算机的核心部件。微型计算机 (PC) 中的处理器常采用一块大规模集成电路芯片构成, 称为微处理器 (Microprocessor), 它代表着整个微型计算机系统的性能。存储系统由处理器内的寄存器 (Register)、高速缓冲存储器、主存储器和辅助存储器构成层次结构。处理器和存储系统在信息处理中起主要作用, 是计算机硬件的主体部分, 通常被称为 “主机”。输入 (Input) 设备和输出 (Output) 设备统称为外部设

备(Peripheral),简称为外设或  $\mathrm{I}/\mathrm{O}$  设备；输入/输出系统的主体是外设,还包括外设与主机之间相互连接的  $\mathrm{I}/\mathrm{O}$  接口电路。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/e312d77b6eee9e1dbdd5485ac4e3e41e484d0b9f6f97ff9fd5ba36edfb3d0692.jpg)  
图1-1 微型计算机的系统组成

为了简化各部件的相互连接，现代计算机广泛应用总线结构，如图1-1所示，使得计算机系统具有组合灵活、扩展方便的特点。

# 1. 处理器

除包括运算器和控制器外，处理器还有一些高速存储单元，即寄存器，它们提供各种操作需要的数据。高性能处理器内部非常复杂，如为了提高存取主存储器的速度而增加了高速缓冲存储器（Cache），运算器中不仅有基本的整数运算器，还有浮点处理单元甚至

多媒体数据运算单元，控制器还包括存储管理单元、代码保护机制等。

# 2. 存储器

存储器（Memory）是计算机的记忆部件，用来存放程序及所涉及的数据。存储器的内容并不因为被读出而消失，可以重复取出；只有存入新的信息后，原来的信息才会被更改。

按所起作用,存储器可以分为主存储器和辅助存储器,即主存(内存)和辅存(外存)。 主存储器存放当前正在执行的程序和使用的数据,由半导体存储器芯片构成,成本高、容量小, 但速度快,可以直接被 CPU 存取。辅助存储器可用于长期保存大量程序和数据,CPU 需要通过 I/O 接口访问,由磁盘或光盘构成,成本低、容量大,但速度较慢。在计算机系统中,主存的容量是有限的,需要辅存来补充；辅存的容量比主存大得多,但存取速率比主存慢得多。一般来说,程序和数据以文件的形式保存在辅存中,只有在用到它们时,才从辅存读到主存的某个区域中,由中央处理单元控制执行。

按读/写能力,存储器可以分为随机存取存储器RAM和只读存储器ROM。CPU可以从RAM中读出信息,也可以向RAM中写入信息,所以RAM也被称为读/写存储器;而ROM中的信息只能被读出,不能被修改。RAM型半导体存储器可以按地址随机读/写,但断电后不能保存信息;ROM型半导体存储器通常只能被读出,在断电后仍能保存信息。磁盘存储器是可读可写的,而CD-ROM光盘是只读的,这两种存储器都是辅存,都可以长期保存数据,但它们的存取速率都慢于半导体存储器。

主存储器由大量存储单元组成。为了区别每个单元,我们将它们编号,于是每个存储单元就有了存储器地址(Address)。每个存储单元存放 1 字节的数据。1 字节 (byte,B) 包含 8 个二进制位 (bit,b)。

存储容量是指存储器所具有的存储单元个数, 其基本单位是字节 (B)。为了表达更大的容量, 常用的单位有 KB(千字节)、MB(兆字节)、GB(吉字节)、TB(太字节)、PB(Petabyte)、 EB(Exabyte)。  $1\mathrm{{KB}} = {2}^{10}\mathrm{\;B} = {1024}\mathrm{\;B},1\mathrm{{MB}} = {2}^{20}\mathrm{\;B},1\mathrm{{GB}} = {2}^{30}\mathrm{\;B},1\mathrm{{TB}} = {2}^{40}\mathrm{\;B}$  。

# 3. 外部设备

外部设备是实现人机交互和机间通信的一些机电设备。在微机系统中，常用的输入设备有键盘、鼠标器等，输出设备有显示器、打印机等；起辅存作用的磁盘和光盘也是以外设的形式连接到系统中的，可以认为它们既是输入设备也是输出设备。

外设的种类繁多、工作原理各异,所以每个外设必须通过输入/输出接口(I/O 接口)电路与系统连接。程序员所见的 I/O 接口由一组寄存器组成。为了区别它们,对每个寄存器进行了编号,形成  $\mathrm{I}/\mathrm{O}$  地址,通常被称为  $\mathrm{I}/\mathrm{O}$  端口 (Port)。系统实际上就是通过这些端口与外设进行通信的。

# 4. 系统总线

总线（Bus）是用于多个部件相互连接、传递信息的公共通道，物理上就是一组公用导线。例如，处理器芯片的对外引脚（Pin）常被称为处理器总线。系统总线（System Bus）是指计算机系统中主要的总线，如处理器与存储器和I/O设备进行信息交换的公共通道。

对汇编语言程序员来说，处理器、存储器和外部设备依次被抽象为寄存器、存储器地址和输入/输出地址，因为编程过程中将只能通过寄存器和地址实现处理器控制、存储器和外设的数据存取与处理等操作。

# 1.1.2 计算机的软件

软件是计算机系统的重要组成部分,可以使机器更好地发挥作用,分为系统软件和应用软件。

# 1. 系统软件

系统软件是指为了方便使用、维护和管理计算机系统而编制的一类软件及其文档，包括操作系统、语言翻译程序等。系统软件是面向计算机系统的、通常由计算机厂家提供的程序及其文档，是用户使用计算机时为产生、准备和执行用户程序所需的程序。

系统软件中最重要的软件是操作系统。操作系统负责管理整个系统的软件、硬件资源，向用户提供交互的界面，是所有其他程序运行的基础。用户借助操作系统使用计算机系统，程序员也要采用操作系统提供的驱动程序编写用户程序。

程序员采用某种程序设计语言编写源程序，利用语言翻译程序将源程序转变成可运行的程序。例如，本书介绍用汇编语言设计源程序的方法，但必须利用“汇编程序”完成源程序的翻译工作。高级语言则采用编译类或解释类程序来完成这个工作。

# 2. 应用软件

应用软件是解决某一问题的程序及其文档，覆盖了计算机应用的所有方面，每个应用都有相应的应用程序。微机系统具有多种多样的应用软件。例如，进行程序设计时要采用文本编辑软件编写源程序，带有丰富格式的字处理软件帮助用户书写文章，排版软件则用于书刊出版。

大型的程序设计项目往往要借助软件开发工具（包）。开发工具是进行程序设计所用到的各种软件的有机集合，所以也被称为集成开发环境，包括文本编辑器、语言翻译程序、用于形成可执行文件的连接程序，以及进行程序排错的调试程序等。

# 1.1.3 计算机的程序设计语言

程序设计语言有很多，可以分为低级语言和高级语言。低级语言有机器语言和汇编语言，高级语言有 C/C++、Java、Python 等。

# 1. 机器语言

计算机能够直接识别的是二进制数0和1组成的代码。机器指令（Instruction）就是用二

00

进制编码的命令，一条机器指令控制计算机完成一个操作。每种处理器都有各自的机器指令集，某处理器支持的所有指令的集合就是该处理器的指令集（Instruction Set）。指令集及使用它们编写程序的规则被称为机器语言（Machine Language）。

用机器语言形成的程序是计算机唯一能够直接识别并执行的程序，用其他语言编写的程序必须经过翻译，转换成机器语言程序，所以机器语言程序常称为目标程序（或目的程序）。

机器指令一般由操作码（Opcode）和操作数（Operand）构成。操作码表明处理器要进行的操作，操作数表明参加操作的数据对象。一条机器指令是一组二进制代码，一个机器语言程序就是一段二进制代码序列。因为二进制数表达比较烦琐，常用对应的十六进制数形式表达。例如，完成两个数据100和256相加的功能，在8086CPU上用十六进制数表达的代码序列如下：

B86400

050001

几乎没有人能够直接读懂该程序段的功能，因为机器语言看起来就是毫无意义的一串代码。

用机器语言编写程序的最大缺点是，难以理解，极易出错，也难以发现错误。所以，只是在计算机发展的早期或不得已的情况下，才用机器语言编写程序。现在，除了有时在程序某处需要直接采用机器指令填充外，几乎没有人采用机器语言编写程序了。

# 2. 汇编语言

为了克服机器语言的缺点，人们采用便于记忆并能描述指令功能的符号来表示机器指令。表示指令操作码的符号称为指令助记符，简称助记符（Memonic），一般是表明指令功能的英语单词或其缩写。指令操作数同样可以用易于记忆的符号表示。

用助记符表示的指令就是汇编格式指令。汇编格式指令及使用它们编写程序的规则形成汇编语言（Assembly Language）。用汇编语言书写的程序就是汇编语言程序，或称为汇编语言源程序。例如，实现100与256相加的MASM汇编语言程序段表达如下：

mov ax, 100

;取得一个数据100 (mov是传送指令)

add ax, 256

; 实现  $100 + 256$  (add 是加法指令)

这时候，如果熟悉了有关助记符及对应指令的功能，就可以读懂上述程序段了。

汇编语言是一种符号语言,用助记符表示操作码,比机器语言容易理解和掌握,也容易调试和维护。但是,汇编语言源程序要翻译成机器语言程序才可以由处理器执行。这个翻译的过程被称为“汇编”,完成汇编工作的程序就是汇编程序(Assembler)。

# 3. 高级语言

汇编语言虽然较机器语言直观一些，但仍然烦琐难记。于是在20世纪50年代，人们研制出了高级程序设计语言（High-level Programming Language），简称高级语言。高级语言比较接近于人类自然语言的语法习惯及数学表达形式，与具体的计算机硬件无关，更容易被广大计算机工作者掌握和使用。利用高级语言，即使一般的计算机用户也可以编写软件，而不必懂得计算机的结构和工作原理。当然，用高级语言编写的源程序不会被机器直接执行，而需经过编译或解释程序的翻译才可变为机器语言程序。

广泛应用的高级语言有十多种，如简单易用的BASIC语言、算法语言FORTRAN、结构化语言Pascal、系统程序语言C/C++等。用高级语言表达100与256相加，就是通常的数学表示形式“100+256”。

4

# 4. 汇编语言程序设计的意义

高级语言简单、易学，而汇编语言复杂、难懂，是否就没有必要采用汇编语言了呢？首先来看汇编语言和高级语言的特点。

① 汇编语言与处理器密切相关。每种处理器都有自己的指令系统，相应的汇编语言各不相同，所以汇编语言程序的通用性、可移植性较差。相对来说，高级语言与具体计算机无关，高级语言程序可以在多种计算机上编译后执行。  
② 汇编语言功能有限，又涉及寄存器、主存单元等硬件细节，所以编写程序比较烦琐，调试起来也比较困难。高级语言提供了强大的功能，采用类似自然语言的语法，所以容易被掌握和应用，也不必关心诸如标志、堆栈等琐碎问题。  
③ 汇编语言本质上就是机器语言，可以直接、有效地控制计算机硬件，因而容易产生运行速度快、指令序列短小的高效率目标程序。高级语言不易直接控制计算机的各种操作，编译程序产生的目标程序往往比较庞大、程序难以优化，所以运行速度较慢。

可见，汇编语言的主要优点就是可以直接控制计算机硬件部件，可以编写在“时间”和“空间”方面最有效的程序，使得汇编语言在程序设计中占有重要的位置，是不可被取代的。

汇编语言的缺点也是明显的。它与处理器密切相关，要求程序员比较熟悉计算机硬件系统、考虑许多细节问题，导致编写程序烦琐，调试、维护、交流和移植困难。因此，有时可以采用高级语言和汇编语言混合编程的方法，取长补短，更好地解决实际问题。

汇编语言主要应用场合如下。

(1) 程序要具有较快的执行时间, 或者只能占用较小的存储空间, 如操作系统的核心程序段、实时控制系统的软件、智能仪器仪表的控制程序等。  
(2) 程序与计算机硬件密切相关, 程序要直接、有效地控制硬件, 如 I/O 接口电路的初始化程序段、外部设备的低层驱动程序等。  
③ 大型软件需要提高性能、优化处理的部分，如计算机系统频繁调用的子程序、动态链接库等。  
④ 没有合适的高级语言或只能采用汇编语言的时候，如开发最新的处理器程序时、暂时没有支持新指令的编译程序。  
⑤ 汇编语言还有许多实际应用, 如分析具体系统尤其是该系统的低层软件、加密解密软件、分析和防治计算机病毒等。

事实上，汇编语言被称为低层程序设计语言（Low-level Programming Language）更合适。因为程序设计语言是按照计算机系统的层次结构区分的，本没有“高低贵贱”之分，只是某种语言更适合某种应用层面（或说场合）而已。

# 1.2 数据表示

计算机只能识别 0 和 1 两个数码，进入计算机的任何信息都要转换成 0 和 1 数码。整数指令支持的基本数据类型是 8、16、32、64 位无符号整数和有符号整数，也支持字符、字符串和 BCD 码操作。本节主要介绍这些数据类型的数据表示。

# 1.2.1 数制

人有 10 个手指, 所以习惯了十进制计数。计算机的硬件基础是数字电路, 它处理具有低

电平和高电平两种稳定状态的电平信号，所以使用了二进制。为了便于表达二进制数，人们又常用到十六进制数。

为了便于区别各种进制的数据，汇编语言中通常使用后缀字母B或b结尾表示一个数据采用二进制（Binary）表达，使用后缀字母H或h结尾表示采用十六进制（Hexadecimal）表达。而十进制（Decimal）数据可以用后缀字母D或d结尾，以示强调或区别，也可以按照习惯不加任何结尾字母。在高级语言C/C++中，表示十六进制数要添加前缀0x。

# 1. 二进制

计算机中为便于存储及物理实现，采用二进制表达数值。

二进制数的特点为：逢2进1,由0和1两个数码组成,基数为2,各位权以  ${2}^{k}$  表示。例如,二进制数  ${a}_{n}{a}_{n - 1}\cdots {a}_{1}{a}_{0}{b}_{1}{b}_{2}\cdots {b}_{m}$  可表示为

$$
a _ {n} \times 2 ^ {n} + a _ {n - 1} 2 ^ {n - 1} + \dots + a _ {1} \times 2 ^ {1} + a _ {0} \times 2 ^ {0} + b _ {1} \times 2 ^ {- 1} + b _ {2} \times 2 ^ {- 2} + \dots + b _ {m} \times 2 ^ {- m}
$$

其中，  $a_{i}$  、  $b_{j}$  非0即1。

二进制数的算术运算类似十进制，只不过是逢2进1、借1当2，如表1-1所示。

表 1-1 二进制运算规则  

<table><tr><td>加法运算</td><td>减法运算</td><td>乘法运算</td></tr><tr><td>1+0=1</td><td>1-0=1</td><td>1×0=0</td></tr><tr><td>1+1=0（进位1）</td><td>1-1=0</td><td>1×1=1</td></tr><tr><td>0+0=0</td><td>0-0=0</td><td>0×0=0</td></tr><tr><td>0+1=1</td><td>0-1=1（借位1）</td><td>0×1=0</td></tr></table>

【例1.1】4位二进制数的算术运算。

$1101 + 0011 = 0000$  （进位1）

1101-0011=1010

1101×0011=00100111

$01001001 \div 1101 = 0101$  （余数1000）

图1-2示例了上述4位二进制的加减乘除运算，注意加减法会出现进位或借位，乘积和被除数是双倍长的数据，除法有商和余数两部分。

$$
\begin{array}{c} 1 1 0 1 \\ + \quad 0 0 1 1 \\ \hline 1 0 0 0 0 \end{array}
$$

(a) 加法

$$
\begin{array}{c} 1 1 0 1 \\ - \quad 0 0 1 1 \\ \hline 1 0 1 0 \end{array}
$$

(b) 减法

$$
\begin{array}{c} 1 \quad 1 0 1 \\ \times \quad 0 0 1 1 \\ \hline 1 1 0 1 \\ + \quad 1 1 0 1 \\ \hline 1 0 0 1 1 1 \end{array}
$$

(c) 乘法

$$
\frac {1 0 1}{\begin{array}{c} 1 0 0 1 0 0 1 \\ - 1 1 0 1 \\ \hline 0 1 0 1 0 1 \\ - 1 1 0 1 \\ \hline 1 0 0 0 \end{array} }
$$

(d) 除法

图1-2 二进制数的算术运算

# 2.十六进制

由于二进制数书写较长、难以辨认，因此常用易于与之转换的十六进制数来描述二进制数。十六进制数的基数是16，共有16个数码：0、1、2、3、4、5、6、7、8、9和A、B、C、D、E、F（也可以使用小写字母a～f，依次表示十进制的  $10\sim 15$ ），逢16进位，各个位的位权为 $16^{k}$ 。例如，十六进制数  $a_{n}a_{n - 1}\dots a_{1}a_{0}b_{1}b_{2}\dots b_{m}$  可以表达为

$$
a _ {n} \times 1 6 ^ {n} + a _ {n - 1} 1 6 ^ {n - 1} + \dots + a _ {1} \times 1 6 ^ {1} + a _ {0} \times 1 6 ^ {0} + b _ {1} \times 1 6 ^ {- 1} + b _ {2} \times 1 6 ^ {- 2} + \dots + b _ {m} \times 1 6 ^ {- m}
$$

其中，  $a_{i}$  、  $b_{j}$  为  $0\sim 9$  和  $\mathrm{A}\sim \mathrm{F}$  中的一个数码。

涉及计算机学科知识的文献中，常使用十六进制数表达地址、数据、指令代码等，需要熟

悉十六进制数的加减运算。十六进制数的加减运算也类似十进制, 但注意逢 16 进位 1 , 借 1 当 16 。例如,  $23 \mathrm{D} 9 \mathrm{H} + 94 \mathrm{BEH} = \mathrm{B} 8 9 7 \mathrm{H}, \mathrm{A} 5 9 \mathrm{FH} - 62 \mathrm{~B} 8 \mathrm{H} = 42 \mathrm{E} 7 \mathrm{H}$ , 这里的后缀字母 H (或小写 h) 表示十六进制形式表达的数据。

# 3. 数制之间的转换

【例1.2】 十进制整数转换为二进制数和十六进制数。

$$
1 2 6 = 0 1 1 1 1 1 1 0 \mathrm {B} = 7 \mathrm {E H}
$$

十进制数的整数部分转换为二进制数和十六进制数可用除法，把要转换的十进制数的整数部分不断除以二进制和十六进制数的基数2或16，并记下余数，直到商为0为止。由最后一个余数起逆向取各余数，则为该十进制数整数部分转换成的二进制和十六进制数，如图1-3所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/cb51a83c94e572ee7cf63fd7db66b207af992d6ae6cea76d1f26726d8d67a1a2.jpg)  
图1-3 十进制整数的转换

【例1.3】十进制小数转换为二进制数和十六进制数

$$
0. 8 1 2 5 = 0. 1 1 0 1 \mathrm {B} = 0. \mathrm {D H}
$$

十进制数的小数部分转换为二进制数和十六进制数需要分别乘以各自的基数，记录整数部分，直到小数部分为0为止或者选取一定的位数，如图1-4所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/962120b4b87af449729093db55de0226bb50a67bdd96668df55489f2625e013a.jpg)  
图1-4 十进制小数的转换

小数部分的转换会发生总是无法乘到为0的情况，这时可选取一定位数（精度）。当然，这将产生无法避免的转换误差。

【例1.4】二进制数和十六进制数转换为十进制数。

$$
0 0 1 1. 1 0 1 0 \mathrm {B} = 1 \times 2 ^ {1} + 1 \times 2 ^ {0} + 1 \times 2 ^ {- 1} + 0 \times 2 ^ {- 2} + 1 \times 2 ^ {- 3} = 3. 6 2 5
$$

$$
1. 2 H = 1 \times 1 6 ^ {0} + 2 \times 1 6 ^ {- 1} = 1. 1 2 5
$$

二进制数、十六进制数转换为十进制数，可分别套用各自的按权展开公式。

【例1.5】二进制数和十六进制数相互转换。

$$
0 0 1 1 1 0 1 0 \mathrm {B} = 3 \mathrm {A H} \quad \mathrm {F} 2 \mathrm {H} = 1 1 1 1 0 0 1 0 \mathrm {B}
$$

二进制和十六进制数之间具有对应关系：以小数点为基准，整数从右向左（从低位到高位）小数从左向右（从高位到低位），每4个二进制位对应一个十六进制位，如表1-2所示，所以相互转换非常简单。表1-2还给出了BCD码以及常用的二进制位权值。

表 1-2 不同进制间(含 BCD 码)的对应关系  

<table><tr><td>十进制</td><td>二进制</td><td>十六进制</td><td>BCD码</td></tr><tr><td>0</td><td>0000</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0001</td><td>1</td><td>1</td></tr><tr><td>2</td><td>0010</td><td>2</td><td>2</td></tr><tr><td>3</td><td>0011</td><td>3</td><td>3</td></tr><tr><td>4</td><td>0100</td><td>4</td><td>4</td></tr><tr><td>5</td><td>0101</td><td>5</td><td>5</td></tr><tr><td>6</td><td>0110</td><td>6</td><td>6</td></tr><tr><td>7</td><td>0111</td><td>7</td><td>7</td></tr><tr><td>8</td><td>1000</td><td>8</td><td>8</td></tr><tr><td>9</td><td>1001</td><td>9</td><td>9</td></tr><tr><td>10</td><td>1010</td><td>A</td><td></td></tr><tr><td>11</td><td>1011</td><td>B</td><td></td></tr><tr><td>12</td><td>1100</td><td>C</td><td></td></tr><tr><td>13</td><td>1101</td><td>D</td><td></td></tr><tr><td>14</td><td>1110</td><td>E</td><td></td></tr><tr><td>15</td><td>1111</td><td>F</td><td></td></tr></table>

<table><tr><td>常用二进制位权</td></tr><tr><td>2-3=0.125</td></tr><tr><td>2-2=0.25</td></tr><tr><td>2-1=0.5</td></tr><tr><td>20=1</td></tr><tr><td>21=2</td></tr><tr><td>22=4</td></tr><tr><td>23=8</td></tr><tr><td>24=16</td></tr><tr><td>25=32</td></tr><tr><td>26=64</td></tr><tr><td>27=128</td></tr><tr><td>28=256</td></tr><tr><td>29=512</td></tr><tr><td>210=1024</td></tr><tr><td>215=32768</td></tr><tr><td>216=65536</td></tr></table>

# 1.2.2 数值的编码

编码是用文字、符号或者数码来表示某种信息（数值、语言、操作指令、状态等）的过程。组合0和1数码就是二进制编码。用0和1数码的组合在计算机中表达的数值被称为机器数；对应地，现实中真实的数值被称为真值。数值主要有两种编码方式：定点格式和浮点格式。定点整数是本书的主要讨论对象，浮点实数将在第8章介绍。

# 1. 定点整数

定点格式固定小数点的位置表达数值，计算机中通常将数值表达成纯整数或纯小数，这种机器数称为定点数。整数可以将小数点固定在机器数的最右侧，实际上并不用表达出来，这就是整数处理器支持的定点整数，如图1-5所示。如果将小数点固定在机器数的最左侧就是定点小数。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/7f64a40bdf5bdccfd76a52b9ad8abaa49f0a014f4b032f18210061eb3a815b5b.jpg)  
图1-5 定点整数格式

如果不考虑正负，定点整数只表达0和正整数，就是无符号整数（简称无符号数）。在上面的数值转换和运算中，默认采用无符号整数。8位二进制有256个编码，依次是：00000000、

008

00000001、00000010、…、11111110、11111111，使用十六进制形式是：00、01、02、…、FE、FF。对应表达无符号整数正值为：0、1、2、…、254、255。

$n$  位二进制共有  $2^{n}$  个编码，表达真值： $0 \sim 2^{n} - 1$ 。例如，16 位和 32 位二进制所能表示的无符号整数范围分别是： $0 \sim 2^{16} - 1$  和  $0 \sim 2^{32} - 1$ 。

如果要表达数值正负，需要占用一个位，通常用机器数的最高位（故称为符号位），用0表示正数、1表示负数，这就是有符号整数（简称有符号数、带符号数）。有符号整数有多种表达形式，如原码、反码、补码等，计算机中默认采用补码，如表1-3所示。

表 1-3 8 位二进制数的原码、反码和补码  

<table><tr><td>十进制数</td><td>原 码</td><td>反 码</td><td>补 码</td></tr><tr><td>+127</td><td>01111111</td><td>01111111</td><td>01111111</td></tr><tr><td>+126</td><td>01111110</td><td>01111110</td><td>01111110</td></tr><tr><td>+2</td><td>00000010</td><td>00000010</td><td>00000010</td></tr><tr><td>+1</td><td>00000001</td><td>00000001</td><td>00000001</td></tr><tr><td>+0</td><td>00000000</td><td>00000000</td><td>00000000</td></tr><tr><td>-0</td><td>10000000</td><td>11111111</td><td>00000000</td></tr><tr><td>-1</td><td>10000001</td><td>11111110</td><td>11111111</td></tr><tr><td>-2</td><td>10000010</td><td>11111101</td><td>11111110</td></tr><tr><td>-126</td><td>11111110</td><td>10000001</td><td>10000010</td></tr><tr><td>-127</td><td>11111111</td><td>10000000</td><td>10000001</td></tr><tr><td>-128</td><td></td><td></td><td>10000000</td></tr></table>

# 2. 原码

最高有效位表示符号（正数用0，负数用1），其他位直接表示数值大小；有符号数的这种表示法就称为原码表示法。

【例1.6】有符号数的原码表示

$$
X = 1 0 5 = 0 1 1 0 1 0 0 1 \mathrm {B}
$$

$$
[ X ] _ {\text {原}} = 0 1 1 0 1 0 0 1 \mathrm {B}
$$

$$
X = - 1 0 5
$$

$$
[ X ] _ {\text {原}} = 1 1 1 0 1 0 0 1 \mathrm {B}
$$

其中, 最高位为符号位, 在字长为 8 位时, 后面 7 位是数值 (若字长为 16 位, 则后面的 15 位是数值)。例如, 用原码表示有符号数时, +105 和 -105 它们的数值位相同, 而符号位不同。

原码表示简单易懂，而且与实际的“真值”转换方便。但若是两个异号数相加（或两个同号数相减），就要做减法。为了把减法运算转换为加法运算，以便只使用加法电路实现加减运算，就引进了反码和补码。

# 3. 反码

正数的反码与原码相同，最高符号位用0表示，其余位为数值位。负数的反码则为它的正数的各位（包括符号位）按位取反而形成的，即：0变成1，1变成0。

【例1.7】有符号数的反码表示。

$$
X = 1 0 5 = 0 1 1 0 1 0 0 1 \mathrm {B}
$$

$$
[ X ] _ {\text {反}} = 0 1 1 0 1 0 0 1 \mathrm {B}
$$

$$
X = - 1 0 5
$$

$$
[ X ] _ {\text {反}} = 1 0 0 1 0 1 1 0 \mathrm {B}
$$

负数的反码与原码有很大的区别：最高符号位仍用1表示，但数值位不同。

对于数值0，在原码和反码中有  $+0$  和  $-0$  两种表示法。所以，8位二进制原码和反码所能表示的数值范围为  $+127 \sim -127$  。

# 4. 补码

补码中最高位表示符号：正数用0，负数用1；正数补码同无符号数，直接表示数值大小。负数补码是将对应正数补码取反（即将0变为1，1变为0）、然后加1形成。

【例1.8】有符号数的补码表示。

$$
\mathrm {X} = 1 0 5 = 0 1 1 0 1 0 0 1 \mathrm {B}
$$

$$
[ X ] _ {n} = 0 1 1 0 1 0 0 1 B
$$

$$
\mathrm {X} = - 1 0 5
$$

$$
[ \mathrm {X} ] _ {\text {补}} = [ 0 1 1 0 1 0 0 1 \mathrm {B} ] _ {\text {收 及}} + 1 = 1 0 0 1 0 1 1 0 \mathrm {B} + 1 = 1 0 0 1 0 1 1 1 \mathrm {B}
$$

8位带符号位的补码也列在表1-3中。它不分所谓  $+0$  或  $-0$  ，0只有一个表示形式。8位进制补码所能表示的数值为  $+127\sim -128$  。

【例1.9】一个负数在用补码表示时，需要一个“取反加1”的过程。

$$
[ 2 0 \mathrm {H} ] _ {\text {反}} = [ 2 0 \mathrm {H} ] _ {\text {反}} = [ 2 0 \mathrm {H} ] _ {\text {补}} = 0 0 1 0 0 0 0 0 \mathrm {B}
$$

$$
[ - 2 0 \mathrm {H} ] _ {\text {B}} = 1 0 1 0 0 0 0 0 \mathrm {B}
$$

$$
[ - 2 0 \mathrm {H} ] _ {\text {反}} = 1 1 0 1 1 1 1 1 \mathrm {B}
$$

$$
[ - 2 0 \mathrm {H} ] _ {\text {补}} = 1 1 1 0 0 0 0 0 \mathrm {B}
$$

正数的补码表示与原码、反码和无符号数相同，即最高符号位为0表示正，其余位为数值位。负数的补码则为原码的反码并在最低有效位（即  $\mathbf{D}_0$  位）加1所形成。

【例1.10】将一个负数的补码转换成真值时，也需要一个“取反加1”的过程。

$$
[ 1 1 1 0 0 0 0 0 \mathrm {B} ] _ {\text {补}} = - (0 0 0 1 1 1 1 1 \mathrm {B} + 1) = - 0 0 1 0 0 0 0 0 \mathrm {B} = - 2 ^ {5} = - 3 2
$$

进行负数求补运算，在数学上等效于用带借位的0作减法（下面等式中用[]表达借位）。

例如：

真值：-8

$$
\text {补 码 ：} [ - 8 ] _ {\text {补 码}} = [ 1 ] 0 - 8 = [ 1 ] 0 0 0 0 0 0 0 0 B - 0 0 0 0 1 0 0 0 B = 1 1 1 1 0 0 0 B
$$

补码：1111000B

$$
\text {真 值 ：} - ([ 1 ] 0 0 \dot {0} 0 0 0 0 0 0 B - 1 1 1 1 1 0 0 0 B) = - 0 0 0 0 1 0 0 0 B = - 8
$$

注意, 求补只针对负数进行, 正数不需要求补。另外, 十六进制更便于表达, 上述运算过程可以直接使用十六进制数。

由于符号要占用一个数位, 8 位二进制补码中只有 7 个数位表达数值, 其所能表示的数值范围是:  $-128 \sim -1$  、  $0 \sim +127$ , 对应补码是:  $10000000 \sim 11111111$  、  $00000000 \sim 01111111$ , 若用十六进制表达是:  $80 \sim \mathrm{FF}, 00 \sim 7 \mathrm{~F}$  。16 位和 32 位二进制补码所能表示的数值范围分别是:  $-2^{15} \sim +2^{15}-1$  、  $-2^{31} \sim +2^{31}-1$  。用  $n$  位二进制编码有符号整数, 仍有  $2^{n}$  个编码, 但表达的真值范围是:  $-2^{n}-1 \sim +2^{n-1}-1$  。使用补码表达有符号整数, 和无符号整数表达的数值个数一样, 但范围不同。

因为采用补码，减法运算可以变换成加法运算，这样硬件电路只需设计加法器，所以在计算机中，有符号数默认采用补码形式。

# 1.2.3 字符的编码

在计算机中，各种字符需要用若干位的二进制码的组合表示，即字符的二进制编码。由于字节为计算机的基本存储单位，所以常以8个二进制位为单位表达字符。

# 1. BCD

一个十进制数位在计算机中用4位二进制编码来表示，这就是二进制编码的十进制数BCD（Binary Coded Decimal）。常用的BCD码是8421BCD码，用4位二进制编码的低10个编码表示  $0\sim 9$  这10个数字，见表1-2。

【例1.11】BCD码和十进制真值之间的转换

010

BCD码：010010010111000.000101001001B

对应的十进制真值：4978.149

BCD 码比较直观，很容易实现与十进制真值之间的转换。实际上，BCD 码和十进制数的相互转换，与二进制数和十六进制数相互转换一样，都是二进制（BCD 码）4 位对应十六进制（十进制）1 位。而且 BCD 码更简单，因为它没有使用大于 10 的 6 个编码。

BCD 码虽然浪费了 6 个编码，但能够比较直观地表达十进制数，也容易与 ASCII 相互转换，便于输入、输出，还可以比较精确地表达数据。例如，对于一个简单的数据 0.2，采用浮点格式（详见第 8 章）无法精确表达，采用 BCD 码可以只使用“0010”表达。最初的计算机支持十进制运算，8086 处理器中使用调整指令实现十进制运算。

实际应用中，通常至少使用1字节表达数值。如果将二进制8位即1字节的高4位设置为0，仅用低4位表达一位BCD码，则被称为非压缩（Unpacked）BCD码；通常用1字节表达两位BCD码，就被称为压缩（Packed）BCD码。

【例1.12】十进制真值“87”分别使用压缩BCD码和非压缩BCD码表达。

压缩BCD码：10000111B（87H） 非压缩BCD码：0000100000000111B（0807H）

# 2. ASCI 业

字母和各种字符也必须按特定的规则用二进制编码才能在计算机中表示。编码方式可以有多种, 其中最常用的是 ASCII (American Standard Code for Information Interchange, 美国标准信息交换码)。现在使用的 ASCII 码源于 20 世纪 50 年代, 完成于 1967 年, 由美国标准化组织 ANSI 定义在 ANSI X3.4-1986 中。

标准 ASCII 用 7 位二进制编码, 故有 128 个, 如表 1-4 所示。计算机存储单位为 8 位, 表达 ASCII 时最高  ${\mathrm{D}}_{7}$  位通常作为 0 ; 通信时,  ${\mathrm{D}}_{7}$  位通常用作奇偶校验位。

ASCII 表中的前 32 个和最后一个编码是不可显示的控制字符,用于表示某种操作。并不是所有设备都支持这些控制字符,也不是所有设备都按照同样的功能应用这些控制字符。不过, 有些控制字符获得广泛使用。例如,  $\mathrm{{ODH}}$  表示回车  $\mathrm{{CR}}$  (Carriage Return),控制屏幕光标时就是使光标回到本行首位；0AH表示换行 LF(Line Feed),使光标进入下一行,但列位置不变； 08H 实现退格 BS(Backspace),7FH 实现删除 DEL (Delete)。另外,07H表示响铃 BEL(Bell), 1BH(ESC)常对应键盘的 Esc 键(多数人称其为 Escape 键)。ESC(Extra Services Control) 字符常与其他字符一起发送给外设(如打印机),用于启动一种特殊功能,很多程序中常使用它表示退出操作。

ASCII表中从20H开始(含20H)的95个编码是可显示和打印的字符,其中包括数码、 英文字母、标点符号等。从表中可看到,数码0~9的ASCII编码为30H~39H,去掉高4位 (或者说减去  ${30}\mathrm{H}$  )就是(非压缩)BCD码。大写字母  $\mathrm{A} \sim  \mathrm{Z}$  的ASCII编码为  ${41}\mathrm{H} \sim  5\mathrm{{AH}}$  ,而小写字母  $\mathrm{a} \sim  \mathrm{z}$  是  ${61}\mathrm{H} \sim  7\mathrm{{AH}}$  。大写字母和对应的小写字母相差  ${20}\mathrm{H}\left( {32}\right)$  ,所以大、小写字母容易相互转换。ASCII中的20H表示空格,尽管显示空白,但要占据一个字符的位置,也是一个字符,用SP(Space)表示。熟悉这些字符的ASCII规律对解决一些应用问题很有帮助,如英文字符就是按照其 ASCII 编码的大小进行排序的。

处理器只是按照二进制数操作字符编码，并不区别可显示（打印）字符和非显示（控制）字符，只有外部设备才区别对待，产生不同的作用。例如，ASCII字符设备总是以ASCII形式处理数据，要显示（打印）数字“8”，必须将其ASCII编码（38H）给显示器（打印机）。

表 1-4 标准 ASCII 编码及对应字符  

<table><tr><td>ASCII</td><td>字符</td><td>ASCII</td><td>字符</td><td>ASCII</td><td>字符</td><td>ASCII</td><td>字符</td></tr><tr><td>00H</td><td>NUL</td><td>20H</td><td>SP</td><td>40H</td><td>@</td><td>60H</td><td>&#x27;</td></tr><tr><td>01H</td><td>SOH</td><td>21H</td><td>!</td><td>41H</td><td>A</td><td>61H</td><td>a</td></tr><tr><td>02H</td><td>STX</td><td>22H</td><td>&quot;</td><td>42H</td><td>B</td><td>62H</td><td>b</td></tr><tr><td>03H</td><td>ETX</td><td>23H</td><td>#</td><td>43H</td><td>C</td><td>63H</td><td>c</td></tr><tr><td>04H</td><td>EOT</td><td>24H</td><td>$</td><td>44H</td><td>D</td><td>64H</td><td>d</td></tr><tr><td>05H</td><td>ENQ</td><td>25H</td><td>%</td><td>45H</td><td>E</td><td>65H</td><td>e</td></tr><tr><td>06H</td><td>ACK</td><td>26H</td><td>&amp;</td><td>46H</td><td>F</td><td>66H</td><td>f</td></tr><tr><td>07H</td><td>BEL</td><td>27H</td><td>&#x27;</td><td>47H</td><td>G</td><td>67H</td><td>g</td></tr><tr><td>08H</td><td>BS</td><td>28H</td><td>(</td><td>48H</td><td>H</td><td>68H</td><td>h</td></tr><tr><td>09H</td><td>HT</td><td>29H</td><td>)</td><td>49H</td><td>I</td><td>69H</td><td>i</td></tr><tr><td>0AH</td><td>LF</td><td>2AH</td><td>*</td><td>4AH</td><td>J</td><td>6AH</td><td>j</td></tr><tr><td>0BH</td><td>VT</td><td>2BH</td><td>+</td><td>4BH</td><td>K</td><td>6BH</td><td>k</td></tr><tr><td>0CH</td><td>FF</td><td>2CH</td><td>,</td><td>4CH</td><td>L</td><td>6CH</td><td>l</td></tr><tr><td>0DH</td><td>CR</td><td>2DH</td><td>-</td><td>4DH</td><td>M</td><td>6DH</td><td>m</td></tr><tr><td>0EH</td><td>SO</td><td>2EH</td><td>.</td><td>4EH</td><td>N</td><td>6EH</td><td>n</td></tr><tr><td>0FH</td><td>SI</td><td>2FH</td><td>/</td><td>4FH</td><td>O</td><td>6FH</td><td>o</td></tr><tr><td>10H</td><td>DLE</td><td>30H</td><td>0</td><td>50H</td><td>P</td><td>70H</td><td>p</td></tr><tr><td>11H</td><td>DC1</td><td>31H</td><td>1</td><td>51H</td><td>Q</td><td>71H</td><td>q</td></tr><tr><td>12H</td><td>DC2</td><td>32H</td><td>2</td><td>52H</td><td>R</td><td>.72H</td><td>r</td></tr><tr><td>13H</td><td>DC3</td><td>33H</td><td>3</td><td>53H</td><td>S</td><td>73H</td><td>s</td></tr><tr><td>14H</td><td>DC4</td><td>34H</td><td>4</td><td>54H</td><td>T</td><td>74H</td><td>t</td></tr><tr><td>15H</td><td>NAK</td><td>35H</td><td>5</td><td>55H</td><td>U</td><td>75H</td><td>u</td></tr><tr><td>16H</td><td>SYN</td><td>36H</td><td>6</td><td>56H</td><td>V</td><td>76H</td><td>v</td></tr><tr><td>17H</td><td>ETB</td><td>37H</td><td>7</td><td>57H</td><td>W</td><td>77H</td><td>w</td></tr><tr><td>18H</td><td>CAN</td><td>38H</td><td>8</td><td>58H</td><td>X</td><td>78H</td><td>x</td></tr><tr><td>19H</td><td>EM</td><td>39H</td><td>9</td><td>59H</td><td>Y</td><td>79H</td><td>y</td></tr><tr><td>1AH</td><td>SUB</td><td>3AH</td><td>:</td><td>5AH</td><td>Z</td><td>7AH</td><td>z</td></tr><tr><td>1BH</td><td>ESC</td><td>3BH</td><td>;</td><td>5BH</td><td>[</td><td>7BH</td><td>{</td></tr><tr><td>1CH</td><td>FS</td><td>3CH</td><td>&lt;</td><td>5CH</td><td>\</td><td>7CH</td><td>|</td></tr><tr><td>1DH</td><td>GS</td><td>3DH</td><td>=</td><td>5DH</td><td>]</td><td>7DH</td><td>}</td></tr><tr><td>1EH</td><td>RS</td><td>3EH</td><td>&gt;</td><td>5EH</td><td>^</td><td>7EH</td><td>~</td></tr><tr><td>1FH</td><td>US</td><td>3FH</td><td>?</td><td>5FH</td><td>-</td><td>7FH</td><td>Del</td></tr></table>

另外，PC采用扩展的ASCII，主要表达各种制表用的符号等。扩展ASCII编码的最高D位为1，以与标准ASCII的区别。

# 3. Unicode

ASCII码表达了英文字符，却无法表达世界上所有语言的字符，如中文、日文、韩文、阿拉伯文等。为此，各国定义了各自的字符集，但相互之间并不兼容。例如，1981年我国制定了《信息交换用汉字编码字符集基本集GB2312—1980》国家标准（简称国标码）。规定每个汉字使用16位二进制编码即2字节表达，共计7445个汉字和字符。实际应用中，为了保持与标准ASCII兼容、不产生冲突，国标码2字节的最高位被设置为1，这称为汉字的机内码。不过，汉字机内码会与扩展ASCII冲突（因它们的最高位都是1），所以一些西文制表符有时会显示为莫明其妙的汉字。

为了解决世界范围的信息交流问题，1991年，国际上成立了统一码联盟（Unicode Consortium），制定了国际信息交换码Unicode。在其网站上对“什么是Unicode？”给出了如

12

下解答: “Unicode 给每个字符提供了一个唯一的数字, 不论是什么平台, 不论是什么程序, 不论是什么语言”。Unicode 使用 16 位编码, 能够对世界上所有语言的大多数字符进行编码, 并提供了扩展能力。Unicode 作为 ASCII 的超集, 与其保持兼容。Unicode 的前 256 个字符对应 ASCII 字符, 16 位编码的高字节为 0、低字节等于 ASCII 编码值。例如, 大写字母 A 的 ASCII 编码是 41H, 其 Unicode 的编码是 0041H。

现在 Unicode 已经越来越被大家认同，很多程序设计语言和计算机系统支持它。例如，Java 语言和微机 Windows 操作系统的默认字符集就是 Unicode。Unicode 标准还在发展，2017 年 6 月 20 日发布 Unicode 10.0.0 版本，详情请访问统一码联盟网站（http://www.unicode.org）。

# 1.3 Intel 80x86 系列微处理器

美国Intel（英特尔）公司是目前世界上最有影响的处理器生产厂家，也是世界上第一个微处理器芯片的生产厂家。Intel80x86系列微处理器一直是个人微机的主流处理器。汇编语言的主体是处理器指令，所以有必要了解一下其发展概况。

# 1.3.1 16位80x86微处理器

1971年，Intel公司生产的4位微处理器芯片4004宣告了微型计算机时代的到来。1972年，Intel公司开发了8位微处理器8008芯片，1974年生产了8080芯片。1977年，Intel公司将8080及其支持电路集成在一块集成电路芯片上，形成了性能更高的8位微处理器8085。1978年，Intel公司在其8位微处理器基础上，陆续推出了16位结构的8086、8088和80286等微处理器，它们在IBMPC系列机中获得广泛应用，被称为16位  $80\times 86$  微处理器。

# 1. 8086

1978年，Intel正式推出16位8086CPU，这是该公司生产的第一个16位结构微处理器芯片。8086芯片的对外引脚共40个，其中包括16位数据总线、20位地址总线，支持1MB（兆字节）主存容量、5MHz（兆赫兹）时钟频率。8086具有的所有指令，即指令系统（Instruction Set)，成为整个Intel  $80\times 86$  系列微处理器的16位基本指令集。

为了方便与当时的8位外部设备连接，1979年，Intel推出了被称为“准16位”的8088芯片。8088只是将外部数据总线设计为8位，内部仍保持16位结构，指令系统等都与8086相同。随后的Intel80186和Intel80188分别以8086和8088为核心并配以支持电路构成的芯片；但它们在8086指令系统的基础上新增若干条实用指令，涉及堆栈操作、输入/输出指令、移位指令、乘法指令、支持高级语言的指令。

# 2. 80286

1982年，Intel推出仍为16位结构的80286微处理器，但地址总线扩展为24位、即主存储器具有16MB容量。80286设计有与8086工作方式一样的实方式（RealMode)，新增了保护方式（ProtectedMode)。在实方式下，80286相当于一个快速8086。在保护方式下，80286提供了存储管理、保护机制和多任务管理的硬件支持。为支持保护方式，80286引入了系统指令，为操作系统等核心程序提供处理器控制功能。

013

# 1.3.2 IA-32微处理器

IBM PC 系列机的广泛应用推动了处理器芯片的生产。Intel 公司在推出 32 位结构的 80386 微处理器后，明确宣布 Intel 80386 芯片的指令集结构（Instruction Set Architecture，ISA）被确定为以后开发的  $80 \times 86$  系列微处理器的标准，称为英特尔 32 位结构：IA-32（Intel Architecture 32）。Intel 公司的 80386、80486、Pentium 各代微处理器被统称为 IA-32 微处理器或 32 位  $80 \times 86$  微处理器。由于通用微处理器的性能越来越强大，现在人们经常省略“微”字，直接称之为 IA-32 处理器或 32 位  $80 \times 86$  处理器。

# 1. 80386

1985年，Intel 80x86 CPU进入第3代80386。Intel 80386处理器采用32位结构，数据总线32位，地址总线也是32位，可寻址4GB主存，时钟频率有  $16\mathrm{MHz}$  、  $25\mathrm{MHz}$  和  $33\mathrm{MHz}$  。除保持与80286兼容外，80386又提供了虚拟8086工作方式（Virtual 8086 Mode）。虚拟8086方式是在保护方式下的一种特殊状态，类似8086工作方式但又接受保护方式的管理，能够模拟多个8086处理器。80386指令系统在兼容原16位80286指令系统基础上，全面升级为32位，还新增了有关位操作、条件设置等指令。

# 2. 80486

1989年，Intel公司出品80486CPU。从结构上来说，80486把80386处理器与80387数学协处理器和8KB高速缓冲存储器（Cache）集成在一个芯片上，使其性能大大提高。

传统上，中央处理单元CPU主要是整数处理器。为了协助处理器处理浮点数据（实数），Intel设计有数学协处理器，后被称为浮点处理单元（Floating-Point Unit，FPU）。配合8086和8088整数处理器的数学协处理器是8087，配合80286的是80287，80386采用80387。从Inte80486开始，FPU已经被集成到一个处理器中，80284指令系统包含了浮点指令，能够直接支持对浮点数据的处理。80486新增了用于多处理器和内部Cache操作的6条指令。

# 3. Pentium 系列

Pentium芯片原来应该被称为80586处理器，因为数字很难进行商标版权保护的缘故而特意取名。其实，Pentium源于希腊文“pente”（数字5），加上后缀-ium（化学元素周期表中命名元素常用的后缀）变化而来。同时，Intel公司为其取了一个响亮的中文名称：奔腾，并进行了商标注册，形成了系列产品。

Intel公司于1993年制造成功Pentium，于1995年正式推出Pentium Pro（原来被称为P6，即“高能奔腾”）。在处理器结构上，Pentium主要引入了超标量（Superscalar）技术，Pentium Pro主要采用了动态执行技术来提升处理器性能。它们增加了若干整数指令，完善了浮点指令。

前面所述的各代 IA-32 处理器，都新增了若干实用指令，但非常有限。为了顺应微机向多媒体和通信方向发展的趋势，Intel 公司及时在其处理器中加入了 MMX（Multimedia Extension，多媒体扩展）技术。MMX 技术于 1996 年正式公布，在 IA-32 指令系统中新增了 57 条整数运算多媒体指令，可以用这些指令对图像、音频、视频和通信方面的程序进行优化，使微型机对多媒体的处理能力较原来有了大幅度提升。MMX 指令应用于 Pentium 处理器就是 Pentium MMX（多能奔腾）。MMX 指令应用于 Pentium Pro 处理器就是 Pentium II，于 1997 年推出。

1999年，针对国际互联网和三维多媒体程序的应用要求，Intel在Pentium II的基础上新增了70条SSE（Streaming SIMD Extensions）指令（原称为MMX-2指令），开发了Pentium III。

014

SSE指令侧重于浮点单精度多媒体运算，极大地提高了浮点3D数据的处理能力。SSE指令类似AMD公司发布的3DNow!指令。这些多媒体指令具有显著的SIMD(Single Instruction Multiple Data，单指令多数据)处理能力，即一条指令可以同时进行多组数据的操作，现在统称为SIMD指令。

2000年11月，Intel公司推出Pentium4，新增76条SSE2指令集，侧重于增强浮点双精度多媒体运算能力。2003年的新一代Pentium4处理器新增了13条SSE3指令，用于补充完善SIMD11指令集。

# 1.3.3 Intel 64 处理器

随着互联网、多媒体、三维视频等的发展，信息时代的应用对计算机性能提出了越来越高的要求，32位单核处理器已不能适应这一要求。

# 1. Intel 64 结构

一直以来，80x86处理器的更新换代都保持与早期处理器的兼容，以便继续使用现有的软硬件资源。但是，Intel公司迟迟不愿将80x86处理器扩展为64位，这给了AMD公司一个机会。AMD公司是生产IA-32处理器兼容芯片的厂商，是Intel公司最主要的竞争对手。AMD公司的IA-32兼容处理器的价格低于Intel芯片，但性能没有超越对应的Intel芯片。于是，AMD公司于2003年9月率先推出支持64位、兼容80x86指令集结构的Athlon64处理器(K8核心)，将桌面PC引入了64位领域。

2005年，在PC用户对64位技术的企盼和AMD公司64位处理器的压力下，Intel公司推出了扩展存储器64位技术（Intel Extended Memory 64 Technology，Intel EM64T）。EM64T技术是IA-32结构的64位扩展，首先应用于支持超线程技术的Pentium4终极版（支持双核技术）和6xx系列Pentium4处理器。随着EM64T技术的出现，IA-32指令系统也扩展成为64位，后来被称为Intel64结构。之后的Pentium4处理器以及PentiumE系列多核处理器、酷睿（Core）2和酷睿i系列多核处理器等都支持Intel64结构。

Intel 64 结构为软件提供了 64 位线性地址空间，支持 40 位物理地址空间，并引入一个新的工作方式：32 位扩展工作方式（IA-32e）。IA-32e 除有一个运行 32 位和 16 位软件的兼容方式外，还有一个 64 位方式。在 64 位工作方式下，允许 64 位操作系统运行存取 64 位地址空间的应用程序，还可以存取 8 个附加的通用寄存器、8 个附加的 SIMD 多媒体寄存器、64 位通用寄存器和 64 位指令指针等。

# 2. 多核技术

单纯以提高时钟频率等传统的增加处理器复杂度的方法已经很难提升处理器性能，还将带来功耗剧增、发热量巨大的问题，于是多核（Multi-core）技术应运而生。多核处理器是在一个集成电路芯片上制作了两个或多个处理器执行核心，依靠多个处理器核心相互协作同时执行多个程序线程提升性能。基于不同的处理器内部结构，Intel也推出了多款多核处理器，主要有Intel奔腾E系列多核处理器、酷睿2和酷睿i系列多核处理器。

另一方面，SSE系列指令集继续丰富，酷睿2补充了SSE3指令（即32条SSSE3指令），又推出增加了54条指令的SSE4指令集。其中，47条指令在Intel面向服务器领域的至强(Xeon)5400系列和酷睿2至尊版QX9650引入，被称为SSE4.1指令，致力于提升多媒体、3D处理等的性能；其余7条指令被称为SSE4.2指令。

015

Intel公司充分利用集成电路生产的先进技术和处理器结构的革新技术，推出了多种  $\mathrm{80x86}$  系列处理器芯片。就目前的发展来看，Intel公司正在利用单芯片多处理器技术生产双四核等多核处理器，并推广支持64位处理器和64位软件的个人计算机。

# 1.4 微型计算机系统

1981年，IBM公司采用8088CPU推出了具有划时代意义的个人计算机——IBMPC，年底又推出了扩展型——PC/XT机。1984年，IBM用80286推出了增强型IBMPC/AT机。II PC、XT、AT通常被称为PC系列，它们都是16位的。后来的32位PC都是采用32位Intel  $80\mathrm{x}$  或其兼容的CPU而形成的微机，但其基本结构仍然源于PC/AT机。现在，人们谈论的微机PC（Personal Computer）就是上述微型计算机系统的统称。

# 1. PC的硬件

从外观上看，微机系统由如下几部分组成：主机、键盘和鼠标、显示器等。其中，键盘微机的标准输入设备，通过电缆与主板上的键盘接口相连；显示器是微机的标准输出设备，主机中的显示卡连接。键盘和显示器又合称为控制台（Console）。

主机一般是指机箱所包含的部分，其中最主要的部件是主机板（简称主板），还有硬盘光盘驱动器和电源等。主板又称为母板，是机箱内的一块大型印刷电路板。主板上有CPU、存储器、I/O接口电路，还有若干插槽用于扩展系统功能及外部接口连接外设。

16位PC一般采用8088或80286CPU，32位PC则采用32位  $80\times 86$  CPU或者与之兼容芯片。  $80\times 86$  兼容CPU执行同样的指令集，对应用程序来说是没有区别的。

# 2. 主存空间的分配

IBM PC 和 IBM PC/XT 机使用 8088 微处理器，支持 1MB 存储空间。IBM PC/AT 机使用 0286 微处理器，支持 16MB 存储空间。32 位 PC 使用 32 位 80x86 微处理器，具有 4GB 主存空间，其使用情况如图 1-6 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/72b9c578260669c33d7b3c8ec8f8ebfd6f0d16c54cc5e466dc6e9d4b6ae8dba2.jpg)  
图1-6PC的主存空间分配

8086 CPU 的地址线是 20 位的，这样其最大可寻址空间为  $2^{20}\mathrm{B} = 1\mathrm{MB}$ ，其地址范围为  $00000\mathrm{H} \sim \mathrm{FFFFFH}$ 。整个 1MB 主存空间从低位地址到高位地址可分为 4 个区段；基本 RAM 区、保留 RAM 区、扩展 ROM 区和基本 ROM 区。

① 基本 RAM 区（00000H～9FFFFFFH）：共 640 KB，由 DOS 进行管理。在这个区域中，操作系统要占用掉一部分低地址空间，其他则向用户程序开放。  
② 保留RAM区（A0000H～BFFFFFFH）：为系统安排的“显示缓冲存储区”，共128KB，由显卡上的RAM芯片提供支持，用于存放屏幕显示信息。但这部分地址空间实际上没有全部使用。  
(3) 扩展 ROM 区  $\left(\mathrm{C} 0000 \mathrm{H} \sim \mathrm{D} \mathrm{FFFH}\right)$ : 共  $128 \mathrm{KB}$ , 由 I/O 接口卡上的 ROM 芯片提供支持, 用于为系统不直接提供支持的外设安排设备驱动程序。用户固化的 ROM 程序就可安排在这一区段, 系统的 ROM-BIOS 会对它进行确认和连接。  
④ 系统 ROM 区（E0000H～FFFFFFH）：共 128 KB，由系统占用，主要提供 ROM-BIOS 程序。BIOS（Basic Input/Output System，基本输入/输出程序）是操作系统的重要组成部分，主要用来驱动输入、输出设备，也负责系统的上电检测、磁盘 DOS 引导等初始化操作。ROM-BIOS 中还有微机 CMOS 设置程序，以及供输出使用的字符/图符点阵信息等内容。

上述1MB被称为实方式主存，其空间分配在所有采用  $80\times 86$  微处理器的PC上都一样。其中，最低640KB的系统RAM区被称为常规主存（ConventionalMemory）或基本主存（BaseMemory），其后384KB主存称为上位主存区（UpperMemoryArea，UMA）。

对于80286的16MB主存、IA-32微处理器的4GB空间，1MB后的64KB可以作为高端主存区HMA使用，最后的64KB复制ROM-BIOS，其他主存空间都作为RAM区域使用，被称为扩展主存（ExtendedMemory）。扩展主存只能在保护方式使用。Lotus（莲花）、Intel（英特尔）、Microsoft（微软）和AST公司制定了扩展主存使用规范XMS（eXtendedMemory Specifications）。DOS（DiskOperationSystem，磁盘操作系统）5及以上系统中的himem.sys文件就是遵循该规范的驱动程序。

由于历史的原因，DOS不能直接管理1MB以上的主存，随着应用程序规模的增大，640KB的常规RAM成了非常宝贵的资源。为了充分利用主存空间，DOS5及以后版本可以利用himem.sys存储管理软件转换到保护方式来使用扩展内存。Windows、Linux等操作系统则重新规划了主存空间，使用虚拟存储器实现存储管理。

# 3. PC的软件

微机早期的操作系统是 DOS，其主要任务是进行文件管理和磁盘管理。DOS 平时驻留于磁盘上，在启动机器时才被调入内存。现在，通常使用它的最终版本 MS-DOS 6.22。由于 MS-DOS 是被设计运行在 8086 CPU 上的 1 MB 内存中，它的管理极限是  $640 \mathrm{KB}$  的基本 RAM 区。因而，DOS 不能直接管理更大的扩展内存，这一点限制了它的功能。现在，微机上常用的操作系统是 Windows，但 32 位 Windows 操作系统仍然保留了 MS-DOS 模拟环境。本书介绍的汇编语言程序设计环境主要运行在 DOS 平台或 32 位 Windows 的 MS-DOS 模拟环境中。不过，64 位 Windows 不再支持 16 位 MS-DOS 模拟环境。运行 16 位 DOS 应用程序需要使用虚拟机软件模拟 DOS 环境，如简单的 DOS Box 或者功能强大的 Vmware 虚拟机（详见第 3 章）。

PC上的应用软件可谓丰富多彩，但进行汇编语言程序设计主要利用如下一些软件。

$\diamond$  录入、修改源程序的文本编辑软件，如 DOS 的全屏幕编辑器 EDIT，Windows 的记事

017

本 Notepad，Turbo C 或 Visual Studio 集成开发系统中的编辑器。

$\diamond$  汇编源程序成为目标模块的汇编程序，本书采用微软的MASM6.x版本，较著名的还有TurboASM，两者差别不大。  
$\diamond$  连接目标模块为可执行程序的连接程序，如LINK程序，连接16位DOS程序的连接程序与连接32位Windows程序的连接程序不同。  
进行程序排错等的调试程序，本书附录介绍 DOS 的 DEBUG 程序和 MASM 配套的 CodeView。  
集编辑、汇编、连接和调试为一体的综合开发环境，如MASM的程序员工作平台PWB微软的Visual Studio开发系统。

20世纪80年代初，Microsoft公司推出MASM1.0，最后一个独立软件包是MASM6.11。MASM4.0支持80286/80287的处理器和协处理器；MASM5.0支持80386/80387处理器和协处理器，并加进了简化段伪定义指令和存储模式伪指令，汇编和连接的速度更快。MASM6.0是1991年推出的，支持80486处理器，对MASM进行重新组织，并提供了许多类似高级语言的新特点。MASM6.0之后又有一些改进，Microsoft又推出MASM6.11，利用它的免费补丁程序可以升级到MASM6.14，支持MMX Pentium、PentiumII及PentiumIII指令系统。以后的MASN都存在于VisualC++开发工具中。例如，可以从VisualC++6.0中复制出MASM6.15，以便支持Penium4的SSE2指令系统。VisualC++.NET2003中有MASM7.10，但没有什么大的更新VisualC++.NET2005提供的MASM才支持Penium4的SSE3指令系统，同时提供一个ML64.exe程序，用于支持64位指令系统。

本书主要以MASM6.x为标准，但大部分程序同样适合MASM5.x。为了方便初学者学习本书利用MASM6.x，介绍了用于模拟DOS环境（和32位控制台）开发汇编语言程序的有关软件，创建一个基本但完整的MASM6.15汇编语言开发系统，详见第3章。

# 1.5 8086微处理器

微处理器是微型计算机的硬件核心，即CPU。微处理器包括指令执行需要的运算和控制部件，还有暂存数据、地址等的寄存器。了解微处理器基本结构、熟悉其寄存器作用是学习指令系统的基础。

# 1.5.1 8086 的功能结构

Intel 公司按两大功能模块描绘了 8086 的内部结构, 如图 1-7 所示。相对于 8086 内部结构 8088 内部除指令队列为 4 字节、对外的数据总线是 8 位外, 其他都相同。

图1-7右半部分是总线接口单元（Bus Interface Unit，BIU），由6字节的指令队列、指令指针（IP）、段寄存器（CS、DS、SS、ES）、地址加法器和总线控制逻辑等构成。该单元管理着8086与外部总线的接口，负责CPU对存储器和外设进行访问。8086所连接的总线由16位双向数据线、20位地址线和若干控制线组成。

图1-7左半部分是执行单元（ExecutionUnit，EU），由算术逻辑单元ALU、数据寄存器、也址寄存器、标志寄存器和指令译码的EU控制逻辑等构成。EU负责指令的译码、执行和数据的运算。

18

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/acf1d64cb8388846c73c6f1af217645114df6aff318ba5b203449e2d8b10069f.jpg)  
图1-7 8086的内部结构

完成一条指令的功能可以分成两个主要阶段：取指和执行。

取指是从主存储器中取出指令代码进入CPU。8086 CPU中，指令在存储器中的地址由代码段寄存器CS和指令指针寄存器IP共同提供，再由地址加法器得到20位存储器地址。总线接口单元BIU负责从存储器取出这个指令代码，送入指令队列。

执行是将指令代码翻译成它代表的功能（被称为译码），并发出有关控制信号实现这个功能。在8086CPU中，EU从指令队列中获得预先取出的指令代码，在EU控制电路中进行译码，然后发出控制信号，由算术逻辑单元进行数据运算、数据传送等操作。指令执行过程需要的操作数据有些来自CPU内部的寄存器，有些来自指令队列，有些来自存储器和外设。如果需要来自外部存储器或外设的数据，则EU控制BIU从外部获取。

# 1.5.2 8086的寄存器

处理器内部需要高速存储单元，用于暂时存放程序执行过程中的代码和数据，这些存储单元被称为寄存器（Register）。处理器内部设计有多种寄存器，每种寄存器还可能有多个，从应用的角度可以分成两类：透明寄存器和可编程寄存器。

有些寄存器对应用人员来说不可见、不能直接控制，如保存指令代码的指令寄存器，它们被称为透明寄存器。这里的“透明（Transparency）”是计算机学科中常用的一个专业术语，表示实际存在但从某个角度看好像没有。“透明”思想可以使我们抛开不必要的细节，而专注于关键问题。

底层语言程序员需要掌握可编程（Programmable）寄存器。它们具有引用名称、供编程使用，还可以进一步分成通用寄存器和专用寄存器。

通用寄存器：在处理器中数量较多、使用频度较高，具有多种用途。例如，它们可用来存放指令需要的操作数据，可用来存放地址以便在主存或I/O接口中指定操作数据的位置。

专用寄存器：只用于特定目的。例如，8086的指令指针寄存器IP只用于记录将要执行指令的主存地址，标志寄存器保存指令执行的辅助信息。

019

图1-8是8086的寄存器组。8086的寄存器组分成8个通用寄存器、4个段寄存器、1个标志寄存器和1个指令指针寄存器，它们均为16位。本节介绍各寄存器的一般用途，具体应用将在每条指令的学习时详细论述。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/4554a9982eeed551968a5f648815d7ec893dde34711127edbc93b08c6eba7e4c.jpg)  
图1-8 8086的寄存器组

# 1. 通用寄存器

通用寄存器（General-Purpose Register）一般是指处理器最常使用的整数通用寄存器，可用于保存整数数据、地址等。8086 处理器有 8 个 16 位通用寄存器，分别被命名为：AX、BX、CX、DX、SI、DI、BP 和 SP。

通用寄存器是多用途的，可以保存数据、暂存运算结果，也可以存放存储器地址、作为变量的指针。但在 8086 处理器中，每个寄存器又有它们各自的特定作用，并因而得名。程序中通常也按照其含义使用它们，如表 1-5 所示。

表 1-5 8086 处理器的通用寄存器  

<table><tr><td>名称</td><td>中英文含义</td><td>作用</td></tr><tr><td>AX</td><td>累加器（Accumulator）</td><td>使用频度最高，用于算术、逻辑运算以及与外设传送信息等</td></tr><tr><td>BX</td><td>基址寄存器（Base）</td><td>常用来存放存储器地址，以方便指向变量或数组中的元素</td></tr><tr><td>CX</td><td>计数器（Counter）</td><td>作为循环操作等指令中的计数器</td></tr><tr><td>DX</td><td>数据寄存器（Data）</td><td>存放数据，在输入、输出指令中存放外设端口地址</td></tr><tr><td>SI</td><td>源变址寄存器（Source Index）</td><td>指向字符串或数组的源操作数</td></tr><tr><td>DI</td><td>目的变址寄存器（Destination Index）</td><td>指向字符串或数组的目的操作数</td></tr><tr><td>BP</td><td>基址指针寄存器（Base Pointer）</td><td>默认指向程序堆栈区域的数据，主要用于在子程序中访问通过堆栈传递的参数和局部变量</td></tr><tr><td>SP</td><td>堆栈指针寄存器（Stack Pointer）</td><td>专用于指向程序堆栈区域顶部的数据，在涉及堆栈操作的指令中会自动增加或减少，以使其总是指向堆栈顶部</td></tr></table>

# （1）数据寄存器

8086有4个16位数据寄存器：AX、BX、CX和DX。它们还都可以进一步分成高字节H（High）和低字节L（Low）两部分，这样有了8个8位通用寄存器：AH和AL、BH和BL、CH和CL、DH和DL。编程应用中，可以整个使用16位寄存器（如AX），也可以分成2个8位使用： $\mathrm{D}_{15}\sim \mathrm{D}_{8}$ （如AH）和  $\mathrm{D}_7\sim \mathrm{D}_0$ （如AL），对其中低或高8位的操作不影响对应高或低8位的数据。

# （2）变址寄存器

许多指令需要表达两个操作数（操作对象，如加法指令的被加数以及加法结果）：源操作

020

数，指被传送或参与运算的操作数（如加法的被加数）；目的操作数，指保存传送结果或运算结果的操作数（如加法的和值结果）。

SI和DI是变址寄存器，常通过改变寄存器表达的地址指向数组元素。SI常用于指向源操作数，而DI常用于指向目的操作数。

# （3）指针寄存器

堆栈（Stack）是一个特殊的存储区域，采用先进后出FILO（First In Last Out，也称为后进先出LIFO，Last In First Out）的操作方式存取数据。堆栈用于调用子程序时暂存数据、传递参数、存放局部变量，也可以用于临时保存数据。BP和SP是（堆栈）指针寄存器，用于指向堆栈中的数据。其中，SP是指向堆栈栈顶的指针，它会随着处理器执行有关指令自动增大或减小，所以SP不应该再用于其他目的，实际上可归类为专用寄存器。但是，SP又可以像其他通用寄存器一样灵活的改变。BP是指向堆栈某处的指针，常以此为基址访问该处前后的数据。

# 2.标志寄存器

标志（Flag）用于反映指令执行结果或控制指令执行形式，是汇编语言程序设计中必须特别注意的。许多指令执行之后将影响有关的标志位，不少指令的执行要利用某些标志。当然，也有很多指令与标志无关。8086处理器中各种常用的标志形成一个16位的标志寄存器FLAGS，也被称为程序状态字寄存器PSW。标志寄存器FLAGS中的各种标志分成了两类：6个状态标志和3个控制标志，如图1-9所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/24ecd90313b4d1eb163228d4052a7486bde4097fa9d33d001aba3a06bb993e22.jpg)  
图1-9 标志寄存器FLAGS

# （1）状态标志

状态标志是最基本的标志，用来记录指令执行结果的辅助信息。加、减运算和逻辑运算指令是主要设置它们的指令，有些其他指令的执行也会相应地设置它们。8086的状态标志有6个，但主要使用其中5个构成各种条件，分支指令判断这些条件实现程序分支。它们从低位到高位是：进位标志CF（Carry Flag）、奇偶标志PF（Parity Flag）、调整标志AF（Adjust Flag）、零标志ZF（Zero Flag）、符号标志SF（Sign Flag）、溢出标志OF（Overflow Flag）。

# （2）控制标志

控制标志位可由程序根据需要用指令设置，用于控制处理器执行指令的方式。8086的控制标志有3个：方向标志DF（Direction Flag），仅用于串操作指令中；中断允许标志IF(Interruptable Flag)，或简称中断标志，用于控制外部可屏蔽中断是否可以被处理器响应；陷阱标志TF（Trap Flag），也常称为单步标志，用于控制处理器是否进入单步操作方式。

# 3. 指令指针寄存器

程序由指令组成，指令存放在主存储器中。处理器需要一个专用寄存器表示将要执行的指令在主存的位置，这个位置用存储器地址表示。在8086微处理器中，这个存储器地址保存在16位指令指针寄存器IP（Instruction Pointer）中。

IP是专用寄存器，具有自动增量的能力。处理器执行完一条指令，IP中的值就加上该指令的字节数，从而指向下一条指令，实现程序的顺序执行。需要实现分支、调用等操作时要修改IP，它的改变将引起程序转移到指定的指令执行。但IP寄存器不能像通用寄存器那样直接

赋值修改，需要执行控制转移指令（如跳转、分支、调用和返回指令）、出现中断或异常的处理器赋值而相应改变。

# 4. 段寄存器

程序中包括可以执行的指令代码，还有指令操作的各类数据等。遵循模块化程序设计思希望将相关的代码安排在一起，相关数据安排在一起，于是段（Segment）的概念自然出现一个段安排一类代码或数据。程序员在编写程序时，可以自然地把程序的各部分放在相应的中。应用程序主要涉及3类段：存放程序中指令代码的代码段（Code Segment）、存放当前行程序所用数据的数据段(Data Segment)、指明程序使用的堆栈区域的堆栈段（Stack Segment）。为了表明段在主存中的位置，8086设计了4个16位段寄存器：代码段寄存器CS（CS Segment）、堆栈段寄存器SS（Stack Segment）、数据段寄存器DS（Data Segment）和附加寄存器ES（Extra Segment）。其中，附加段也是用于存放数据的数据段，专为处理数据串设计串操作指令必须使用附加段作为其目的操作数的存放区域。

# 1.5.3 8086的存储器组织

存储器是计算机存储信息的地方。程序运行所需要的数据，程序执行的结果以及程序本身均保存在存储器中。

# 1. 数据的存储格式

计算机存储信息的基本单位是一个二进制位（bit），1位可存储一个二进制数0或1。8个二进制位组成1字节(Byte)，位编号由右向左从0开始递增计数为  $\mathrm{D}_7\sim \mathrm{D}_0$  ，如图1-10所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/fea42b4c5548557f368cdfd2268b3923e80631157852c0dfb3ea9130a4ca7ac1.jpg)  
图1-10 8086的存储格式

8086 和 80286 的字长为 16 位, 由 2 字节组成, 称为字 (Word), 位编号自右向左为  $\mathrm{D}_{15} \sim \mathrm{I}$  80386 和 80486 的字长为 32 位, 由 4 字节组成, 称为双字 (Double Word), 位编号自右向左  $\mathrm{D}_{31} \sim \mathrm{D}_{0}$  。其中最低位称为最低有效位 (Least Significant Bit, LSB), 即  $\mathrm{D}_{0}$  位; 最高位称为高有效位 (Most Significant Bit, MSB), 对应字节、字、双字分别指  $\mathrm{D}_{7} 、 \mathrm{D}_{15} 、 \mathrm{D}_{31}$  位。

存储器中以字节为单位存储信息。为了正确存取信息，每个存储单元被赋予一个地址，存储器地址。地址编号从0开始，顺序加1，是一个无符号二进制整数，常用十六进制数表示

存储单元中存放的信息称为该存储单元的内容。图 1-10 表示在  $0002 \mathrm{H}$  地址的存储器中放的信息为  $34 \mathrm{H}$ , 即 2 单元的内容为  $34 \mathrm{H}$ , 表示为  $[0002 \mathrm{H}] = 34 \mathrm{H}$  或  $(0002 \mathrm{H}) = 34 \mathrm{H}$  (本书中主从[]表示存储单元的内容) 每个存储单元的内容是 1 字节, 很多数据是以字或双字来表示的。E存储器中如何来存放一个字或双字呢? 字或双字在存储器中占相邻的 2 个或 4 个存储单元? 放时, 低字节存入低地址, 高字节存入高地址; 字或双字单元的地址用它的低地址来表示  $0 \times 86$  处理器采用的这种 “低对低、高对高” 的存储形式被称为 “小端方式 (Little Endian)” 如, 在图 1-10 中, 2 号 “字” 单元的内容为  $[0002 \mathrm{H}] = 1234 \mathrm{H}, 2$  号 “双字” 单元的内容为  $[0002 8561234 \mathrm{H}]$  。

因此，同一个地址既可以看做字节单元的地址，也可以看做字单元的地址，还可以看做单元的地址，这要根据具体情况来确定。

对于以字节为存储单位的主存储器来说，多字节数据还涉及是否对齐地址边界问题。对  $= 2, 2^{2}, 2^{3}, 2^{4}, \cdots$ ）字节的数据，如果起始于能够被  $n$  整除的存储器地址位置（也称为模：）存放，则称地址边界对齐（Align）。例如，16 位 2 字节数据起始偶地址（模 2 地址，

址最低1位为0)，32位4字节数据起始模4地址（地址最低2位为00），就是对齐地址边界。

难道不允许  $n$  字节数据起始于非模  $n$  地址吗？是，也不是。有很多处理器要求数据存放必须对齐地址边界，否则会发生非法操作。8086 处理器比较灵活，允许不对齐边界存放数据。不过，访问未对齐地址边界的数据，处理器需要更多的读写操作，性能不及对齐地址边界的数据访问，尤其大量、频繁的存储器数据操作时。所以，为了获得更好的性能，常要进行地址边界对齐。

# 2. 存储器的分段管理

对于16位字长的8086CPU来说，可以方便地表达16位存储器地址：编号为  $0000\mathrm{H}\sim$  FFFFH，即  $2^{16}\mathrm{B} = 64\mathrm{KB}$  容量。但是8086CPU的地址线是20位的，这样最大可寻址空间应为 $2^{20}\mathrm{B} = 1\mathrm{MB}$  ，其物理地址范围为  $00000\mathrm{H}\sim$  FFFFFH。那么，这1MB空间如何用16位寄存器表达呢？

8086将1MB存储器空间分成许多逻辑段（Segment），每个段最大限制为  $64\mathrm{KB}$  。这样，每个存储器单元就可以用“段基地址：段内偏移地址”表达其准确的物理位置。

段基地址：说明逻辑段在主存中的起始位置，简称段地址。为了能用16位寄存器表达段地址，8086规定段地址必须是模16地址，即xxxx0H形式。省略低4位的0，段地址就可以用16位数据表示，它通常被保存在16位的段寄存器中。

段内偏移地址：说明主存单元距离段起始位置的偏移量（Displacement），简称偏移地址（Offset）。由于限定每段不超过64KB，所以偏移地址也可以用16位数据表示。

每个存储器单元都有的一个唯一的20位地址，被称为该单元的物理地址或绝对地址。在8086内部和用户编程时，采用的“段地址:偏移地址”形式被称为逻辑地址。将逻辑地址中的段地址左移4位，加上偏移地址就得到20位物理地址。例如，逻辑地址“1460H:100H”表示物理地址  $14700\mathrm{H}$  。同一个物理地址可以有多个逻辑地址，如图1-11所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/209d3db1a530e53aa5f07e05ab718f0d956866bfbe6202733bc128a326e15a06.jpg)  
图1-11 逻辑地址和物理地址

# 3. 段寄存器的作用

8086的段寄存器保存对应逻辑段的段基地址，每种段均有各自的用途。

代码段寄存器（Code Segment，CS）：存放程序的指令序列。CS存放代码段的段地址，指令指针寄存器IP指示代码段中指令的偏移地址。处理器利用CS:IP取得下一条要执行的指令。

堆栈段寄存器（Stack Segment，SS）：确定堆栈所在的主存区域。SS存放堆栈段的段地址，堆栈指针寄存器SP指示堆栈栈顶的偏移地址。处理器利用SS：SP操作堆栈中的数据。

数据段寄存器（Data Segment，DS）：存放当前运行程序所用的数据。DS存放数据段的段地址，存储器中操作数的偏移地址则由各种主存寻址方式得到，称为有效地址（Effective Address，EA）。

附加段寄存器（Extra Segment，ES）：附加的数据段，也用于数据的保存。另外，串操作指令将附加段作为其目的操作数的存放区域。

将存储器分段管理符合程序的模块化思想，利于编写模块化结构的程序。程序员在编制程序时，可以自然地把程序的各部分放在相应的逻辑段中。

程序的指令序列必须安排在代码段中。  
程序使用的堆栈一定在堆栈段中。  
程序中的数据默认安排在数据段中，也经常安排在附加段中，尤其是串操作的目的区必须是附加段。但是，数据的存放是比较灵活的，实际上可以存放在任何一种逻辑段中。这时，只要明确指明是哪个逻辑段就可以了。为此，8086 设计有 4 个段超越前缀指令，分别如下：

cs: ；代码段超越，使用代码段的数据  
ss: ；堆栈段超越，使用堆栈段的数据  
ds: 数据段超越，使用数据段的数据  
es: ；附加段超越，使用附加段的数据

段寄存器的使用规定总结在表1-6中。注意允许段超越的情况：一般的数据访问使用DS段，允许进行段超越，即可以是其他段；若使用BP基址指针寄存器访问主存，则默认是SS段，也允许段超越。

表 1-6 段寄存器的使用规定  

<table><tr><td>访问存储器的方式</td><td>默认的段寄存器</td><td>可超越的段寄存器</td><td>偏移地址</td></tr><tr><td>取指令</td><td>CS</td><td>无</td><td>IP</td></tr><tr><td>堆栈操作</td><td>SS</td><td>无</td><td>SP</td></tr><tr><td>一般数据访问(下列除外)</td><td>DS</td><td>CS, ES, SS</td><td>EA</td></tr><tr><td>串操作的源操作数</td><td>DS</td><td>CS, ES, SS</td><td>SI</td></tr><tr><td>串操作的目的操作数</td><td>ES</td><td>无</td><td>DI</td></tr><tr><td>BP 作为基址的寻址方式</td><td>SS</td><td>CS, DS, ES</td><td>EA</td></tr></table>

8086规定段地址低4位均为0，每段最大不超过  $64\mathrm{KB}$  。但是，每段并不要求必须是64KB，各段之间并不要求完全分开。两个逻辑段可以部分重叠，甚至完全重叠。当然，各段的内容是不允许发生冲突的，图1-12说明了这种情况。

图1-12(a)是各自独立段的分配示例。CS=0150H，DS=4200H，SS=1CD0H，ES=B000H，它们分别为代码段、数据段、堆栈段和附加段的首地址。自每个首地址开始，各段均占64KB的范围，各段之间互不重叠。

图1-12(b)则是相互重叠段的分配示例。  $\mathrm{CS} = 0200\mathrm{H}$  ，  $\mathrm{DS} = 0400\mathrm{H}$  ，  $\mathrm{SS} = 0480\mathrm{H}$  ，这样代码段、数据段和堆栈段的首地址分别为  $02000\mathrm{H}$  、  $04000\mathrm{H}$  和  $04800\mathrm{H}$  。其中代码段大小为8KB，数据段占2KB，而堆栈段只有  $256\mathrm{B}$  ，  $\mathrm{SP} = 0100\mathrm{H}$  。该程序没有使用附加段，所以没有设置ES。可以看出，各段大小应根据实际需要来分配，可以重叠。有时甚至可以将所有4种段集中在一个逻辑段内，形成一个短小紧凑的程序，其大小不超过64KB。在图1-12(b)所示的情况下，

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/e3afeddf568921d568c4315f079d67250d53d6663c6c8ac80ef95a48f9f85fb6.jpg)  
图1-12 存储器的分段

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/575e3020c6ea7bec309081659440748dd56e5f2654523a6d0c29e3e2ee5a4bf6.jpg)

CS=DS=SS=0200H，这时代码段将占据该逻辑段偏移地址为  $0000\sim 1\mathrm{FFFH}$  的8KB，而数据段在偏移地址为  $2000\mathrm{H}\sim 27\mathrm{FFH}$  位置，堆栈顶指针  $\mathrm{SP} = 2900\mathrm{H}$  。

# 1.6 8086 的寻址方式

笼统地说，数据来自主存或外设，但这个数据可能事先已经保存在处理器的寄存器中，也可能与指令操作码一起进入了处理器。主存和外设在汇编语言当中被抽象为存储器地址或I/O地址，寄存器以名称表达，机器代码中同样用地址编码区别寄存器，所以指令的操作数需要通过地址指示。通过地址才能查找到数据本身，这就是操作数的寻址方式（Addressing Mode），也称为数据寻址方式。对处理器的指令系统来说，绝大多数指令采用相同的寻址方式。寻址方式对处理器工作原理和指令功能的理解以及汇编语言程序设计至关重要。

汇编语言中，操作码用助记符表示，操作数则由寻址方式体现。8086只有输入/输出指令与外设交换数据（将在5.4节中学习）。除外设数据外的操作数寻址方式有3类：用常量表达的具体数值（立即数寻址），用寄存器名表示的其中内容（寄存器寻址），用存储器地址代表保存的数据（存储器寻址）。

为了能够从一开始就形成正确的书写格式，为以后编写汇编语言源程序打好基础，在此先简单介绍汇编语言的语句格式（详细内容参考第3.1节）。

汇编语言的每条语句一般占一行，由分隔符分成4部分组成，又可以分成两种。

① 执行性语句：用于表达处理器指令（将在第2章学习）。执行性语句汇编后对应一条指令代码。由处理器指令组成的代码序列是程序设计的主体，其格式如下：  
标号：处理器指令助记符 操作数，操作数  
② 说明性语句：用于表达汇编程序命令（将在第3章学习），指示源程序如何汇编、变量怎样定义、过程怎么设置等。相对于真正的处理器指令（也称为真指令、硬指令），汇编程序命令也称为伪指令（Pseudoinstruction）、指示性语句或指示符（Directive），其格式如下：

名字伪指令助记符参数，参数，…注释其中，标号和名字是用户定义的标识符，用于指示指令的逻辑地址；助记符是表达处理器指令或汇编语言命令的标识符（属于保留字），操作数和参数是指令或命令需要的数据，“；”后的

025

内容则是注释。通常，在双操作数的指令语句中“，”右边的操作数是源操作数，表示参与操作的一个对象；“，”左边的操作数是目的操作数，不仅可以作为指令操作的一个对象，以用来存放指令操作的结果。

# 1.6.1 8086的机器代码格式

机器代码（Machine Code）格式是指令用二进制数 0 和 1 进行编码的形式，也被称为编码格式（Instruction Format）。8086 的机器代码格式如图 1-13 所示。操作码占 1 或 2 字后面的各字节指明操作数。其中，“mod reg r/m”表明寻找操作数的方式（即采用的寻址方式“位移量”字节给出某些寻址方式需要的相对基地址的偏移量，“立即数”字节给出立即寻址方式需要的数值本身。设计有多种寻址方式，因此操作数的各字段有多种组合，如表 1-7 所列）。

<table><tr><td>操作码</td><td>mod reg r/m</td><td>位移量</td><td>立即数</td></tr></table>

图1-13 8086的机器代码格式

表 1-7 8086 指令的寻址方式字节编码  

<table><tr><td rowspan="2">R/M</td><td rowspan="2">0 0</td><td rowspan="2">0 1</td><td rowspan="2">1 0</td><td colspan="2">1 1</td><td rowspan="2">REG</td></tr><tr><td>w=0</td><td>w=1</td></tr><tr><td>000</td><td>[BX+SI]</td><td>[BX+SI+D8]</td><td>[BX+SI+D16]</td><td>AL</td><td>AX</td><td>000</td></tr><tr><td>001</td><td>[BX+DI]</td><td>[BX+DI+D8]</td><td>[BX+DI+D16]</td><td>CL</td><td>CX</td><td>001</td></tr><tr><td>010</td><td>[BP+SI]</td><td>[BP+SI+D8]</td><td>[BP+SI+D16]</td><td>DL</td><td>DX</td><td>010</td></tr><tr><td>011</td><td>[BP+DI]</td><td>[BP+DI+D8]</td><td>[BP+DI+D16]</td><td>BL</td><td>BX</td><td>011</td></tr><tr><td>100</td><td>[SI]</td><td>[SI+D8]</td><td>[SI+D16]</td><td>AH</td><td>SP</td><td>100</td></tr><tr><td>101</td><td>[DI]</td><td>[DI+D8]</td><td>[DI+D16]</td><td>CH</td><td>BP</td><td>101</td></tr><tr><td>110</td><td>[D16]</td><td>[BP+D8]</td><td>[BP+D16]</td><td>DH</td><td>SI</td><td>110</td></tr><tr><td>111</td><td>[BX]</td><td>[BX+D8]</td><td>[BX+D16]</td><td>BH</td><td>DI</td><td>111</td></tr></table>

8086指令最多可以有两个操作数。在“mod reg r/m”字节中，reg字段表示一个采用寄存器寻址的操作数，reg占用3位，不同编码指示8个8位（w=0）或16位（w=1）通用寄存器之一；mod和r/m字段表示另一个操作数的寻址方式，分别占用2位和3位。

$\diamond$  mod=00时，为无位移量的存储器寻址方式。其中，当  $[\mathrm{r / m}] = 110$  时，为直接寻址方此时该字节后跟16位有效地址D16。  
mod=01时，为带有8位位移量的存储器寻址方式。此时该字节后跟1字节量，表示位位移量D8，它是一个有符号数。  
mod=10时，为带有16位位移量的存储器寻址方式。此时该字节后跟2字节（字）表示16位位移量D16，它也是一个有符号数。  
mod=11时，为寄存器寻址方式，由r/m指定寄存器，此时的编码与reg相同。

除上述一般机器代码的格式外，8086还有其他机器代码格式，详见参考文献。

为了更清楚地掌握寻址方式，下面以最常用的MOV指令（详见2.1节）来举例说明。MO指令是一个数据传送指令，相当于高级语言的赋值语句，其格式为：

mov dest, src ；DEST←SRC

MOV指令的功能是将源操作数SRC传送至目的操作数DEST。我们固定目的操作数采用寄存器寻址，而用源操作数反映各种寻址方式。

【例1.13】将寄存器BX的内容传送给AX寄存器。

mov ax，bx ;指令功能：  $\mathsf{AX}\leftarrow \mathsf{BX}$  ，机器代码为89D8（十六进制数，下同）

其中，第1字节“89”是操作码，还包含  $\mathrm{w} = 1$  （字节中的最低位)，表示进行16位操作；第2字节“D8”表示“mod reg r/m”寻址方式，用二进制数表示为11011000。对应表1-7可以看出：reg=011，表示一个操作数BX；mod=11和  $\mathrm{r / m = 000}$  ，表示另一个操作数AX。

【例1.14】将寄存器BX的内容加寄存器SI的内容再加6的值作为存储器地址，从该地址单元传送1字节数据给AL寄存器。

mov al, [bx+si+6] ; 指令功能: AL←[BX+SI+6], 机器代码为 8A 40 06

其中，第1个操作码“8A”，包含  $\mathrm{w} = 0$  ，表示进行8位操作，第2个寻址方式“40”用二进制数表示为01000000。从表1-7可以看出：REG=000，表示一个操作数AL；MOD=01和R/M=000，表示另一个操作数[BX+SI+D8]是带8位位移量的存储器寻址，这里[D8]=06，由第3字节表达。

为了体会指令功能和查看机器代码，可以利用调试程序。在入门学习阶段，建议利用MS-DOS平台的调试程序DEBUGexe。虽然功能不够强大、使用也不够灵活，但简单的DEBUG调试程序却具有基本的调试手段，不仅适合学习要求（前5章，尤其是第2章的指令学习），也是熟悉其他调试程序的基础。

要进入 DEBUGGexe 程序，在 32 位 Windows 图形界面下需要启动命令行窗口，输入“DEBUG”即可（详见第 3 章）。在调试程序中，使用汇编命令输入指令，使用反汇编命令查看指令及其机器代码，用单步命令执行一条指令，通过观察结果体会指令功能。调试程序 DEBUG 的使用参见附录 A。

# 1.6.2 立即数寻址方式

在立即数寻址方式下，指令中的操作数直接存放在机器代码中，紧跟在操作码之后，如图1-14左侧。这条指令汇编成机器代码后，操作数作为指令的一部分存放在操作码之后的主存单元中。这种操作数称为立即数IMM，可以是8位数值i8（00H～FFH)，也可以是16位数值i16(0000H～FFFFH)。立即数寻址方式常用来给寄存器或存储单元赋值。

【例1.15】将立即数05H（字节，即8位立即数）传送给AL寄存器。

mov al, 05h ;功能：AL←05H，机器代码为B005

其中，B0为该指令的操作码，紧接其后的05就是立即数05H。

【例1.16】将16位立即数0102H送至AX寄存器。

mov ax, 0102h ;功能：AX←0102H，机器代码为B80201

在该指令机器代码所在主存单元后的2字节单元的内容为0102H，可见16位立即数0102H紧跟在MOV指令后，存放在代码段中。注意，高字节01H存放于高地址中，低字节存放于低地址单元中，如图1-14右侧所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/33f1a1d7b4f9334cbd2be4eae73e0aa6cbd5176d83411407fc7ccf1216a387ab.jpg)  
图1-14 立即数寻址方式

# 1.6.3 寄存器寻址方式

寄存器寻址方式的操作数存放在CPU的内部寄存器REG中，可以是8位寄存器R8（AH、AL、BH、BL、CH、CL、DH、DL）或者16位寄存器R16（AX、BX、CX、DX、SI、DI、BP、SP）。另外，操作数可以存放在4个段寄存器SEG（CS、DS、SS、ES）中。

mov ax, 1234h ; 目的操作数采用寄存器寻址，源操作数为立即数寻址 AX←1234H

mov bx, ax ; 两个操作数均为寄存器寻址: BX←AX, 机器代码为 89 C3

执行上述两条指令之后，结果是  $\mathrm{BX} = 1234\mathrm{H}$ 。

寄存器寻址方式的操作数存放于CPU的某个内部寄存器中，不需要访问存储器，因而执行速度较快，是经常使用的方法。

# 1.6.4 存储器寻址方式

寄存器寻址虽然速度较快，但CPU中寄存器数目有限，不可能把所有参与运算的数据都存放在寄存器中。在多数情况下，操作数还是要存储在主存中。如何寻址主存中存储的操作数称为存储器寻址方式，也称为主存寻址方式。在这种寻址方式下，指令中给出的是有关操作数的主存地址信息。我们知道，8086的存储器是分段管理的，所以这里给出的地址只是偏移地址（即有效地址EA），而段地址在默认的或用段超越前缀指定的段寄存器中。

为了方便各种数据结构的存取，8086设计了多种主存寻址方式。

# 1. 直接寻址方式

在直接寻址方式下，指令中直接包含了有效地址，如图1-15左侧。例如：

mov ax, [2000h] ; AX←DS: [2000H], 机器代码为 A1 00 20

该指令中给定了有效地址  $2000 \mathrm{H}$ , 它不是存储器的物理地址。在默认情况下, 有效地址要与数据段寄存器 DS 一起构成操作数所在存储单元的物理地址。在汇编语言中, 用 [ ] 表示存储单元的内容。

该例指令的执行结果是将 DS:[2000H]单元的内容传送至 AX 寄存器，其中高字节内容送 AH 寄存器，低字节内容送 AL 寄存器，如图 1-15 右侧所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/0d08621aa8b87e56ac313e9b706f2e9194b292a75379dfa8b6131960e9c3b3a0.jpg)  
图1-15 存储器直接寻址方式

数据不仅可以存放于数据段中，也可根据需要存放于附加段、代码段或堆栈段中，这时指令中应指明段超越前缀。例如：

mov ax, es:[2000h] ; AX←ES: [2000H], 机器代码为 26 A1 00 20

该指令中的操作数存放在附加段中。

# 2. 寄存器间接寻址方式

在这种寻址方式中，有效地址存放在寄存器中（如图1-16(a)所示），8086中寄存器只能是基址寄存器BX或变址寄存器SI、DI中。其默认的段地址在DS段寄存器中，但可使用段超越前缀改变。例如：

mov ax,[si]

; AX←DS:[SI], 机器代码为8B04

该指令中有效地址存放于 SI 寄存器中，操作数则存放在数据段主存单元中。假设 SI 内容设置为  $2000\mathrm{H}$ ，则该指令等同于“mov ax, [2000H]”。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/41c5b48882a3b3a087e6a58da204abeab942846615ce49d43a6514ccffe00177.jpg)  
(a) 寄存器间接寻址

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/696e61ef21b8350cf71606c886151d0f81895e7faa2ba2fc661b48a72c76bafc.jpg)  
图1-16 寄存器间接寻址和相对寻址

# 3. 寄存器相对寻址方式

在寄存器相对寻址方式下，有效地址是寄存器内容与有符号8位或16位位移量之和（如图1-16(b)所示），寄存器可以是BX、BP或SI、DI。操作数的EA=BX/BP/SI/DI+8/16位位移量。其中，BX、SI、DI寄存器默认数据段DS，BP寄存器默认堆栈段SS。当使用非默认段时，可用段超越前缀。

mov ax, [di+06h]

;  $\mathrm{AX}\leftarrow \mathrm{DS}:[\mathrm{DI} + 06\mathrm{H}]$  ，机器代码为8B4506

这条指令使用的是 DI 寄存器, 位移量为  $06 \mathrm{H}$ , 那么操作数的  $\mathrm{EA} = \mathrm{DI} + 06 \mathrm{H}$ , 与 DI 寄存器约定的段是数据段 DS。再如:

mov ax, [bp+06h]

; AX←SS: [BP+06H], 机器代码为8B4606

该指令使用的是BP寄存器，与之约定的段为堆栈段SS。另外，采用BP相对寻址时，如果偏移量为0，也可以不写，形式上与寄存器间接寻址一样。例如：

mov ax, [bp]

；等同于MOV AX，[BP+0H]，机器代码均为8B4600

指令代码中的位移量采用补码表示，如果是8位，则被带符号扩展为16位。当得到的有效地址EA超过FFFFH时，则取64K（即  $64\times 1024$  ）的模。例如，如果上例中的DI为FFFEH（如作为补码，表示-2），则  $[\mathrm{DI} + 6]$  后的有效地址为  $0004\mathrm{H}$  。

# 4. 基址变址寻址方式

基址变址寻址方式是把一个基址寄存器（BX或BP）的内容加上变址寄存器（SI或DI）的内容构成有效地址EA。这样，操作数的  $\mathrm{EA} = \mathrm{BX} / \mathrm{BP} + \mathrm{SI} / \mathrm{DI}$  。若基址寄存器使用BX，其默认段为数据段DS。若基址寄存器使用BP，其默认段为堆栈段SS。

mov ax, [bx+si]

;  $\mathrm{AX}\leftarrow \mathrm{DS}:[\mathrm{BX} + \mathrm{SI}]$  ，机器代码为8B00

```txt
mov ax，[bp+di] ;AX-SS [BP+DI]、机器代码为8803 mov ax,ds [bp+di] ;AX-DS [BP+DI]、机器代码为3E8803
```

当得到的有效地址 EA 超过 FFFFH 时，则取其 64K 的模。

# 5. 相对基址变址寻址方式

相对基址变址寻址方式也使用基址寄存器（BX/BP）和变址寄存器（SI/DI），还在指令指定一个8位或16位的位移量，这三者之和构成操作数的有效地址EA，即  $\mathrm{EA} = \mathrm{BX} / \mathrm{BP} + \mathrm{SI}$ $+8 / 16$  位位移量。与BX寄存器约定的段为数据段DS，与BP寄存器约定的段为堆栈段SS例如：

```txt
mov ax, [bx+si+06h] ; ax←ds: [bx+si+06h], 机器代码为8B4006
```

指令中的位移量采用补码表示，如果是8位，则被带符号扩展为16位。如果得到的有效地址EA超过FFFFH，则取其64K的模。

需要说明的是：

① 在寄存器相对寻址或相对基址变址寻址方式中，位移量可用符号表示，如：

```txt
mov ax, [si+count] ; count是事先定义的变量或常量，此处就是一个数值  
mov ax, [bx+si+wnum] ; wnum也是变量或常量
```

② 同一寻址方式有时可以写成不同的形式，如：

```txt
mov ax, [bx][si] ；也可写成：mov ax, [bx+si]  
mov ax, count[si] ；也可写成：mov ax, [si+count]  
mov ax, wnum[bx][si] ；也可写成：mov ax, wnum[bx+si]  
或 mov ax, [bx+si+wnum]
```

# 1.6.5 数据寻址的组合

至此，已经学习了绝大多数指令采用的数据寻址方式，下面做一个简单总结，便于在以后的编程实践中掌握它们的具体应用。

① 立即数寻址只能用于源操作数，其类型由另一个操作数的类型或指令决定。本书统一使用符号 IMM 表示立即数，而 8086 处理器支持 16 位立即数（使用符号 i16 表示）和 8 位立即数（使用符号 i8 表示）。  
② 寄存器寻址主要是指通用寄存器寻址，最常使用、可以单独或同时用于源和目的操作数，寄存器本身包含有类型。本书统一使用符号 REG 表示通用寄存器，对 8086 来说有 8 个 1 位通用寄存器 R16（AX、BX、CX、DX、SI、DI、BP 和 SP）和 8 个 8 位通用寄存器 R8（AH、AL、BH、BL、CH、CL、DH 和 DL）。部分指令可以使用专用寄存器，例如段寄存器 SEG（CDS，SS，ES）。  
(3) 存储器寻址访问的数据在主存, 利用逻辑地址指示。段基地址由默认或指定的段寄存器指出, 指令代码只表达偏移地址、称为有效地址, 有多种形式、对应多种存储器寻址方式。本书统一用 MEM 表示存储器操作数, 可以是 16 位或 8 位数据, 分别用符号 M16 和 M8 表示

典型的指令操作数有两个：一个书写在左边，被称为目的操作数 DEST；另一个用 “,” 分隔，书写在右边，被称为源操作数 SRC。数据寻址方式在指令中并不是任意组合的，但有规律符合逻辑。例如，绝大多数指令（数据传送、加减运算、逻辑运算等常用指令）都支持如下组合，如图 1-17 所示。

```txt
处理器指令助记符 reg,imm/reg/mem处理器指令助记符 mem,imm/reg
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-30/2a9ec203-5345-48de-9fc6-7a5bbdd5bb9a/a95ccf70e16c3251cdc86933624e24e01b6ce8048c0aebc2a5e27617ea5de473.jpg)  
图1-17 数据寻址的组合

在这两个操作数中，源操作数可以由立即数、寄存器或存储器寻址，而目的操作数只能是寄存器或存储器寻址，并且两个操作数不能同时为存储器寻址方式。格式中的“/”表示“或者”，即可以是多个中的任意一个操作数。

第2章将学习8086指令，并使用约定符号，如表1-8所示。除特别说明的新符号外，凡不符合指定格式的指令都是不存在的非法指令。附录D中罗列了全部指令。

表 1-8 寻址方式及其符号  

<table><tr><td>寻址方式</td><td>符号及说明</td></tr><tr><td>立即数寻址</td><td>IMM(包括8位立即数i8,16位立即数i16)</td></tr><tr><td>寄存器寻址</td><td>通用寄存器REG(包括8位通用寄存器R8,16位通用寄存器R16),段寄存器SEG</td></tr><tr><td>存储器寻址</td><td>MEM(包括8位存储器操作数M8,16位存储器操作数M16)</td></tr></table>

高级语言虽然不讨论数据寻址，但实际上其复杂数据类型和构造的数据结构都需要处理器数据寻址的支持，这也是处理器设计多种灵活的访问数据方式的重要原因。

# 习题1

1-1 简述计算机系统的硬件组成及各部分作用。  
1-2 明确下列概念或符号：

主存和辅存 RAM和ROM 存储器地址和I/O端口

KB MB GB TB

1-3 什么是汇编语言源程序、汇编程序、目标程序？  
1-4 汇编语言与高级语言相比有什么优缺点？  
1-5 将下列十六进制数转换为二进制数和十进制数表示。

(1) FFH (2) 0H (3) 5EH (4) EFH  
(5) 2EH (6) 10H (7) 1FH (8) ABH

1-6 将下列十进制数转换为（压缩）BCD码表示。

(1) 12 (2) 24 (3) 68 (4) 127  
(5) 128 (6) 255 (7) 1234 (8) 2458

1-7 将下列（压缩）BCD码转换为十进制数。

（1）10010001 （2）10001001 (3）00110110 （4）10010000  
（5）00001000 (6)10010111 （7）10000001 （8）00000010

1-8 将下列十进制数分别用 8 位二进制数的原码、反码和补码表示。

(1) 0 (2) -127 (3) 127 (4) -57  
(5) 126 (6) -126 (7) -128 (8) 68

1-9 完成下列二进制数的运算。

（1）1011+1001 (2）1011-1001 （3）  $1011\times 1001$  （4）10111000=1001

(5)  $1011 \wedge 1001$

(6) 1011v1001

(7) ~1011

（8）  $1011\oplus 1001$

1-10 数码  $0 \sim 9$ 、大写字母 A～Z、小写字母 a～z 对应的 ASCII 码分别是多少？ASCII 码为 0，OAH 对应的是什么字符？

1-11 计算机中有一个“01100001”编码，如果把它认为是无符号数，则转换为十进制数么？如果认为它是BCD码，则转换为十进制数是什么？如果它是某个ASCII码，则代表哪个字？

1-12 简述Intel80x86系列微处理器在指令集方面的发展。

1-13 什么是DOS和ROM-BIOS？

1-14 简述PC的最低1MB主存空间的使用情况。

1-15 罗列8086CPU的8个8位和16位通用寄存器，并说明各自的作用。

1-16 什么是标志？它有什么用途？状态标志和控制标志有什么区别？画出标志寄存FLAGS，说明各标志的位置和含义。

1-17 指令指针寄存器IP的作用是什么？

1-18 字和双字在存储器中如何存放，什么是“小端方式”？对字和双字存储单元，什么是它们的对齐地址？为什么要对齐地址？

1-19 什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址？请将如下逻辑地址用物理地址表达（表达地址默认采用十六进制数）：

(1) FFFF:0

(2)  $40:17$

(3)  $2000:4500$

（4）B821：4567

1-20 8086有哪4种逻辑段？各种逻辑段分别是什么用途？

1-21 数据的默认段是哪个？是否允许其他段存放数据？如果允许，如何实现？有什么要求？

1-22 什么是操作码、操作数和寻址方式？有哪3种给出操作数的方法？

1-23 什么是有效地址 EA? 8086 的操作数如果在主存中, 有哪些寻址方式可以存取它?

1-24 说明下列指令中源操作数的寻址方式？如果  $\mathrm{BX} = 2000\mathrm{H}$ ， $\mathrm{DI} = 40\mathrm{H}$ ，给出  $\mathrm{DX}$  的值或有效地址 EA 的值。

(1) mov dx, [1234H]  
(2) mov dx, 1234H  
(3) mov dx, bx  
(4) mov dx, [bx]  
（5）mov  $\mathrm{dx}$  ，[bx+1234H]  
(6) mov dx, [bx+di]  
(7) mov dx, [bx+di+1234H]