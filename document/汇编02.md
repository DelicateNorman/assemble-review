# 汇编语言程序设计

# Assembly Language Programming

主讲人：鲁宏伟luhw@hust.edu.cn

# 第二章

# 8086 的指令系统

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/ae747d9535e59a095671c29aae2692cbe22bc3db8b135ea87c8b14a031f1ae23.jpg)

# 重点掌握常用指令功能及应用

常用传送指令  
✓加减法指令  
✓逻辑运算和移位指令  
控制转移指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/35c17fa28fb064fecf0edb8e74de70bee273733dc9c6d22784c20a542dc98b83.jpg)

计算机的指令系统就是指该计算机能够执行的全部指令的集合  
每种计算机都有它支持的指令集合  
16位8086指令系统是Intel 80x86系列微处理器指令系统的基础  
Intel 80x86 系列微处理器指令系统

整数指令  
浮点指令  
■ 多媒体指令

# Intel 8086指令系统共有117条基本指令

# 可分成6个功能组

(1) 数据传送类指令  
(2) 算术运算类指令  
(3) 位操作类指令  
(4) 串操作类指令  
(5) 控制转移类指令  
(6) 处理机控制类指令

# 如何学习

# 学习指令的注意事项

指令的功能——该指令能够实现何种操作。通常指令助记符就是指令功能的英文单词或其缩写形式  
> 指令支持的寻址方式——该指令中的操作数可以采用何种寻址方式  
> 指令对标志的影响——该指令执行后是否对各个标志位有影响，以及如何影响  
其他方面——该指令其他需要特别注意的地方，如指令执行时的约定设置、必须预置的参数、隐含使用的寄存器等

# 由 4 部分组成:

标号：指令助记符 目的操作数,源操作数 ; 注释

标号表示该指令在主存中的逻辑地址  
每个指令助记符就代表一种指令  
目的和源操作数表示参与操作的对象  
注释是对该指令或程序段功能的说明

# 教学提示

• 全面而准确地理解每条指令的功能和应用，是编写汇编语言程序的关键  
- 什么时候用什么指令是个技巧问题

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/56ea8a8aff0850ad5af2cc8db0f6508eb5231d6b07626664c9d469921494f759.jpg)

逐个展开指令

# 2.1 数据传送类指令

数据传送是计算机中最基本、最重要的一种操作

> 传送指令也是最常使用的一类指令  
> 传送指令把数据从一个位置传送到另一个位置  
$\succ$  除标志寄存器传送指令外，均不影响标志位  
重点掌握

MOV XCHG  
PUSH POP  
LEA

# 2.1 数据传送类指令

MOV 传送字或字节.  
MOVSX 先符号扩展, 再传送.  
> MOVZX 先零扩展,再传送.  
PUSH 把字压入堆栈.  
POP 把子弹出堆栈.  
PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.  
>POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.  
> PUSHAD 把 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI 依次压入堆栈.  
> POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.  
BSWAP 交换32位寄存器里字节的顺序  
XCHG 交换字或字节（至少有一个操作数为寄存器，段寄存器不可作为操作数）  
> CMPXCHG比较并交换操作数.（第二个操作数必须为累加器AL/AX/EAX)  
XADD 先交换再累加. (结果在第一个操作数里)  
XLAT 字节查表转换----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.  $\left[\left[\mathrm{BX} + \mathrm{AL}\right] - >\mathrm{AL}\right)$

# 2.1.1 通用数据传送指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/3840957930526bf55191bae4d61a32d47b3c086a0b02b95fe192e93fd24dc635.jpg)  
MOV 并非任意传送

# 两个操作数的类型不一致

例如源操作数是字节，而目的操作数是字；或相反

# 两个操作数不能都是存储器

■传送指令很灵活，但主存之间的直接传送却不允许

# 段寄存器的操作有一些限制

■段寄存器属专用寄存器，对他们的操作能力有限

堆栈：后进先出  
FILO，位于堆栈段；  
SS段寄存器记录其  
段地址  
堆栈只有一个出口，即当前栈顶；用堆栈指针寄存器SP指定  
栈是程序中不可或缺的一个存储区域

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/a80a4934b741499fa0b9659dfcd42afb067a6028522fb9cd3523e24065b313d9.jpg)

>堆栈只有两种基本操作：进栈和出栈，  
对应两条指令 PUSH 和 POP

PUSH ; 进栈指令先使堆栈指针SP减2，然后把一个字操作数存入堆栈顶部

POP ; 出栈指令把栈顶的一个字传送至指定的目的操作数, 然后堆栈指针 SP 加 2

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/76424de8e252a5fd8d9c7d908d68ec84c296b6cce0d6cb22e39bfef192f93092.jpg)

Stack

PUSH

POP

# 2.1.3 标志传送指令

> 标志寄存器传送指令用来传送标志寄存器FLAGS的内容  
>标志位操作指令直接对CF、DF、IF标志进行复位或置位

# 2.1.3 标志传送指令

> LAHF 标志寄存器传送，把标志装入 AH.  
SAHF 标志寄存器传送, 把 AH 内容装入标志寄存器.  
PUSHF 标志入栈.  
>POPF 标志出栈.  
PUSHD 32位标志入栈.  
>POPD 32位标志出栈.

# 地址传送指令将存储器单元的逻辑地址送至指定的寄存器

> LEA 装入有效地址. 例: LEADX, mem; 把偏移地址存到 DX.  
> LDS 传送目标指针, 把指针内容装入 DS. 例: LDS SI, mem ; 把段地址: 偏移地址存到 DS:SI.  
• LES 传送目标指针, 把指针内容装入 ES. 例: LES DI, mem ; 把段地址 : 偏移地址存到 ES:DI.  
LFS 传送目标指针, 把指针内容装入 FS. 例: LFS DI, mem ; 把段地址: 偏移地址存到 FS:DI.  
> LGS 传送目标指针, 把指针内容装入 GS. 例: LGS DI, mem ; 把段地址: 偏移地址存到 GS:DI.  
• LSS 传送目标指针, 把指针内容装入 SS. 例: LSS DI, mem ; 把段地址: 偏移地址存到 SS

# 2.2 算术运算类指令

四则运算是计算机经常进行的一种操作。算术运算指令实现二进制（和十进制）数据的四则运算  
掌握常用状态标志，并请注意算术运算类指令对标志的影响以及指令中隐含的寄存器

掌握：ADD/ADC/INC、SUB/SBB/DEC/NEG/CMP  
熟悉：MUL/IMUL、DIV/IDIV  
理解：CBW/CWD、DAA/DAS、AAA/AAS/AAM/AAD

# 2.2 算术运算类指令

> ADD 加法  
> ADC 带进位加法.  
INC 加1.  
> AAA 加法的 ASCII 码调整.  
DAA 加法的十进制调整.  
> SUB 减法.  
SBB 带借位减法.  
$\triangleright$  DEC 减 1.  
> NEG 求反 (以 0 减之).  
> CMP 比较. (两操作数作减法, 仅修改标志位, 不回送结果).  
AAS 减法的 ASCII 码调整.  
DAS 减法的十进制调整.  
MUL 无符号乘法. 结果回送 AH 和 AL(字节运算), 或 DX 和 AX(字运算),

# 2.2 算术运算类指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/29c1ae670d775332a56c5a758af9b6d5de53054cf2387304389b614a37d0b5fb.jpg)

ADD

加法

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/21951739c75167de671defdde17f47ce7e8ddc52f2a90ec68924a9e9225321fc.jpg)

ADC

带进位加法.

程序员

$\mathsf{FFFF} + \mathsf{FFF} =$

1 FFFE

HEX 1 FFEF

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/8c373809cb2b9aa27872c5c7988145ab8b4266a67390e99234340e37d87cdcaf.jpg)

# 第2章

# 2.2 算术运算类指令

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/29d235f5ca629f83a1f42235545a63835509c11ba8460ed08b361a965baae009.jpg)

SUB

SBB

减法.

带借位减法.

```txt
HEX 3E7   
DEC 999
```

```txt
3E8-1= 3E7
```

```csv
DOS Box DOSBox 0.74-3, Cpu speed: 3000 cycles, Frameskip 0, Program: DEBUG - X  
AX=077A BX=0000 CX=0199 DX=0000 SP=0080 BP=0000 SI=0000 DI=0000  
DS=075A ES=075A SS=077A CS=0782 IP=0008 NU UP EI PL NZ NA PO NC  
0782:000B BAE803 MOV DX, 03E8  
-t  
AX=077A BX=0000 CX=0199 DX=03E8 SP=0080 BP=0000 SI=0000 DI=0000  
DS=075A ES=075A SS=077A CS=0782 IP=000B NU UP EI PL NZ NA PO NC  
0782:000B B86500 MOV AX, 00C5  
-t  
AX=0005 BX=0000 CX=0199 DX=03E8 SP=0080 BP=0000 SI=0000 DI=0000  
DS=075A ES=075A SS=077A CS=0782 IP=00OE NU UP EI PL NZ NA PO NC  
-782:000E 2D6666 SUB AX, 0C6666 AX = 5H - 6H = FFFFH  
-t  
AX=FFFF BX=0000 CX=0199 DX=03E8 SP=008O BP=00CQ SI=Oooo DI=Oooo  
DS=075A ES=075A SS=077A CS=O782 IP=Ooo11 NU UP EI NG NZ AC PE CY  
-782:OO11 83DAOO SBB DX,+OO DX = DX - O - CF  
-t  
AX=FFFF BX=Oooo CX=O199 DX=O3E7 SP=Oooo BP=Oooo SI=Oooo DI=Oooo  
DS=O75A ES=O75A SS=O77A CS=O782 IP=Ooo14 NU UP EI PL NZ NA PE NC  
-782:OO14 B8664C MOV AX, 4Coo https://blog.csdn.net/qq_44989881
```

# 2.2 算术运算类指令

IMUL 整数乘法. 结果回送 AH 和 AL(字节运算), 或 DX 和 AX(字运算),  
AAM 乘法的 ASCII 码调整.  
> DIV 无符号除法. 结果回送：商回送 AL, 余数回送 AH, (字节运算); 或 商回送 AX, 余数回送 DX, (字运算).  
IDIV 整数除法. 结果回送：商回送 AL, 余数回送 AH, (字节运算); 或 商回送 AX, 余数回送 DX, (字运算).  
AAD 除法的 ASCII 码调整。  
> CBW 字节转换为字.（把 AL 中字节的符号扩展到 AH 中去）  
CWD 字转换为双字。（把AX中的字的符号扩展到DX中去）  
> CWDE 字转换为双字.（把 AX 中的字符号扩展到 EAX 中去）  
> CDQ 双字扩展. (把 EAX 中的字的符号扩展到 EDX 中去)

例 1 :  $3 \mathrm{AH} + 7 \mathrm{CH} = 8 \mathrm{B} 6 \mathrm{H}$

无符号数运算:  $58 + 124 = 182$

范围内，无进位

有符号数运算:  $58 + 124 = 182$

范围外，有溢出

例 2 :  $A A H + 7 C H =$

(1)  $26 \mathrm{H}$

无符号数运算:  $170 + 124 = 294$

范围外，有进位

有符号数运算:  $-86 + 124 = 38$

范围内，无溢出

# 如何运用溢出和进位

处理器对两个操作数进行运算时，按照无符号数求得结果，并相应设置进位标志 CF；同时，根据是否超出有符号数的范围设置溢出标志 OF  
应该利用哪个标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数，就应该关心进位；认为是有符号数，则要注意是否溢出

判断运算结果是否溢出的简单规则:

只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确  
其他情况下，则不会产生溢出

设  $X 、 Y 、 Z 、 V$  均为 16 位带符号数，分别存放在  $X 、 Y 、 Z 、 V$  存储单元中，阅读如下程序段，得出它的运算公式，并说明运算结果存于何处？

<table><tr><td>65</td><td>V</td></tr><tr><td>F3</td><td>Z</td></tr><tr><td>02</td><td>Y</td></tr><tr><td>00</td><td rowspan="9">X</td></tr><tr><td>24</td></tr><tr><td>E0</td></tr><tr><td>05</td></tr><tr><td>00</td></tr><tr><td>|</td></tr><tr><td>|</td></tr><tr><td>|</td></tr><tr><td>|</td></tr></table>

mov ax,X

imul Y ; DX.AX = X×Y

mov cx,ax

mov bx,dx ; BX.CX = X×Y

mov ax,Z

cwd ; 参考 2.2.6/P45

add cx,ax

adc bx,dx ; BX.CX = X×Y -

65

F3

02

00

24

E0

05

00

V

Z

Y

X

# 习题 2.9：算术运算 2

sub cx,540

sbb bx,0

; BX.CX = X×Y + Z - 540

mov ax,V

cwd

sub ax,cx

sbb dx,bx 540)

; DX.AX = V - (X×Y + Z -

idiv X

; DX.AX = (V - (X×Y + Z - 540))÷X

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/ce8281abb75e4f5c36ec9a69f50ce50418d89715d9951b1740cea9ad422d176e.jpg)

在正确理解每条指令的功能基础上，可以阅读和编写有实际意义的程序段

多多阅读程序段

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/6a39d3bd1111c6c97cd02320ebe369a9a6ab39471df9f50eefd0f2a96a63ab17.jpg)

# 2.3 位操作类指令

位操作类指令以二进制位为基本单位进行数据的操作

这是一类常用的指令，都应该掌握  
注意这些指令对标志位的影响

1. 逻辑运算指令

AND OR XOR NOT TEST

2. 移位指令

SHL SHR SAR

3. 循环移位指令

ROL ROR RCL RCR

# 逻辑与指令 AND

AND 与运算.  
OR 或运算.  
XOR 异或运算.  
NOT 取反.  
TEST 测试.（两操作数作与运算，仅修改标志位，不回送结果）.  
> SHL 逻辑左移.  
> SAL 算术左移  $(= \mathrm{SHL})$  
> SHR 逻辑右移.  
> SAR 算术右移  $(= \text{SHR})$  
ROL 循环左移.  
ROR 循环右移.  
RCL 通过进位的循环左移.  
RCR 通过进位的循环右移.  
> 以上八种移位指令, 其移位次数可达 255 次。移位一次时, 可直接用操作码。如 SHL AX,1。移位  $>1$  次时, 则由寄存器 CL 给出移位次数。

如 MOV CL,04 SHL AX,CL

# 2.4 控制转移类指令

控制转移类指令用于实现分支、循环、过程等程序结构，是仅次于传送指令的常用指令

重点掌握：JMP/JCC/LOOP CALL/RET  
一般了解：LOOPZ/LOOPNZ INTO

控制转移类指令通过改变 IP（和 C）

S）值，实现程序执行顺序的改变

# 2.4.1 无条件转移

JMP 无条件转移指令  
CALL 过程调用 (子程序调用指令)  
RET/RETF 过程返回.

JMP label ; 程序转向 label 标号指定的地址

指定的目标地址处，从目标地址处开始执行指令

操作数 label 是要转移到的目标地址（目的地址、转移地址）  
JMP指令分成4种类型：

(1) 段内转移、相对寻址（通过偏移地址）  
(2) 段内转移、间接寻址（通过寄存器）  
(3) 段间转移、直接寻址（逻辑地址）  
(4) 段间转移、间接寻址

$\succ$  相对寻址方式

用标号表达

- 相对寻址方式以当前 IP 为基地址，加上位移量构成目标地址

直接寻址方式

用标号表达

■转移地址象立即数一样，直接在指令的机器代码中用寄存器或存

间接寻址方式

用寄存器或存储器操作数表达

转移地址在寄存器或主存单元中

段内转移——近转移（near）

在当前代码段 64KB 范围内转移（±32KB 范围）  
■不需要更改CS段地址，只要改变IP偏移地址

段内转移——短转移（short）

■转移范围可以用一个字节表达，在段内- 128 ~ + 127 范围的转移

段间转移——远转移（fa r）

从当前代码段跳转到另一个代码段，可以在 1MB 范围  
■更改CS段地址和IP偏移地址  
目标地址必须用一个 32 位数表达，叫做 32 位远指针，它

段代码

段代码

实际编程时，MASM 汇编程序会根据目标地址的距离，自动处理成短转移、近转移或远转移  
程序员可用操作符 short、near ptr 或 far ptr 强制

# JMP label

# ; IP←IP+ 位移量

位移量是紧接着 JMP 指令后的那条指令的偏移地址，到目标指令的偏移地址的地址位移  
当向地址增大方向转移时，位移量为正；向地址减小方向转移时，位移量为负

```txt
again: dec cx ; 标号 again 的指令  
……  
jmp again ; 转移到 again 处继续执行  
……  
jmp output ; 转向 output  
……  
output: mov result,al ; 标号 output 的指令
```

JMP r16/m16

; IP← r16/m16

>将一个16位寄存器或主存字单元内容送入IP寄存器，作为新的指令指针，但不修改CS寄存器的内容

jmp ax

; IP←AX

jmp word ptr [2000h]

; IP←[2000h]

# JMP far ptr label

; IP←label 的偏移地址  
; CS←label 的段地址

将标号所在段的段地址作为新的 CS 值, 标号在该段内的偏移地址作为新的 IP 值; 这样, 程序跳转到新的代码段执行

jmp far ptr otherseg ; 远转移到代码段2的 otherseg

# JMP far ptr mem

; IP←[mem] , CS←[mem+2]

用一个双字存储单元表示要跳转的目标地址。这个目标地址存放在主存中连续的两个字单元中的，低位字送IP寄存器，高位字送CS寄存器

mov word ptr [bx],0

mov word ptr [bx+2],1500h

JMP far ptr [bx] ; 转移到 1500h:0

# 2.4.2 条件转移指令

JA/JNBE 高于/不低于等于时转移.

> JAE/JNB 高于等于/不低于转移.  
JB/JNAE 低于I不高于等于转移.  
JBE/JNA 不低于等于/不高于转移.  
> 以上四条，测试无符号整数运算的结果（标志 C 和 Z）。  
> JG/JNLE 大于转移.  
JGE/JNL 大于或等于转移.  
> JL/JNGE 小于转移.  
JLE/JNG 小于或等于转移.  
> 以上四条, 测试带符号整数运算的结果 (标志 S,O 和 Z).

JE/JZ 等于转移.  
JNE/JNZ 不等于时转移.  
$\succ$  JC 有进位时转移.  
JNC 无进位时转移.  
JNO 不溢出时转移.  
JNP/JPO 奇偶性为奇数时转移.  
JNS 符号位为 "0" 时转移.  
JO 溢出转移.  
> JP/JPE 奇偶性为偶数时转移.  
JS 符号位为 "1" 时转移.

cmp cx,0  
jz done

# 例 2.45：记录空格个数

mov cx,count ; 设置循环次数

mov si,offset string

xor bx,bx ; bx = 0 , 记录空格数

jcxz done

mov al,20h ；如果长度为 0 ，退出

again: cmp al,es:[si]

jnz next ; ZF = 0 非空格，转移

inc bx ; ZF=1 是空格，个数加 1

next: inc si

loop again jnz again

; 字符个数减 1 , 不为 0 继续循环

done: mov result,bx; 保存结果

子程序是完成特定功能的一段程序

当主程序（调用程序）需要执行这个功能时，采用CALL调用指令转移到该子程序的起始处执行  
当运行完子程序功能后，采用 RET 返回指令回到主程序继续执行

演示

CALL指令分成4种类型（类似JMP）

CALL label ; 段内调用、相对寻址

CALL r16/m16 ; 段内调用、间接寻址

CALL far ptr label; 段间调用、直接寻址

CALL far ptr mem; 段间调用、间接寻址

CALL指令需要保存返回地址：

段内调用——入栈偏移地址 IP

$$
\mathsf {S P} \leftarrow \mathsf {S P} - 2, \mathsf {S S}: [ \mathsf {S P} ] \leftarrow \mathsf {I P}
$$

段间调用——入栈段地址 CS 和偏移地址 IP

$$
\mathsf {S P} \leftarrow \mathsf {S P} - 2, \mathsf {S S}: [ \mathsf {S P} ] \leftarrow \mathsf {C S}
$$

$$
\mathsf {S P} \leftarrow \mathsf {S P} - 2, \mathsf {S S}: [ \mathsf {S P} ] \leftarrow \mathsf {I P}
$$

根据段内和段间、有无参数，分成4种类型

RET

; 无参数段内返回

RET i16 ; 有参数段内返回

i16 参数的作用

RET

; 无参数段间返回

RET i16 ; 有参数段间返回

需要弹出CALL指令压入堆栈的返回地址

段内返回——出栈偏移地址 IP

$\mathrm{IP} \leftarrow \mathrm{SS}: [\mathrm{SP}], \quad \mathrm{SP} \leftarrow \mathrm{SP} + 2$

段间返回——出栈偏移地址 IP 和段地址 CS

$\mathrm{IP} \leftarrow \mathrm{SS}: [\mathrm{SP}] , \quad \mathrm{SP} \leftarrow \mathrm{SP} + 2$

CS←SS:[SP]，SP←SP+2

# 例 2.46：子程序

# ; 主程序

mov al,0fh ; 提供参数 AL

callhtoasc；调用子程序

#

子程序: 将 AL 低 4 位的一位 16 进制数转换成 ASCII 码

htoasc: and al,0fh ; 只取 al 的低 4 位

or al,30h ; al高4位变成3

cmp al,39h ; 是  $0 \sim 9$ , 还是  $0 \mathrm{Ah} \sim 0 \mathrm{Fh}$

jbe htoend

add al,7 ；是  $0 \mathrm{Ah} \sim 0 \mathrm{F h}$  ，加上7

htoend: ret ; 子程序返回

中断（Interrupt）是又一种改变程序执行顺序的方法

>中断具有多种中断类型  
$\succ$  中断的指令有 3 条:

INT i8 IRET INTO

本节主要掌握类似子程序调用指令的中断调用指令 INT i8，进而学习使用 DOS 功能调用

8086 可以管理 256 个中断  
$\succ$  各种中断用一个向量编号来区别  
主要分成外部中断和内部中断  
外部中断——来自CPU之外的原因引起的中断，又可以分成

■ 可屏蔽中断：可由 CPU 的中断允许标志 IF 控制  
■非屏蔽中断：不受CPU的中断允许标志IF控制

内部中断——CPU 内部执行程序引起的中断，又可以分成：

■ 除法错中断：执行除法指令，结果溢出产生的 0 号中断  
■ 指令中断：执行中断调用指令 INT i8 产生的 i8 号中断  
■ 断点中断：用于断点调试（INT3）的3号中断  
■ 溢出中断：执行溢出中断指令，OF = 1产生的4号中断  
■ 单步中断：TF = 1 在每条指令执行后产生的 1 号中断

# INT i8

; 中断调用指令: 产生 i8 号中断

# IRET

; 中断返回指令: 实现中断返回

# INTO

; 溢出中断指令:  
; 若溢出标志  $OF = 1$ , 产生 4 号中断  
；否则顺序执行

# 教学提示

在学习和应用汇编语言进行程序设计时，有一些经常遇到的问题，例如算术运算、代码转换等，需要掌握

总结常见编程问题

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-27/e008fb5e-bb4b-4647-9fd3-a6266dac46b0/eb7fd822825fb4c49f1366fce5514deef0c03df7e99baa0e7409970ad0c913b8.jpg)

# 对CPU状态进行控制的指令

■NOP CS: SS: DS: ES:  
■LOCK HLT ESC WAIT

# NOP

不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期  
NOP 常用于程序调试

在需要预留指令空间时用 NOP 填充  
- 代码空间多余时也可以用 NOP 填充  
还可以用NOP实现软件延时

事实上，NOP 和 XCHG AX,AX 的指令代码一样，都是 90H

在允许段超越的存储器操作数之前，使用段超越前缀指令，将采用指定的段寄存器寻址操作数

CS: 使用代码段的数据  
SS: ; 使用堆栈段的数据  
DS: ; 使用数据段的数据  
ES: ; 使用附加段的数据

# LOCK ; 封锁总线

这是一个指令前缀，可放在任何指令前  
这个前缀使得在这个指令执行时间内，8086 处理器的封锁输出引脚有效，即把总线封锁，使别的控制器不能控制总线；直到该指令执行完后，总线封锁解除

# HLT

# ；进入暂停状态

暂停指令使 CPU 进入暂停状态，这时 CPU 不进行任何操作。当 CPU 发生复位或来自外部的中断时，CPU 脱离暂停状态  
> HLT 指令可用于程序中等待中断。当程序中必须等待中断时，可用 HLT，而不必用软件死循环。然后，中断使 CPU 脱离暂停状态，返回执行 HLT 的下一条指令

# ESC 6 位立即数 ,reg/mem

; 把浮点指令交给浮点处理器执行

浮点协处理器 8087 指令是与 8086 的整数指令组合在一起的，当 8086 发现是一条浮点指令时，就利用 ESC 指令将浮点指令交给 8087 执行  
实际编写程序时，一般采用易于理解的浮点指令助记符格式

ESC 6,[SI]

; 实数除法指令: FDIV dword ptr [SI]

ESC 20H,AL

; 整数加法指令: FADD ST(0),ST

# WAIT ; 进入等待状态

> 8086利用WAIT指令和测试引脚实现与8087同步运行  
浮点指令经由 8086 处理发往 8087，并与 8086 本身的整数指令在同一个指令序列；而 8087 执行浮点指令较慢，所以 8086 必须与 8087 保持同步

本章详细而完整地介绍了 8086 的 16 位指令系统的指令  
希望大家进行一下整理（总结）：

寻址方式  
■ 指令支持的操作数形式  
■ 指令对标志的影响  
常见编程问题

通过复习整理，形成指令系统的整体概念，进而掌握常用指令

# 第2章 教学要求（1）

1. 熟悉 8086 的基本参数、堆栈工作原理、常用状态标志及指令对其影响、符号扩展的含义、压缩和非压缩 BCD 的格式、串操作寻址特点  
2. 掌握基本指令：MOV / XCHG、PUSH / POP、LEA；ADD / ADC / INC、SUB / SBB / DEC / NEG / CMP；AND / OR / XOR / NOT / TEST、SHL / SHR / SAR、ROL / ROR / RCL / RCR；JMP / Jcc、LOOP、CALL / RET、INT n

# 第2章 教学要求（2）

3. 熟悉特色指令：XLAT；MUL / IMUL、DIV / IDIV、CBW / CWD；NOP、CLC / STC / STC、CLD / STD  
4. 了解其他指令：LAHF / SAHF / PUSHF / POPF、LDS / LES ; DAA / DAS、AAA / AAS、AAM / AAD ; IRET、LOOPZ / LOOPNZ、INTO ; HLT、CLI / STI

习题：2.1 2.6 2.8 2.10

2.20 2.22 2.24 (3) (6) (7)