# 第4章 基本汇编语言程序设计

与高级语言类似, 编写汇编语言源程序首先应理解和分析题目要求, 选择适当的数是构及合理的算法, 再着手用语言来实现。但是汇编语言面向机器的特点要求我们在编写时要严格遵守其语法及程序结构方面的规定, 小心处理程序的每个细节。

汇编语言源程序的主体（代码段）可以包括顺序、分支、循环结构和子程序、宏等。管早期版本的汇编程序不直接支持结构化程序设计，但是用户仍然可以用微处理器指令系中的转移指令、循环指令、子程序调用及返回指令，实现程序的各种结构。

本章学习怎样编写一个功能和结构完整的汇编语言源程序, 即对第  $2 \sim 3$  章硬指令、令和程序结构方面基本知识的综合运用。

# 4.1 顺序程序设计

顺序程序结构按照指令书写的前后顺序执行每条指令，是最基本的程序片段，也是复杂程序的基础，如构成分支程序的分支体、循环结构的循环体等。

【例4.1】 将一个字节数据以十六进制数形式显示

分析：一个字节二进制8位、对应十六进制2位，每个十六进制位需要转换为 ASCII 显示。本例没有采用例2.46的转换方法，而是通过查表实现 ASCII 码转换，然后逐位显形成顺序程序结构。

```asm
;数据段  
hex db 4bh ; 待显示的字节数据  
ascii db 30h,31h,32h,33h,34h,35h,36h,37h,38h,39h  
db 41h,42h,43h,44h,45h,46h ; ASCII 表  
;代码段  
mov bx, offsetascii ; BX指向ASCII表  
mov al, hex ; AL取得字节数据  
mov cl, 4 ; 先显示二进制高4位（对应十六进制一位  
sar al, cl ; 高4位移位到低4位，即ASCII表中的位号  
xlat ; 换码：AL←DS: [BX+AL]  
mov dl, al ; 入口参数：DL←AL  
mov ah, 2 ; 02号DOS功能调用  
int 21h ; 显示数据高位  
mov al, hex ; al取得字节数据  
and al, 0fh ; 高4位清0，只有低A位有效  
xlat ; 换码  
mov dl, al  
mov ah, 2
```

# 【例4.2】 自然数求和程序

分析: 自然数求和可以采用循环累加的方法, 但利用等差数列的求和公式, 能够避免重复相加, 得到改进的算法。求和公式:  $1 + 2 + 3 + \dots + N = (1 + N) \times N \div 2$  。

程序中, 可以在数据段定义一个变量 NUM, 作为 N 值; 并预留保存求和结果的双倍长变量 SUM。代码段按照公式顺序使用加法、乘法和移位指令实现加1、乘以 N 和除以2, 最后保存结果。因为没有方便的实现数值显示的功能调用、子程序或者函数, 程序没有显示结果。这也是一个典型的高级语言求解算术表达式的过程。

```txt
;数据段 num dw 3456 ;假设一个n值（小于  $2^{16} - 2$  ） sum dd ? ;代码段 mov ax, num ;ax=n add ax, 1 ;ax=n+1 mul num ;dx. ax=(1+n)×n shr dx, 1 ;32位逻辑右移一位，相当于除以2 rcr ax, 1 ;dx. ax=dx. ax÷2 mov word ptr sum, ax mov word ptr sum+2, dx ;按小端方式保存
```

因为自然数求和是无符号整数，所以使用无符号乘法指令MUL。乘积是双倍长的数据、保存于DX.AX寄存器对中，然后使用右移1位方法实现32位数据除以2（没有使用无符号除法指令）。使用16位指令实现32位数据移位的方法可以参考例2.35程序片段。

# 4.2 分支程序设计

分支程序结构有单分支 if-then 和双分支 if-then-else 两种基本形式。当程序的逻辑根据某一条件表达式为真或为假，执行两个不同处理之一时，便是双分支形式；当有其中一个处理为空时，就是单分支形式；如果分支处理中又嵌套有分支，或者说具有多个分支走向时，即为逻辑上的多分支形式。

条件转移 JCC 和无条件转移 JMP 指令用于实现程序的分支结构。JMP 指令仅实现转移到指定位置, JCC 指令则可根据条件转移到指定位置或不转移而顺序执行后续指令序列。条件转移语句不支持一般的条件表达式, 它是根据当前的某些标志位的设置情况实现转移或不转移。因此, 必须在条件转移指令前安排算术运算、比较、测试等影响相应标志位的指令, 细节请参考第2章。

# 4.2.1 单分支结构

单分支程序结构是只有一个分支的程序，类似高级语言的 if-then 语句结构（没有 else 语句）。计算有符号数据的绝对值就是一个典型的单分支结构：正数不变，负数求补。

```txt
cmp ax, 0  
jge nonneg ; 分支条件：ax > 0  
neg ax ; 条件不满足，为负数，需要执行分支体进行求补
```

nonneg: mov result, ax ; 条件满足, 为正数, 保存结果

对于单分支程序, 需要正确选择分支条件。因为 JCC 指令是条件成立才能发生转移,所以分支语句体是在条件不成立时顺序执行, 如图4-1所示。这与高级语言的分支 if 语句不同, 请特别注意, 否则求绝对值的例子成为:

cmp ax, 0

j1 yesneg

jmp nonneg

yesneg: neg ax

nonneg: mov result, ax

；分支条件：  $ax <   0$

；条件不满足，为正数，不需要求补，转向保存结果

；条件满足，为负数，需要求补

；保存结果

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/fc24370eac8debd2f251ed889465e46eb04f7ca1a2a125680ed82b10d7625ef0.jpg)  
图4-1 单分支结构的流程图

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/8920a3a2d98ec13fa4e694eef93fb54679f482d5ed157c60b7511c9b82e586a5.jpg)

比较上述两个程序段，由于后者选择分支条件不当，不仅多了一个 JMP 指令，还容易出错。对于后者程序段，这个 JMP 指令是不可缺少的。

# 4.2.2 双分支结构

双分支程序结构有两个分支, 条件为真, 执行一个分支, 条件为假, 则执行另一个分支,相当于高级语言的 if-then-else 语句。例如, 将数据最高位显示出来就可以采用双分支结构:最高位为 0 显示字符 0、为 1 显示字符 1。

shl bx, 1

jc one

mov d1, '0'

jmp two

one: mov dl, '1'

two: mov ah, 2

int 21h

; BX 最高位移入 CF 标志

；  $CF = 1$  ，即最高位为1，转移

；  $CF = 0$  ，即最高位为  $\theta$  ：DL←'0'

；一定要跳过另一个分支体

; DL←'1'

；显示

对于双分支程序, 两种情况都有各自的分支语句体, 选择条件并不关键。但是, 顺序执行的分支语句体1不会自动跳过分支语句体2, 所以分支语句体1的最后一定要有一条 JMP 指令跳过分支体2, 即分支汇点处; 否则, 将进入顺序分支语句体2而出现错误, 如图4-2所示。这与高级语言不同。类似自然语言的高级语言使程序员不必操心这些细节。

上例中, 如果条件转移指令选择 JNC, 则只要交换两个分支语句体的位置即可。该程序也可以修改成为单分支程序结构。这只要事先假设一种情况, 如假设 BX 最高位为 0 , 则只要 BX 最高位为 1 才需要执行分支语句, 如下所示:

mov dl, '0'

sh1 bx,1

JNC two

mov d1, 1

$\therefore {DL} = {0}^{\prime }$

; BX 最高位移入 CF 标志

$\therefore {CF} = 0$  ,即最高位为0,转移

$\therefore {CF} = 1$  ,即最高位为  $1 : {DL} \leftarrow  {1}^{\prime }$

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/b289acf2d7c278aabb36c6ee10d22c70cf2deae64b09c801d9cfefee450aabe9.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/745e673f1bc18570df4d200ef2c4cd0ebd91674cd14240cf28f39cef00183366.jpg)  
图4-2 双分支结构的流程图

two: mov ah,2

int 21h ;显示

由此可见, 编写分支程序必须留心分支的开始点和结束点, 当出现多分支时更是如此。这正是汇编语言编写程序的繁杂体现之一, 也是学习上的一个难点。

【例4.3】判断方程  $ax^2 + bx + c = 0$  是否有实根, 若有实根, 则将字节变量 TAG 置 1 , 否则置 0 (假设 a、b、c 均为字节变量, 表达  $-127 \sim +127$  的数据)。

分析: 二元一次方程有根的条件是  $b^{2} - 4ac \geqslant 0$  。依据题意, 首先计算出  $b^{2}$  和  $4ac$ , 然后比较两者大小, 根据比较结果分别给 TAG 赋不同的值。

```asm
;数据段  
_a db ?  
_b db ?  
_c db ?  
_tag db ?  
;代码段  
mov al, _b  
imul al  
mov bx, ax ;bx中为b2  
mov al, _a  
imul _c  
mov cx, 4  
imul cx ;ax中为4ac（按照题目假设dx不含有效数值）  
cmp bx, ax ;比较二者大小  
jge yes ;条件满足？  
mov tag, 0 ;第一个分支体：条件不满足，tag--0  
jmp done ;跳过第二个分支体  
yes; mov tag, 1 ;第二个分支体：条件满足，tag--1  
done:
```

# 4.2.3 多分支结构

实际问题有时并不是单纯的单分支或双分支结构就可以解决, 往往分支处理中又嵌套有分支, 或者说具有多个分支走向, 这可以认为是逻辑上的多分支结构。一般利用单分支和双分支这两个基本结构, 就可以解决程序中多个分支结构的问题。

例如, DOS 功能调用利用 AH 指定各子功能, 可以采用如下程序片段, 实现多分支:

```txt
or ah, ah  
jz function0  
dec ah  
jz function1  
dec ah  
jz function2  
…
```

如果分支较多，上述方法显得有些烦琐。但是，可以构造一个入口地址表实现多分支，下面通过一个简单的示例说明。

【例4.4】程序根据键盘输入的  $1 \sim 8$  数字转向 8 个不同的处理程序段。

分析：在数据段定义一个存储区，顺序存放8个处理程序段的起始地址。所有程序都在一个代码段，所以用字定义伪指令 DW 存入偏移地址。为了具有良好的交互性，程序首先提示输入数字，然后判断是否为  $1 \sim 8$  。不是有效数字，则重新提示；是有效数字，则形成表中的正确偏移，并按地址表跳转。为了简化处理程序段，假设只是显示8个不同的信息串。

根据不同的输入值转向不同的程序片段, 与 C 语言多分支选择 switch 语句对应, 程序流程参考图4-3。而本示例程序所采用的地址表方法也就是 C 语言编译程序通常对 switch 语句采用的编译方法。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/e75cc26b6a49248af7018d0569a9aadd9a8a276153d0029761b2b6d788c4c5cf.jpg)  
图4-3 地址表程序流程（多分支结构）

# ；数据段

```csv
msg db 'Input number (1~8): ', 0dh, 0ah, '$'  
msg 1 db 'Chapter 1: Fundamentals of assembly language', 0dh, 0ah, '$'  
msg 2 db 'Chapter 2: 8086 instruction set', 0dh, 0ah, 's'  
msg 3 db 'Chapter 3: Statements of assembly language', 0dh, 0ah, '$'  
msg 4 db 'Chapter 4: Basic assembly language programming', 0dh, 0ah, '$'  
msg 5 db 'Chapter 5: Advanced assembly language programming', 0dh, 0ah, '$'  
msg 6 db 'Chapter 6: 32-bit instructions and programming', 0dh, 0ah, '$'  
msg 7 db 'Chapter 7: Mixed programming with C/C++, 0dh, 0ah, '$'  
msg 8 db 'Chapter 8: FP instructions and programming', 0dh, 0ah, '$'  
table dw disp1, disp2, disp3, disp4, disp5, disp6, disp7, disp8
```

```asm
;取得各标号的偏移地址  
；代码段  
start1: mov dx, offset msg ;提示输入数字  
mov ah, 9  
int 21h  
mov ah, 1 ;等待按键  
int 21h  
cmp al, '1' ;数字<1?  
jb start1  
cmp al, '8' ;数字>8?  
ja start1  
and ax, 000fh ;将ASCII码转换成数值  
dec ax  
shl ax, 1 ;等效于add ax, ax  
mov bx, ax  
jmp table[bx] ;（段内）间接转移：IP←[TABLE+BX]  
start2: mov ah, 9  
int 21h  
_exit 0  
disp1: mov dx, offset msg1 ;处理程序1  
jmp start2  
disp2: mov dx, offset msg2 ;处理程序2  
jmp start2  
disp3: mov dx, offset msg3 ;处理程序3  
jmp start2  
disp4: mov dx, offset msg4 ;处理程序4  
jmp start2  
disp5: mov dx, offset msg5 ;处理程序5  
jmp start2  
disp6: mov dx, offset msg6 ;处理程序6  
jmp start2  
disp7: mov dx, offset msg7 ;处理程序7  
jmp start2  
disp8: mov dx, offset msg8 ;处理程序8  
jmp start2
```

本例题有8个分支，标号是DISP1～DISP8。各分支程序很简单，获得对应信息的存放地址，然后显示。为实现分支，在数据段构造了一个地址表TABLE，依次存放分支目标地址（使用标号就表示其地址，也可以用OFFSET获得）。

利用1号 DOS 功能输入一个字符后，先确定是数字  $1 \sim 8$  之间的 ASCII 字符（不是的话，要求重新输入），接着将其转换为  $1 \sim 8$  的数值。数值减1的目的是对应地址表，因为1号分支对应的 DISP1 标号地址存放在地址表位移量为0的位置。接着左移1位实现乘2，因为分支地址是16位，在地址表中占2字节。例如，输入3、减1为2，乘2为4，对应 DISP3 在地址表位移量也是4。

利用地址表构造的多分支程序结构，需要使用间接寻址的转移指令实现跳转。程序“JMP TABLE[BX]”指令的目标地址IP取自“TABLE+BX”指向的主存地址位置，正是应分支目标地址。

间接寻址的 JMP 转移指令还有其他形式。例如，示例程序中的 JMP 指令还可以使用下指令实现：

add bx, offset table ; 计算偏移地址

jmp word ptr[bx] ; 多分支跳转

另外，该指令也可以替换成“call table[bx]”，则所有处理程序中最后的“jmp start2”指令，应该更改为“RET”指令。

针对本程序比较简单的功能，地址表中还可以直接存放信息字符串的地址，如下更地完成要求：

table dw msg1, msg2, msg3, msg4, msg5, msg6, msg7, msg8, msg9

```txt
dec ax shl ax, 1 乘以2，因为地址表是以2字节为单位 mov bx, ax mov dx, table[bx] 获得信息字符串地址 mov ah, 9 显示 int 21h
```

# 4.3 循环程序设计

当需要重复执行某段程序时, 可以利用循环程序结构。循环结构一般是根据某一条断为真或假来确定是否重复执行循环体, 条件永真或无条件的重复循环就是逻辑上的死 (永真循环、无条件循环)。

循环结构的程序通常由三部分组成，如图4-4(a)所示：

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/4e506b1e6cc746a4ed48e2427a53ceb5d750f0e52ac8facfaa64bbe6210ee311.jpg)

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/f472af9ec1ae59165dd952f1881ea722404fc4609760d961fe1b70043db2f650.jpg)  
图4-4 循环程序结构

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/9a8fabab01597ae80cc10b559c665e0677e1b3ada225fecacae05a616d581f03.jpg)

循环初始部分——为开始循环准备必要的条件，如循环次数、循环体需要的初始  
循环体部分——重复执行的程序代码，其中包括对循环条件修改的程序段。  
循环控制部分——判断循环条件是否成立，决定是否继续循环。

其中, 循环控制部分是编程的关键和难点。循环条件判断的循环控制可以在进入循环之

行, 即形成 “先判断、后循环” 的循环程序结构 (如图4- 4(b)所示)。如果循环之后进行循环条件判断, 即形成 “先循环、后判断” 的循环程序结构 (如图4- 4(c)所示)。

# 4.3.1 计数控制循环

比较简单的循环程序是通过次数控制循环，即计数控制循环。

8086 CPU 指令集中有一组专门用于循环控制的指令: JCXZ、LOOP、LOOPE/LOOPZ 和 LOOPNE/LOOPNZ, 第2章中已详细讲述了这组指令的功能。从某种意义上讲, 它们都是计数循环, 即用于循环次数已知或最大循环次数已知的循环控制, 且必须预先将循环次数或最大循环次数置入 CX 寄存器; LOOPE/LOOPZ、LOOPNE/LOOPNZ 只是在计数循环的基础上增加了关于 ZF 标志位的测试, 可根据标志位 ZF 值的当前状态提前退出记数循环或继续下一次循环。

【例4.5】计算  $1 \sim 100$  数字之和，并将结果存入字变量 SUM 中。

分析: 程序要求  $\mathrm{SUM} = 1 + 2 + 3 + \dots + 99 + 100$ , 这是一个典型的计数循环, 完成100次简单加法。我们编写一个100次的计数循环结构: 循环开始前将被加数清0, 加数置1, 循环体内完成一次累加, 每次的加数递增1。LOOP指令要求循环次数预置给 CX, 每次循环 CX 递减 1 。这样, 循环体内加数就可以直接用循环控制变量 CX 简化循环体, 完成与题目等价的  $100 \sim$  1 的累加。

```txt
sum ; 数据段  
sum dw ?  
; 代码段  
xor ax, ax  
mov cx, 100  
again: add ax, cx  
loop again  
mov sum, ax  
; 将累加和送入指定单元
```

【例4.6】确定字变量wordX中为1的最低位数（0～15），并将结果存于变量byteY中；若wordX中没有为1的位，则将-1存入byteY。

分析: 对wordX中的16个位, 从低位向高位依此循环测试, 第一个为1的位数便是题目所求, 因此循环的最大次数为16。循环开始前将计位数置-1, 循环体内每次对计位数加1后, 测试目标最低位, 再将目标循环右移1位 (为下一次测试做准备)。由于循环移位指令不影响ZF标志位, 故可根据当前ZF的设置情况得到判断: 若ZF=0, 则测试结果非0, 被测位为1,从而找到定位, 退出循环; 若ZF=1, 则被测位不满足要求, 应进行下一次循环, 继续测试目标的次低位。此循环控制与LOOPE指令功能吻合。循环体结束后, 根据ZF的设置将计位数或-1送byteY单元。

```txt
;数据段  
wordx dw 56  
bytey db ?  
;代码段  
mov ax, wordx ;测试目标送AX  
mov cx, 16 ;循环计数器置初值  
mov dl,-1 ;计位器置初值
```

```txt
again: inc d1 test ax, 1 rer ax, 1 loope again ; 循环指令不影响 ZF je notfound mov byte, d1 jmp done notfound:mov byte, -1 ; ZF=1，测试目标的16个位均为0 done:
```

# 4.3.2 条件控制循环

在例4.5中，循环控制条件是循环次数，这是比较常见和简单的情况。在例4.6中，循环控制条件又加上了ZF。实际上，循环控制条件有时是比较复杂的，很多循环并不能预先知道循环次数或确切的最大循环次数，而且循环体内可能还需将CX另做他用，与循环控制计数器冲突。换句话说，循环指令的功能是较弱的，不能满足更复杂的循环结构要求。

转移指令可以指定目标标号来改变程序的运行顺序, 如果目标标号指向一个重复执行的语句体的开始或结束, 实际上便构成了循环控制结构。这时, 程序重复执行带标号的语句至转移指令之间的循环体。利用条件转移指令支持的转移条件作为循环控制条件, 被称为条件控制循环。这种循环还可以构造复杂的循环程序结构。例如, 循环体中嵌套有循环 (多重循环结构), 循环体中具有分支结构, 分支体中采用循环结构。

【例4.7】把一个字符串中的所有大写字母改为小写字母, 该字符串以‘0’结尾。

分析：这是一个循环次数不定的循环程序结构，宜用转移指令决定是否循环结束，并应该先判断后循环。循环体判断每个字符，如果是大写字母，则转换为小写，否则不予处理。循环体中具有分支结构。大、小写字母的 ASCII 码不同之处是：大写字母的  $D_{5}=0$  ，而小写字母的  $D_{5}=1$  。

```txt
string db 'Hello, Everybody!', 0  
；可以任意给定一个字符串  
；代码段  
mov bx, offset string  
again: mov al, [bx]  
or al, al  
jz done  
cmp al, 'a'  
jb next  
cmp al, 'z'  
ja next  
or al, 20h  
mov [bx], al  
；是，转换为小写字母（使  $D_{5}=1$ ）  
next: inc bx  
jmp again  
done:
```

字符串用'0'结尾，也可以用JCXZ指令判断。例如：

```txt
mov ch, 0
```

```txt
mov cl, [bx]  
jcxz done
```

计算机中表达字符串时常用三种方法标识结束。最简单的方法是固定长度, 但不够灵活。在Pascal等语言中, 字符串最开始的单元存放该字符串的长度。比较常用的方法是使用结尾字符, 也就是字符串最后使用一个特殊的标志。结尾字符曾使用过字符‘$’(如DOS 的9号功能调用)、回车字符CR (ASCII值是13)、换行字符LF (ASCII值是10)等, 现在多使用‘0’(即ASCII表的第一个字符, 常表达为NULL或NUL常量)。使用‘0’作为字符串结尾是C/C++和Java语言的规定, 也可以避免在字符串中出现结尾字符的情况。

# 4.3.3 多重循环

计数控制循环往往至少执行一次循环体之后, 才判断次数是否为 0 , 这是所谓的 “先循环、后判断” 循环结构。条件控制循环更多见的是 “先判断、后循环” 结构。实际的应用问题, 不会只有单纯的分支或循环, 两者可能同时存在, 即循环体中具有分支结构, 分支体中采用循环结构。

有时, 循环体中嵌套有循环, 即形成多重循环结构。在多重循环中, 如果内外循环之间没有关系, 问题比较容易处理; 但如果需要传递参数或利用相同的数据, 问题就比较复杂了。

【例4.8】采用“冒泡法”，把一个长度已知的数组元素按从小到大排序。假设数组元素为无符号字节量。

分析: 实际的排序算法很多, “冒泡法” 是一种易于理解和实现的方法, 但并不是最优的算法。“冒泡法”从第一个元素开始, 依次对相邻的两个元素进行比较, 使前一个元素不大于后一个元素; 将所有元素比较完后, 最大的元素排到了最后; 然后, 除掉最后一个元素之外的元素, 依上述方法再进行比较, 得到次大的元素排在后面; 如此重复, 直至完成实现元素从小到大的排序, 如图4-5所示 (图中段设只有5个数据)。可见, 这是一个双重循环程序结构。外循环由于循环次数已知, 可用LOOP指令实现; 而内循环次数每次外循环后减少一次, 用DX表示。循环体比较两个元素大小, 又是一个分支结构。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/fc331fb02a04c9cb104db754ee9e86bd64801f7ed261c7c78d78828c3570d6d2.jpg)  
图4-5 冒泡法的排序过程

```txt
;数据段  
array db 56h, 23h, 37h, 78h, 0ffh, 0, 12h, 99h, 64h, 0b0h  
db 78h, 80h, 23h, 1, 4, 0fh, 2ah, 46h, 32h, 42h  
count equ (\(-array)/typearray ; 计算数据个数；代码段  
mov cx, count ; \(\mathbf{C}\mathbf{x}^{-}\) 数组元素个数  
dec cx ; 元素个数减1为外循环次数
```

```txt
outlp: mov dx, cx ; DX←内循环次数  
mov bx, offset array  
inlp: mov al, [bx] ; 取前一个元素  
cmp al, [bx+1] ; 与后一个元素比较  
jna next ; 前一个不大于后一个元素，则不进行交换  
xchg al, [bx+1] ; 否则，进行交换  
mov [bx], al  
next: inc bx ; 下一对元素  
dec dx  
jnz inlp ; 内循环尾  
loop outlp ; 外循环尾
```

【例4.9】现有一个以‘$'结尾的字符串,要求剔除其中的空格字符。

这是一个循环次数不定的循环程序结构,应该用判断字符是否为$作为循环控制条件。循环体判断每个字符,如果不是空格,不予处理继续循环;是空格,则进行剔除,也就是将后续字符前移一个字符位置,将空格覆盖,这又需要一个循环。循环结束条件仍然用字符是否为$进行判断。可见,这还是一个双重循环程序结构。

```asm
string ; 数据段
string db 'Let us have a try! ', '$'
; 假设一个字符串
; 代码段
mov si, offset string
outlp: cmp byte ptr[si], '$'
jz done
cmp byte ptr[si],
jnz next
mov di, si
inlp: inc di
mov al, [di]
mov [di-1], al
cmp byte ptr[di], '$'
jnz inlp
jmp outlp
next: inc si
jmp outlp
done:
```

# 4.3.4 串操作类指令

以字节、字或双字等为单位的多个数据存放在连续的主存区域中就形成数据串(String), 即数组 (Array), 如以字节为单位的 ASCII 字符串就是典型的数据串。数据串是程序经常需要处理的数据结构, 前面字符串处理、数组排序等循环结构程序都是串操作。为了方便进行数据串操作, 8086指令系统特别设计了串操作类指令, 很有特色。

根据串数据类型的特点，串操作指令采用了特殊的寻址方式：

源操作数用寄存器 SI 间接寻址，默认在数据段 DS 中，即 DS:[SI]，允许段超越。  
目的操作数用寄存器 DI 间接寻址，默认在附加段 ES 中，即 ES:[DI]，不允许段超越。  
每执行一次串操作，源指针SI和目的指针DI将自动修改；±1或±2。

对于以字节为单位的数据串（指令助记符用B结尾）操作，地址指针应该±1。  
对于以字为单位的数据串（指令助记符用 W 结尾）操作，地址指针应该±2。  
当方向标志  $\mathrm{DF} = 0$  (执行 CLD 指令设置), 地址指针应该 +1 或 +2。  
当方向标志  $\mathrm{DF} = 1$  (执行 STD 指令设置), 地址指针应该 -1 或 -2。

串操作后, 之所以自动修改 SI 和 DI 指针, 是为了方便对后续数据的操作, 修改的数值对应数据串单位所包含的字节数。用户通过执行 CLD 或 STD 指令控制方向标志 DF, 决定主存地址是增大 (DF=0, 向地址高端增量) 还是减小 (DF=1, 向地址低端减量)。

串操作指令有两组：一组实现数据串传送，另一组实现数据串检测。串操作通常需要重复进行，所以经常配合重复前缀指令，通过计数器 CX 控制重复执行串操作指令的次数。

# 1. 串传送指令

这组串操作指令实现对数据串的传送 MOVs、存储 STOS 和读取 LODS，可以配合 REP 重复前缀，它们不影响标志。

(1) 串传送指令 MOVS 将数据段中的字节或字数据, 传送至 ES 指向的段:

```txt
movsb ; 字节串传送：es:[di]←ds:[si]，然后：si←si±1，di←di±1  
movsw ; 字串传送：es:[di]←ds:[si]，然后：si←si±2，di←di±2
```

② 串存储指令 STOS 将 AL 或 AX 内容存入 ES 指向的段:

```txt
stosb ; 字节串存储: es:[di]←al, 然后: di←di±1  
stosw ; 字串存储: es:[di]←ax, 然后: di←di±2
```

③ 串读取指令LODS将数据段中的字节或字数据读到AL或AX:

```txt
iodsb ; 字节串读取：al←ds:[si]，然后：si←si±1  
Iodsw ; 字串读取：ax←ds:[si]，然后：si←si±2
```

④ 重复前缀指令 REP 用在 MOVS、STOS 和 LODS 指令前，利用计数器 CX 保存数据串长度，可以理解为“当数据串没有结束（CX≠0），则继续传送”：

```txt
rep ；每执行一次串指令，cx减1，直到  $cx = 0$  ，重复执行结束
```

注意, 串操作指令本身仅进行一个数据的操作, 利用重复前缀才能实现连续操作。重复前缀指令先判断 CX 是否为0, 为0结束; 否则进行减1操作, 并执行串操作指令。

串操作指令都还支持书写串名的格式, 如 MOVS 指令还可以写成:

```txt
movs 目的串名，源串名
```

这种格式增加了可读性, 但要求两个串名 (变量名) 类型一致, 并以其类型区别是字节或字操作。

【例4.10】将数据段SRCMSG指示的字符串传送到DSTMSG指示的主存区。

；数据段

srcmsg db 'Try your best, why not.'

dstmsg db sizeof srcmsg dup(?)

```txt
;代码段  
mov ax, ds  
mov es, ax  
mov si, offset srcmsg;设置附加段ES=DS  
mov di, offset dstmsg;SI=源字符串地址  
mov cx, lengthof srcmsg;SI=源字符串地址  
mov cx, lengthof dstmsg;CX=字符串长度、即传送次数  
cld;地址增量传送  
rep movsb ;重复进行字符串传送
```

```txt
mov ah, 9 ; 显示字符串  
mov dx, offset dstmsg  
int 21h
```

使用串传送指令 MOVS，需要事前设置 DS、ES、SI、DI 和方向标志 DF，并将 CX 值为需要重复的次数。这样，简单的一条指令就完成了全部传送工作。如果不使用重复前缀需要用循环指令：

```txt
again: movsb loop again
```

MOVSB 指令每次只传送一字节数据, 如果字符串很长, 可以使用 MOVSW 提高效例如:

```txt
mov dx, cx ;字符串长度，转存DX  
shr cx, 1 ;长度除以2  
rep movsw ;以字为单位重复传送  
mov cx, dx  
and cx, 01b ;求出剩余的字符串长度（0~1）  
rep movsb ;以字节为单位传送剩余的字符
```

利用串操作指令, 通常使用地址增加 (DF=0) 的正向传送方式; 但有些情况下必须行反向传送, 如将一个字符串向高地址区顺序移动若干单元。

实际上，很多时候可以不使用数据串指令，但通常需要使用一个循环程序。例如：

```txt
xor si, si ; SI指向首个字符  
mov cx, lengthof srcmsg ; CX=字符串长度，即传送次数  
again: mov al, srcmsg[si] ; 取源字符串中的字符  
mov dstmsg[si], al ; 传送到目的字符串中  
inc si ; SI增量，指向下一个字符  
loop again ; 重复传送
```

实现数据块在主存中移动是串传送指令 MOVS 经常应用的情况，串存储指令 STOS 常用于主存的填充，如缓冲区的初始化等。

【例4.11】 设置显示缓冲区。

在 DOS 的标准显示模式下, 屏幕由 25 行、每行 80 列字符组成 (  $25 \times 80$  显示模式)。每字符由 2 字节控制显示, 高字节为字符属性字节。例如, 07H 是标准的黑底白字, 低字节字符的 ASCII 码。从逻辑地址 B800H:0000H 开始的显示缓冲区, 每个字单元内容对应一显示字符, 共  $25 \times 80$  个字单元。

本例将 B800:000开始的  $25 \times 80$  个字单元全部填入  $0720 \mathrm{H}$ , 实现清除屏幕的目的 (相当 DOS 的清屏命令 CLS)。

```asm
.model tiny   
.code   
.startup   
mov dx,0b800h   
mov es,dx   
mov di,0 ；设置ES:DI=B800H:0000H   
mov cx,25\*80 ；设置CX=填充个数   
mov ax,0720h ；设置AX=填充内容   
cld   
rep stosw
```

```txt
. exit 0 end
```

本例设置 AL 为  $20 \mathrm{H}$ , 即空格字符, 将显示缓冲区填充为空格, 实现了清除屏幕作用 (程序运行后, 最后显示的命令行是 DOS 加上的)。如果将 AX 值设置为  $0731 \mathrm{H}$ , 则屏幕将充满数字 1; 如果  $\mathrm{AX} = 0141 \mathrm{H}$ , 则屏幕将充满蓝色字母 A。

本例没有通过功能调用, 而是直接读写显示缓冲区实现显示输出, 常被称为 “直接写屏” 方法。这是直接针对硬件操作的程序, 属于最底层的驱动程序。

【例4.12】数据段 DS 中有一个数据块, 具有 COUNT 字节, 起始地址为 BLOCK。现在要把其中的正数、负数分开, 分别存入同一个段的两个缓冲区。存放正数的起始地址为 DPLUS, 存放负数的起始地址为 DMINUS。

```txt
;数据段  
block db 12, -87, 63, 85, 0, -32  
count equ lengthof block  
dplus db count dup(?)  
dminus db count dup(?)  
;代码段  
mov si, offset block  
mov di, offset dplus  
mov bx, offset dminus  
mov ax, ds  
mov es, ax ;所有数据都在一个段中，所以设置ES=DS  
mov cx, count ;CX←字节数  
cld  
go_on: lodsb ;从block取出一个数据  
test al, 80h ;检测符号位，判断是正是负  
jnz minus ;符号位为1，是负数，转向minus  
stosb ;符号位为0，是正数，存入dplus  
jmp again ;程序转移到again处继续执行  
minus: xchg bx, di  
stosb ;把负数存入dminus  
xchg bx, di  
again: dec cx ;字节数减1  
jnz go_on ;完成正负数据分离
```

LODS 指令虽然可与前缀 REP 一起使用, 但因为每重复一次, AL/AX 寄存器中的内容就要改写一次, 最后的执行结果只会保留最后一个数据, 所以没有实际意义。

# 2. 串检测指令

这组串操作指令实现对数据串的比较 CMPS 和扫描 SCAS。串比较和扫描的实质是进行减法运算, 所以它们像减法指令一样影响标志。这两个串操作指令可以配合重复前缀 REPE/REPZ 和 REPNE/REPNZ, 通过 ZF 标志说明两数是否相等。

(1) 串比较指令 CMPS 用源数据串减去目的数据串, 以比较两者间关系。

cmspsb

; 字节串比较: DS:[SI]-ES:[DI], 然后 SI=SI±1, DI=DI±1

Cmpsw

; 字串比较: DS:[SI]-ES:[DI], 然后 SI=SI±2, DI=DI±2

注意：串比较指令 CMPS 是源操作数（SI 指向的主存数据）减去目的操作数（DI 指向

的主存数据); 而比较指令 CMP 是目的操作数减去源操作数。

② 串扫描指令 SCAS 用 AL 或 AX 内容减去目的数据串, 以比较两者间关系。

scasb

；字节串扫描：AL- ES：[DI]，然后DI=DI±1

scasw

; 字串扫描: AX-ES: [DI], 然后 DI=DI±2

(3) 重复前缀指令 REPE（或 REPZ）用在 CMPS 和 SCAS 指令前，利用计数器 CX 保存数据串长度，同时判断比较是否相等，可以理解为“当数据串没有结束（CX≠0），并且串相等（ZF=1），则继续比较”。

repe|repz

; 每执行一次串指令, CX 减 1 ; 只要 CX=0 或 ZF=0 , 重复执行结束

(4) 重复前缀指令 REPNE（或 REPNZ）也用在 CMPS 和 SCAS 指令前，利用计数器 CX 保存数据串长度，同时判断比较是否不相等，可以理解为“当数据串没有结束（CX≠0），并且串不相等（ZF=0），则继续比较”。

repne|repnz

; 每执行一次串指令, CX 减 1 ; 只要 CX=0 或 ZF=1 , 重复执行结束

重复执行结束的条件是“或”的关系，只要满足条件之一就可以。所以指令执行完成，可能数据串没有比较完，也可能数据串已经比较完，编程时需要区分。

注意，在执行串操作指令前，重复前缀指令先判断 CX 是否为0，为0结束（所以，如果初始化 CX 为0，将不会重复操作）；否则进行减1操作，并执行串操作指令（LOOP 指令是先减1后判断是否为0）；最后判断ZF标志是否符合继续循环的条件。图4-6总结了重复前缀作用下的串操作流程。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/7c0830bc6e260d2c8ed0e37558db30139302b5e23b4bea4faaa6cd12d7f77ae2.jpg)  
图4-6 重复串操作的流程图

【例4.13】比较数据段两个等长字符串是否相同，相同显示 Y，不同显示 N。

；数据段

```txt
string1 db 'Equal or not'  
string2 db 'Equal or not'  
; 代码段  
mov ax, ds  
mov es, ax  
mov cx, lengthof string1  
mov si, offset string1  
mov di, offset string2  
cld  
repz cmpsb  
jnz unmat  
mov dl, 'y'  
jmp output  
unmat: mov dl, 'n'  
output: mov ah, 2  
int 21h
```

指令“REPZ CMPSB”结束重复执行的情况有两种。

(1) 出现不相等的字符, ZF=0。  
(2) 比较完所有字符,  $\mathrm{CX} = 0$  。在这种情况下, 对最后比较的一对字符又有两种可能:  
最后一个字符不等，ZF=0;  
最后一个字符相等，ZF=1，也就是两个字符串相同。

所以，重复比较结束后，指令JNE的条件成立（ZF=0）表示字符串不相等。

本例字符串长度为 12（包括其中的空格字符），比较的两个字符串第 1 个字符相同、第 2 个字符不相同，根据串操作流程图 4-4，结束重复执行时 CX=10。

如果不使用重复前缀，需要编写成循环程序结构，如下：

```txt
again: cmpsb ;比较两个字符 jnz unmat ;出现不同的字符，转移到unmat，设置FFH标记 loop again ;进行下一个字符的比较
```

【例4.14】在字符串中查找“空格”字符。

假设该字符串在附加段, 首地址由 STRING 指示, 具有 COUNT 字节。字符串不含空格,则继续执行, 包含空格, 则转到 FOUND 执行。代码段部分如下:

```txt
mov di, offset string  
mov al,  
mov cx, count  
cld  
repnz scasb ; 搜索  
je found ; 发现空格，ZF=1，转移到found  
… ; 不含空格，则继续执行
```

# 4.4 子程序设计

当程序功能相对复杂, 所有的语句序列均写到一起时, 程序结构将显得零乱; 特别是由

于汇编语言的语句功能简单, 源程序更显得冗长。这将降低程序的可阅读性和可维护性。为了简化问题, 实际编程时我们常把功能相对独立的程序段单独编写和调试, 作为一个相对独立的模块供程序使用, 这就是子程序。子程序可以实现源程序的模块化, 简化源程序结构。而当这个子程序被多次使用时, 子程序还可以使模块得到复用, 进而提高编程效率。

# 4.4.1 过程定义伪指令

汇编语言的子程序（Subroutine）相当于高级语言的过程和函数。在汇编语言中，子程序是过程（Procedure）的一种，是具有一个唯一的子程序名的程序段。过程的定义由一对过程伪指令 PROC 和 ENDP 来完成，其格式为：

过程名 proc[near/far]

过程体

过程名 endp

其中, 过程名 (子程序名) 为符合语法的标识符, 同一源程序中该名字应是唯一的。过程属性可为 NEAR 或 FAR。NEAR 属性的过程只能被相同代码段的其他程序调用, 为段内近调用; 属性为 FAR 的过程可以被相同或不同代码段的程序调用, 为段间远调用。

对简化段定义格式，在微型、小型和紧凑存储模型下，过程的默认属性为 NEAR；在中型、大型和巨型存储模型下，过程的默认属性为 FAR。对完整段定义格式，过程的默认属性为 NEAR。当然，用户可以在过程定义时用 NEAR 或 FAR 改变默认属性。

子程序的调用与返回是由指令CALL和RET来完成的，其格式参考第2章相应介绍。注意，为保证过程的正确调用与返回，除定义时需正确选择属性外，还应该注意子程序运行期间的堆栈状态，保持堆栈平衡。当发生过程调用时，CALL指令的功能之一是将返回地址压入堆栈；当过程返回时，RET则直接从当前栈顶取内容作为返回地址；而过程中可能还有其他指令涉及堆栈操作。因此，要保证RET指令执行前堆栈栈顶的内容刚好是过程返回的地址，即相应CALL指令压栈的内容，否则将造成不可预测的错误。所以，过程中对堆栈的操作应特别小心。

进行过程设计时, 必须注意寄存器的保护和恢复。过程体中一般要使用寄存器, 除了要带回结果的寄存器（返回参数）外, 希望过程的执行不改变其他寄存器的内容, 即避免过程的副作用。处理器中可用的寄存器数量有限 (8086 CPU 只有 8 个通用寄存器), 如果要使用某些寄存器, 但不能改变其原来的内容, 解决这个矛盾常见的方法是在过程开始部分先将要修改内容的寄存器顺序压栈 (不包括返回值寄存器), 在过程最后返回调用程序之前, 再将这些寄存器内容逆序弹出。

子程序应安排在代码段的主程序之外，最好放在主程序执行终止后的位置（返回操作系统后、汇编结束 END 伪指令前），也可以放在主程序开始执行之前的位置。

例如，实现回车、换行功能的子程序，过程定义如下：

```txt
dpcrlf proc ；具有默认属性的过程push ax ；保护寄存器：顺序压入堆栈push dx mov dl,0dh ；回车控制字符为0DHmov ah,2int 21h
```

```txt
mov dl, 0ah ; 换行控制字符为0AH  
mov ah, 2  
int 21h  
pop dx ; 恢复寄存器：逆序弹出堆栈  
pop ax  
ret ; 子程序返回  
dpcrlf endp ; 过程结束
```

【例4.15】编制一个过程, 把 AL 寄存器的二进制数用十六进制形式显示在屏幕上。

分析：AL 中 8 位二进制数对应 2 位十六进制数，先转换高 4 位成 ASCII 码并显示，然后转换低 4 位并显示。将 1 位十六进制数转换为 ASCII 码的原理参见第 2 章例 2.46。屏幕显示采用 02 号 DOS 功能调用。

```txt
aldisp proc ;实现AL内容的显示push ax ;过程中使用了AX，CX和DXpush cxpush dxpush ax ;暂存AXmov dl, al ;转换AL的高4位mov cl, 4shr dl, clor dl, 30h ;AL高4位变成3cmp dl, 39hjbe aldisp1add dl,7 ;是0AH～0FH，其ASCII码还要加上7  
aldisp1: mov ah,2 ;显示int 21hpop dx ;恢复原AX值到DXand dl,0fh ;转换AL的低4位or dl, 30hcmp dl, 39hjbe aldisp2add dl,7  
aldisp2: mov ah,2 ;显示int 21hpop dx pop cxpop axret ;过程返回  
aldisp endp
```

下面将其运用到例4.8中，实现排序后数据的显示。调用程序段应位于外循环后、返回 DOS 前。而上述过程定义应放在主程序最后，END 语句之前，或者在.CODE 语句后、.STARTUP 语句前。

```txt
;主程序，同例4.8源程序 loop outlp ;外循环尾 mov bx, offset array ;调用程序段开始 mov cx, count displp: mov al, [bx]
```

```txt
call aldisp ；调用显示过程  
mov dl,'，' ；显示一个逗号，以分隔两个数据  
mov ah,2  
int 21h  
inc bx  
loop displp ；调用程序段结束  
_exit0  
… ；过程定义，同例4.10源程序  
end
```

# 4.4.2 子程序的参数传递

主程序在调用子程序时，通常需要向其提供一些数据，对于子程序来说，就是入口参数（输入参数）；同样，子程序执行结束要返回给主程序必要的数据，这就是子程序的出口参数（输出参数）。主程序与子程序间通过参数传递建立联系，相互配合共同完成处理工作。

传递参数的多少反映程序模块间的耦合程度。根据实际情况，子程序可以只有入口参数或只有出口参数，也可以入口参数和出口参数都有。汇编语言中参数传递可通过寄存器、变量或堆栈来实现，参数的具体内容可以是数据本身（传数值），也可以是数据的存储地址（传地址）。

由于子程序相对独立、需要传递参数、具有多种参数传递方法，因此在过程定义时，加上适当的注释是有必要的。完整的注释应该包括子程序的功能、入口参数和出口参数等。

# 1. 用寄存器传递参数

采用寄存器传递参数是把参数存于约定的寄存器中，这种方法简单易行，经常采用。前面例4.10就利用了 AL 寄存器传递入口参数，该例没有出口参数；02号 DOS 功能调用也采用了 DL 传递欲显示字符的 ASCII 码；这两者都是利用寄存器直接传送数据本身。

【例4.16a】设 ARRAY 是 10 个元素的数组, 每个元素是 8 位数据。试用子程序计算数组元素的校验和, 并将结果存入变量 RESULT 中。所谓 “校验和”, 是指不记进位的累加, 常用于检查信息的正确性。

分析：子程序完成元素求和，主程序需要向它提供入口参数，使得子程序能够访问数组元素。

子程序需要回送求和结果这个出口参数。本例采用寄存器传递参数。

由于数组元素较多，直接用寄存器传送元素有困难，但是元素在主存中是顺序存放的，所以选用寄存器 DS 和 BX 传入数组首地址，用计数器 CX 传入数组元素个数。一个输出参数可以用累加器 AL 传出。这样，主程序设置好入口参数后调用子程序 checksuma，最后将结果送入指定单元。子程序首先保护寄存器，然后通过入口参数完成简单的循环累加，并在 AL 中得到校验和作为出口参数。

```txt
. modelsmall
. stack
. data
count equ 10
array db 12h,25h,0f0h,0a3h,3,68h,71h,0cah,0ffh,90h
result db ?
```

```asm
.code
		startup ；设置入口参数（含有DS←数组的段地址）
mov bx, offset array ; bx←数组的偏移地址
mov cx, count ; cx←数组的元素个数
call checksuma ; 调用求和过程
mov result, al ; 处理出口参数
		exit 0 ; 计算字节校验和的通用过程
		; 入口参数：DS:BX=数组的段地址：偏移地址，CX=元素个数
		; 出口参数：AL=校验和
		; 说明：除 AX/BX/CX 外，不影响其他寄存器
checksuma proc
		xor al, al ; 累加器清θ
suma:
		add al, [bx] ; 求和
		inc bx ; 指向下一字节
		loop suma
ret
checksuma endp
end
```

通用寄存器个数有限, 能直接传送数据的个数较少。而这种采用寄存器传送存储地址的方法在参数传递中常常运用, 可以传递较多的数据。09号 DOS 功能调用的入口参数就采用了 DS:DX 指示显示信息串。采用寄存器传递参数时, 注意带有出口参数的寄存器不能保护和恢复, 带有入口参数的寄存器可以保护也可以不保护。DOS 功能调用没有保护带入口参数的寄存器, 如反映功能号的 AX、09号调用的偏移地址 DX 等。

# 2. 用变量传递参数

主程序与被调用过程直接用同一个变量名访问传递的参数, 就是利用变量传递参数。如果调用程序与被调用程序在同一个源程序文件中, 只要设置好数据段寄存器 DS, 则子程序与主程序访问变量的形式相同, 即它们共享数据段的变量。调用程序与被调用程序不在同一个源文件中, 必须利用 PUBLIC/EXTERNAL 进行声明, 才能用变量传递参数 (详见 5.3 节)。

【例4.16b】对例4.16a 问题, 现在用变量传递参数、计算数组元素的校验和。

分析：采用变量传递参数，本例是共用 COUNT、ARRAY 和 RESULT 变量。主程序只要设置数据段 DS，就可以调用子程序；子程序直接采用变量名存取数组元素。

```txt
...
; 与例4.16a前半部分相同
.code
startup ; 含有DS←数组的段地址
call checksumb ; 调用求和过程
_exit 0
; 计算字节校验和
; 入口参数: array=数组名, count=元素个数, result=校验和存放的变量名
checksumb proc
push ax
push bx
push cx
xor al, al ; 累加器清0
mov bx, offset array ; BX←数组的偏移地址
```

```asm
mov cx, count ; CX←数组的元素个数  
sumb: add al, [bx] ; 求和  
inc bx  
loop sumb  
mov result, al ; 保存校验和  
pop cx  
pop bx  
pop ax  
ret  
checksumb endp  
end
```

利用变量传递参数, 过程的通用性较差。显然, 例4.16b 不如例4.16a 通用, 也不如例4.16a来得自然。然而, 在多个程序段间, 尤其在不同的程序模块间, 利用全局变量共享数据也是一种常见的参数传递方法。

# 3. 用堆栈传递参数

上面用共享寄存器和变量（存储单元）的方法实现了参数传递；同样，可以通过共享堆栈区，即利用堆栈传递参数。主程序将子程序的入口参数压入堆栈，子程序从堆栈中取出参数；子程序将出口参数压入堆栈，主程序弹出堆栈取得它们。

高级语言进行函数调用时提供的参数, 实质也是利用堆栈传递的; 高级语言还利用堆栈创建局部变量。保存参数和局部变量的堆栈区域被称为堆栈帧 (Stack Frame), 函数调用时建立、返回后消失。但是, 高级语言中, 函数的返回值通常并不采用堆栈传递, 而是采用最常用的寄存器传递。下例中, 入口参数采用堆栈传递, 出口参数采用寄存器传递。

【例4.16c】对例4.16a 问题，现在用堆栈传递参数计算数组元素的校验和。

分析：通过堆栈传递参数，主程序将数组的偏移地址和元素个数压入堆栈，然后调用子程序；子程序通过BP寄存器，从堆栈相应位置取出参数（非栈顶数据），求和后，用AL返回结果。因为共用数据段，所以没有传递数据段基地址。本例利用堆栈传递入口参数，但出口参数仍利用寄存器传递。

```txt
... ;与例4.16a前半部分相同
.code
.startup
mov ax, offset array ;设置入口参数
push ax ;压入数组的偏移地址
mov ax, count
push ax ;压入数组的元素个数
call checksun ;调用求和过程
add sp, 4 ;主程序平衡堆栈
mov result, al ;保存校验和
 EXIT 0
;计算字节校验和的近过程
;入口参数：在堆栈压入数组的偏移地址和元素个数
;出口参数：AL=校验和
checksumc proc
push bp
```

```txt
mov bp, sp ; BP指向当前栈顶，用于取出入口参数push bx ；保护使用的BX和CX寄存器push cx mov bx,[bp+6] BX←SS：[BP+6]（数组的偏移地址）mov cx,[bp+4] CX←SS：[BP+4]（数组的元素个数）xor al, al累加器清0sumc: add al, [bx] 求和：AL←AL+DS：[BX]inc bx loop sumc pop cx 恢复寄存器pop bx ret checksumc endp end
```

上述程序执行过程中利用堆栈传递参数，如图4-7所示。

进入子程序后, 设置基址指针 BP 等于当前堆栈指针 SP,这样利用 BP 相对寻址（默认采用堆栈段 SS）可以存取堆栈段中的数据。主程序压入了 2 个参数, 使用了堆栈区的 4 字节;为了保持堆栈的平衡, 主程序在调用 CALL 指令后用一条 “ADD SP, 4” 指令平衡堆栈。平衡堆栈也可以利用子程序来实现, 则返回指令采用 “RET 4”, 使 SP 加 4 。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/deaafa92413211f0cb01f05e6fc655ba1971450b4f623986af66274e514f8d02.jpg)  
图4-7 例4.16c的堆栈区

由此可见，由于堆栈采用“先进后出”原则存取，而且返回地址和保护的寄存器等也要存于堆栈，因此，用堆栈传递参数时，要时刻注意堆栈的分配情况，保证参数的正确存取及子程序的正确返回。

# 4.4.3 子程序的嵌套、递归和重入

与高级语言类似, 子程序也允许嵌套, 满足一定条件的子程序还可以实现递归和重入。

# 1. 子程序的嵌套

子程序内包含有子程序的调用就是子程序嵌套。嵌套深度（即嵌套的层次数）逻辑上没有限制，但由于子程序的调用需要在堆栈中保存返回地址及寄存器等数据，因此实际上受限于开设的堆栈空间。嵌套子程序的设计并没有什么特殊要求，除子程序的调用和返回应正确使用CALL和RET指令外，还要注意寄存器的保存与恢复，以避免各层子程序之间因寄存器使用冲突而出错。

在例4.15过程中有两段程序一样，我们可以写成过程，形成过程（子程序）嵌套。

```txt
aldisp proc ;显示AL中的2位十六进制数 push ax 保护入口参数 push cx push ax 暂存数据 mov cl,4 shr al,cl ；转换AL的高4位 call htoasc 子程序调用（嵌套）
```

```txt
pop ax ;转换AL的低4位  
call htoasc ;子程序调用（嵌套）  
pop cx  
pop ax  
ret ;子程序返回  
aldisp endp;  
htoasc proc ;将AL低4位表达的1位十六进制数转换为ASCII写  
push ax ;保护入口参数  
push bx  
push dx  
mov bx, offsetascii ;BX指向ASCII码表  
and al, 0fh ;取得1位十六进制数  
xlatascii ;换码：AL←CS：[BX+AL]，注意数据在代码段CS  
mov dl, al ;显示  
mov ah,2  
int 21h  
pop dx  
pop bx  
pop ax  
ret ;子程序的数据区  
ascii db 30h, 31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h, 39h  
db 41h, 42h, 43h, 44h, 45h, 46h  
htoasc endp
```

本例利用换码方法实现1位十六进制数转换为 ASCII 码，需要一个按  $0 \sim 9$  和 A～F 原排列的 ASCII 码表。这个数码表只提供给该子程序使用，是该子程序的局部数据，所以设置在代码段的子程序中。此时，子程序应该采用 CS 寻址这些数据。于是，又需要利用换码指令 XLAT 的另一种助记格式。这里写出指向缓冲区的变量名，MASM 会自动加上代码段首缀“CS:”。串操作 MOVS、LODS 和 CMPS 指令也可以这样使用，以便使用段超越前缀

# 2. 子程序的递归

当子程序直接或间接地嵌套调用自身时称为递归调用, 含有递归调用的子程序称为递子程序。递归子程序的设计必须保证每次调用都不破坏以前调用时所用的参数和中间结果因此将调用的输入参数、寄存器内容和中间结果都存放在堆栈中。递归子程序必须采用寄存器或堆栈传递参数, 递归深度受堆栈空间的限制。

递归子程序对应于数学上对函数的递归定义, 往往能设计出效率较高的程序, 可完成当复杂的计算。下面以阶乘函数为例说明递归子程序的设计方法。

【例4.17】编制计算  $N! = N \times (N - 1) \times (N - 2) \times \dots \times 2 \times 1$  （ $N \geqslant 0$ ）的程序。

分析：已知递归定义  $N! = \begin{cases} N \times (N - 1)! & N > 0 \\ 1 & N = 0 \end{cases}$ ，因此求  $N!$  可以设计成输入参数为  $N$  递归子程序，每次递归调用的输入参数递减1。如果  $N > 0$ ，则由当前参数  $N$  乘以递归子程返回值得到本层返回值；如果递归参数  $N = 0$ ，得到返回值为1。递归子程序的执行过程中频繁存取堆栈，如求3! 的堆栈最满的情况如图4-8所示。

```asm
;数据段  
n dw 3  
result dw ?  
;  
mov bx, n  
push bx  
call fact  
pop result  
;  
fact proc ; 计算n!的近过程  
push ax ; 入口参数压入n  
push bp ; 出口参数：弹出n！  
mov bp, sp  
mov ax, [bp+6]  
cmp ax, 0  
jne fact1  
inc ax  
jmp fact2  
fact1: dec ax  
push ax  
call fact  
pop ax  
mul word ptr[bp+6]  
mov [bp+6], ax  
pop bp  
pop ax  
ret  
fact endp
```

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/01058a88dab7d1eb1d3754d2f1123de2750f6afeeffa2d410cc5daa02a266b62.jpg)  
图4-8 例4.17的堆栈区

由于采用16位量表示阶乘，因此本程序只能计算8以内的阶乘。

# 3. 子程序的重入

子程序的重入是指子程序被中断后又被中断服务程序所调用, 能够重入的子程序称为可重入子程序。在子程序中, 注意利用寄存器和堆栈传递参数和存放临时数据, 而不要使用固定的存储单元 (变量), 就能够实现重入。子程序的重入性在采用中断与外设交换信息的系统中是重要的, 这样中断服务程序就可以调用这些可重入子程序而不致发生错误。遗憾的是, DOS 功能调用却是不可重入的。

子程序的重入不同于子程序的递归。重入是被动的进入，而递归是主动的进入；重入的调用间往往没有关系，而递归的调用间却是密切相关的。递归子程序也是可重入子程序。

# 4.4.4 子程序的应用

程序开发中，子程序是经常采用的方法。本节再举几个比较复杂的子程序实例。

【例4.18】从键盘输入有符号十进制数的子程序。

分析：子程序从键盘输入一个有符号十进制数。负数用“-”引导，正数直接输入或用“+”引导。子程序还包含将 ASCII 码转换为二进制数的过程，其算法如下：

(1) 判断输入正数还是负数, 并用一个寄存器记录下来。  
(2) 输入  $0 \sim 9$  数字 (ASCII 码), 并减  $30 \mathrm{H}$  转换为二进制数。  
(3) 将前面输入的数值乘10，并与刚输入的数字相加得到新的数值。  
(4) 重复②、③步, 直到输入一个非数字字符结束。  
(5) 如果是负数进行求补, 转换成补码, 否则直接将数值保存。

本例采用16位寄存器表达结果数值，所以输入的数据范围是+327677～-32768（注意未处理超出范围的情况），但该算法适合更大范围的数据输入。

子程序的出口参数用寄存器 AX 传递。主程序调用该子程序输入 10 个数据。

```txt
count =10  
array dw count dup(0)  
；代码段：主程序  
mov cx, count  
mov bx, offset array  
again: call read ;调用子程序，输入一个数据  
mov [bx], ax ;将出口参数存放到数据缓冲区  
inc bx  
inc bx  
call dpcrlf ;调用子程序，光标回车换行以便输入下一个数据  
loop again  
;  
read proc ;输入十进制数的通用子程序：read  
push bx ;出口参数：ax=补码表示的二进制数值  
push cx ;说明：负数用“-”引导，数据范围是+32767～-3200  
push dx  
xor bx, bx ;BX保存结果  
xor cx, cx ;CX为正负标志，θ为正，1为负  
mov ah, 1 ;输入一个字符  
int 21h  
cmp al,'+';是“+”，继续输入字符  
jz read1  
cmp al,'-' ;是“-”，设置-1标志  
jnz read2  
mov cx,-1  
mov ah, 1 ;继续输入字符  
int 21h  
cmp al,'0';不是0~9之间的字符，则输入数据结束  
jb read3  
cmp al,'9'  
ja read3  
sub al, 30h ;是0~9之间的字符，则转换为二进制数  
shl bx, 1 ;利用移位指令，实现数值乘10：BX←BX×10
```

```asm
add bx, dx  
;  
mov ah, 0  
add bx, ax ;已输入数值乘10后，与新输入数值相加  
jmp read1 ;继续输入字符  
read3: cmp cx, 0 ;是负数，进行求补  
jz read4  
neg bx  
read4: mov ax, bx ;设置出口参数  
pop dx  
pop cx  
pop bx  
ret ;子程序返回  
read endl  
proc ;使光标回车换行的子程序  
push ax  
push dx  
mov ah, 2  
mov dl, 0dh  
int 21h  
mov ah, 2  
mov dl, 0ah  
int 21h  
pop dx  
pop ax  
ret  
endp
```

【例4.19】向显示器输出有符号十进制数的子程序。

分析：子程序在屏幕上显示一个有符号十进制数，负数用“-”引导。子程序还包含将二进制数转换为 ASCII 码的过程，其算法如下：

(1) 判断数据是零、正数或负数, 是零显示 “0” 退出。  
(2) 是负数, 显示 “-”, 求数据的绝对值。  
(3) 数据除以10，余数加  $30 \mathrm{H}$  转换为 ASCII 码压入堆栈。  
(4) 重复③步, 直到商为0结束。  
(5) 依次从堆栈弹出各位数字, 进行显示。

本例采用16位寄存器表达数据，所以只能显示+327677～-32768间的数值，但该算法适合更大范围的数据。

子程序的入口参数用共享变量 WTEMP 传递。主程序调用子程序显示 10 个数据。

```csv
; 数据段
array dw 1234, -1234, 0, 1, -1, 32767, -32768, 5678, -5678, 9000
count = ($ -array)/2
wtemp dw ?
; 代码段: 主程序
mov cx, count
mov bx, offset array
```

```asm
again: mov ax, [bx]  
mov wtemp, ax ；将入口参数存放到共享变量  
call write ；调用子程序，显示一个数据  
inc bx  
inc bx  
dpcrlf ；光标回车换行以便显示下一个数据  
loop again  
;  
write proc ；显示有符号十进制数的通用子程序：write  
push ax ；入口参数：共享变量wtemp  
push bx  
push dx  
mov ax, wtemp ；取出显示数据  
test ax, ax ；判断数据是零、正数或负数  
jnz write1  
mov dl, '0' ；是零，显示“0”后退出  
mov ah,2  
int 21h  
jmp write5  
write1: jns write2 ；是负数，显示“-”  
mov bx, ax ；AX数据暂存于BX  
mov dl, '-'  
mov ah,2  
int 21h  
mov ax, bx  
neg ax ；数据求补（绝对值）  
write2: mov bx, 10  
push bx ；10压入堆栈，作为退出标志  
cmp ax,0 ；数据（商）为零，转向显示  
jz write4  
sub dx, dx ；扩展被除数DX.AX  
div bx ；数据除以10：DX.AX÷10  
add dl, 30h ；余数（0~9）转换为ASCII码  
push dx ；数据各位先低位后高位压入堆栈  
jmp write3  
pop dx ；数据各位先高位后低位弹出堆栈  
cmp dl, 10 ；是结束标志10，则退出  
je write5  
mov ah,2 ；进行显示  
int 21h  
jmp write4  
pop dx  
pop bx  
pop ax  
ret ；子程序返回  
write endp
```

```txt
【例4.2 分析： 溢出，被加 制数表示数 表达累加和 -215，共216 子程序 据个数和数 从堆栈段相 口参数用奇 个数据，并 array dvmcount = mowmed dvm; mopu puc aad mo mean prpupupupupup upm oomxom mean1: mow ad ad in in lo mo
```

【例4.20】 计算有符号数平均值的子程序。

分析：子程序将16位有符号二进制数求和，然后除以数据个数，得到平均值。为了避免溢出，被加数要进行符号扩展，得到倍长数据（大小没有变化），然后求和。采用16位二进

制数表示数据个数，最大是  $2^{16}$ ，这样扩展到32位二进制数表达累加和，不再会出现溢出（考虑极端情况：数据全是  $-2^{15}$ ，共  $2^{16}$  个，求和结果是  $-2^{31}$ ，32位数据仍然可以表达）。

子程序的入口参数利用堆栈传递，主程序需要压入数据个数和数据缓冲区的偏移地址。子程序通过BP寄存器从堆栈段相应位置取出参数（非栈顶数据），子程序的出口参数用寄存器AX传递，如图4-9所示。主程序提供10个数据，并保存平均值。

![](https://cdn-mineru.openxlab.org.cn/result/2025-10-07/8ad04b94-5f42-467c-aef0-7cc493f07fc6/594308e13a2b3ec20b41cf64afe3630459bb13ce193a836c2d409cf8409f673f.jpg)  
图4-9 利用堆栈传递参数

```csv
;数据段
array dw 1234,-1234,0,1,-1,32767,-32768,5678,-5678,9000
count = ($-array)/2
wmed dw ? ;存放平均值
;代码段:主程序
mov ax, count
push ax ;压入数据个数
mov ax, offset array
push ax ;压入数据缓冲区的偏移地址
call mean ;调用子程序,求平均值
add sp, 4 ;平衡堆栈
mov wmed, ax ;保存出口参数(未保留余数部分)
;
mean proc ;计算16位有符号数平均值子程序: mean
push bp ;入口参数:顺序压入数据个数和数据缓冲区的偏移地址
mov bp, sp ;出口参数:AX=平均值
push bx ;保护寄存器
push cx
push dx
push si
push di
mov bx, [bp+4] ;从堆栈中取出缓冲区的偏移地址→BX
mov cx, [bp+6] ;从堆栈中取出数据个数→CX(见图4-9)
xor si, si ;SI保存求和的低16位值
mov di, si ;DI保存求和的高16位值
mov ax, [bx] ;取出一个数据→AX
cwd ;符号扩展→DX
add si, ax ;求和低16位
adc di, dx ;求和高16位
inc bx ;指向下一个数据
inc bx
loop mean1 ;循环
mov ax, si ;累加和转存到DX.AX
mov dx, di
```

<table><tr><td>mov</td><td>cx, [bp+6]</td><td>; 数据个数在 CX</td></tr><tr><td>idiv</td><td>cx</td><td>; 有符号数除法，求的平均值在 AX 中（余数在 DX 中）</td></tr><tr><td>pop</td><td>di</td><td>; 恢复寄存器</td></tr><tr><td>pop</td><td>si</td><td></td></tr><tr><td>pop</td><td>dx</td><td></td></tr><tr><td>pop</td><td>cx</td><td></td></tr><tr><td>pop</td><td>bx</td><td></td></tr><tr><td>pop</td><td>bp</td><td></td></tr><tr><td>ret</td><td></td><td></td></tr><tr><td>mean</td><td>endp</td><td></td></tr></table>

# 习题4

4.1 例4.1使用换码指令XLAT实现查表，换用若干其他指令实现同样功能。  
4.2 参考例4.2（和例2.46）将保存于DX.AX寄存器对的32位数据进行算术右移一位。  
4.3 编制一个程序, 将 AX 寄存器中的 16 位数连续 4 位分成一组, 共 4 组, 然后把这 4 组数分别放在 AL、BL、CL 和 DL 寄存器中。  
4.4 编写一个程序，把从键盘输入的一个小写字母用大写字母显示出来。  
4.5 已知用于LED数码管显示的代码表为：

LEDTABLE DB 0C0H, 0F9H, 0A4H, 0B0H, 99H, 92H, 82H, 0F8H

DB 80H, 90H, 88H, 83H, 0C6H, 0C1H, 86H, 8EH

依次表示  $0 \sim 9$  和  $\mathrm{A} \sim \mathrm{F}$  这16个数码的显示代码。现编写一个程序, 实现将 lednum 中的一个数字  $(0 \sim 9$  和  $\mathrm{A} \sim \mathrm{F})$  转换成对应的 LED 显示代码。

4.6 编制一个程序, 把变量 bufX 和 bufY 中较大者存入 bufZ; 若两者相等, 则把其中之一存入 bufZ 中。假设变量存放的是 8 位无符号数。  
4.7 设变量 bufX 为有符号 16 位数, 请将它的符号状态保存在 signX, 即: 如果 X 大于等于 0 , 保存 0 ; 如果 X 小于 0 , 保存 -1 (FFH)。编写该程序。  
4.8 bufX、bufY 和 bufZ 是 3 个有符号十六进制数，编写一个比较相等关系的程序。

(1) 如果这3个数都不相等, 则显示  $0$  。  
(2) 如果这3个数中有两个数相等, 则显示1。  
(3) 如果这3个数都相等, 则显示  $2 。$  
例4.9 内、外循环次数共是多少？如果要求按从大到小排序，程序如何修改？

4.10 串操作指令常要利用循环结构，现在不用串操作指令，如何实现字符串 stringl 内容传送到字符串 string2？字符长度为 count。

4.11 不用串操作指令，求主存0040H:0开始的一个64 KB物理段中共有多少个空格？

4.12 编程实现，把输入的一个字符用二进制形式（0/1）显示出其 ASCII 代码值。

4.13 编写程序，要求从键盘接收一个数 bellN（0~9），然后响铃 bellN 次。

4.14 编写程序，将一个包含有20个有符号数据的数组 arrayM 分成两个数组：正数数组 arrayP 和负数数组 arrayN，并分别把这两个数组中的数据个数显示出来。  
4.15 编写计算100个正整数之和的程序。如果和不超过16位字的范围（65535），则保存其和到wordsum，如超过，则显示“overflow”。  
4.16 编写程序，判断主存0070H:0开始的1KB中有无字符串“DEBUG”。这是一个字符串

包含的问题，可以采用逐个向后比较的简单算法。

4.17 编写程序, 把一个 16 位无符号二进制数转换成用 8421BCD 码表示的 5 位十进制数。

转换算法可以是：用二进制数除以10000，商为“万位”，再用余数除以1000，得到“千位”；依次用余数除以100、10和1，得到“百位”、“十位”和“个位”。

4.18 以 MOVSW 指令为例，说明串操作指令的寻址特点，并用 MOV 和 ADD 等指令实现 MOVSD 的功能（假设  $\mathrm{DF} = 0$ ）。

4.19 已知数据段  $500 \mathrm{H} \sim 600 \mathrm{H}$  处存放了一个字符串, 说明下列程序段执行后的结果。

```txt
mov si, 600h  
mov di, 601h  
mov ax, ds  
mov es, ax  
mov cx, 256  
std  
rep movsb
```

4.20 说明下列程序段的功能。

```asm
cld mov ax, 0fefh mov cx, 5 mov bx, 3000h mov es, bx mov di, 2000h rep stosw
```

4.21 使用“直接写屏”方法编程，将 DOS 标准显示模式下的屏幕内容向上滚动一行，最后一行填充字母 A。这需要将屏幕第 2 行（开始于  $1 \times 2 \times 80$  的偏移地址）内容传送到第一行，第 3 行传送到第 2 行……最后一行（开始于  $24 \times 2 \times 80$  的偏移地址）传送完后，填充字符 A。  
4.22 过程定义的一般格式是怎样的?子程序入口为什么常有 PUSH 指令、出口为什么有 POP 指令? 下面的程序段有什么不妥吗? 若有, 请改正。

```txt
crazy proc push ax  
xor ax, ax  
xor dx, dx  
again: add ax, [bx]  
adc dx, 0  
inc bx  
inc bx  
loop again  
ret  
endp crazy
```

4.23 子程序的参数传递有哪些方法？请简单比较。  
4.24 采用堆栈传递参数的一般方法是什么？为什么应该特别注意堆栈平衡问题？  
4.25 什么是子程序的嵌套、递归和重入？  
4.26 将例4.7的大写字母转换为小写字母写成过程，利用 AL 作为入口参数、出口参数完成。  
4.27 请按如下子程序说明编写过程：

；子程序功能：把用 ASCII 码表示的 2 位十进制数转换为对应的二进制数

$\therefore$  入口参数:  ${DH} =$  十位数的 ASCII 码,  ${DL} =$  个位数的 ASCII 码

出口参数:  ${AL}$  =对应的二进制数

4.28 编写一个子程序, 根据入口参数 AL 为 0、1、2, 分别实现大写字母转换成小写字母转换成大写或大小写字母互换。欲转换的字符串在 string 中, 用 0 表示结束。  
4.29 编写一个子程序, 把一个16位二进制数用十六进制形式在屏幕上显示出来, 分别如下3种参数传递方法, 并用一个主程序验证它。  
（1）采用AX寄存器传递这个16位二进制数。  
（2）采用堆栈方法传递这个16位二进制数。  
（3）采用wordTEMP变量传递这个16位二进制数。  
4.30 设有一个数组存放学生的成绩（0～100），编写一个子程序，统计0～59分、60～69分、70～79分、80～89分、90～100分的人数，并分别存放到scoreE、scoreD、scoreC、scoreB及score单元中。编写一个主程序与之配合使用。  
4.31 编写一递归子程序，计算指数函数  $X^n$  的值。