# 第一章重点题目解析

## 1.14 简述PC的最低1MB主存空间的使用情况

**题目解析：**

根据教学内容，8086 CPU的地址线是20位的，最大可寻址空间为2²⁰B = 1MB，地址范围为00000H～FFFFFH。

整个1MB主存空间从低位地址到高位地址可分为4个区段：

### 1. 基本RAM区（00000H～9FFFFH）
- **容量**：共640KB
- **管理**：由DOS进行管理
- **用途**：操作系统占用一部分低地址空间，其他向用户程序开放
- **特点**：这是用户程序可以使用的常规主存区域

### 2. 保留RAM区（A0000H～BFFFFH）
- **容量**：共128KB
- **用途**：系统安排的"显示缓冲存储区"
- **支持**：由显卡上的RAM芯片提供支持
- **功能**：用于存放屏幕显示信息
- **注意**：这部分地址空间实际上没有全部使用

### 3. 扩展ROM区（C0000H～DFFFFH）
- **容量**：共128KB
- **支持**：由I/O接口卡上的ROM芯片提供支持
- **用途**：为系统不直接提供支持的外设安排设备驱动程序
- **扩展**：用户固化的ROM程序可安排在这一区段
- **确认**：系统的ROM-BIOS会对它进行确认和连接

### 4. 系统ROM区（E0000H～FFFFFH）
- **容量**：共128KB
- **占用**：由系统占用
- **主要功能**：提供ROM-BIOS程序
- **BIOS作用**：
  - 驱动输入、输出设备
  - 负责系统的上电检测
  - 磁盘DOS引导等初始化操作
- **其他功能**：
  - 微机CMOS设置程序
  - 供输出使用的字符/图符点阵信息

### 术语说明：
- **常规主存**：最低640KB的系统RAM区
- **上位主存区（UMA）**：其后384KB主存
- **实方式主存**：整个1MB空间在所有80×86微处理器的PC上都一样

### 高级内存管理：
对于80286的16MB主存、IA-32微处理器的4GB空间：
- 1MB后的64KB可作为高端主存区HMA使用
- 最后的64KB复制ROM-BIOS
- 其他主存空间作为RAM区域使用，称为扩展主存（ExtendedMemory）
- 扩展主存只能在保护方式使用
- 遵循扩展主存使用规范XMS

---

## 1.17 指令指针寄存器IP的作用是什么？

**题目解析：**

### 基本作用
指令指针寄存器IP（Instruction Pointer）是8086处理器中的一个专用寄存器，用于**表示将要执行的指令在主存中的位置**。

### 主要功能

1. **指令定位**
   - 程序由指令组成，指令存放在主存储器中
   - IP保存下一条要执行指令的存储器地址
   - 处理器根据IP找到要执行的指令

2. **自动增量能力**
   - IP是专用寄存器，具有自动增量的能力
   - 处理器执行完一条指令后，IP中的值就加上该指令的字节数
   - 从而指向下一条指令，实现程序的顺序执行

3. **程序控制流**
   - 顺序执行时：IP自动增加指向下一条指令
   - 需要跳转时：通过控制转移指令修改IP
   - IP的改变将引起程序转移到指定的指令执行

### 使用限制

1. **不能直接赋值**
   - IP寄存器不能像通用寄存器那样直接赋值修改
   - 必须通过特定方式来改变

2. **修改方式**
   - **控制转移指令**：跳转（JMP）、分支（JCC）、调用（CALL）、返回（RET）指令
   - **中断处理**：出现中断或异常时由处理器自动修改
   - **处理器赋值**：在特定情况下由处理器直接设置

### 在机器周期中的作用
在取指阶段：
- 指令在存储器中的地址由代码段寄存器CS和指令指针寄存器IP共同提供
- 地址加法器将CS左移4位加上IP得到20位存储器物理地址
- 总线接口单元BIU负责从存储器取出指令代码

### 重要特性
- **16位寄存器**：IP是16位的，可以寻址64KB的代码段
- **与CS配合**：IP必须与代码段寄存器CS配合使用才能形成物理地址
- **关键性**：IP是程序执行的核心寄存器，控制着程序的执行流程

---

## 1.18 字和双字在存储器中如何存放，什么是"小端方式"？对字和双字存储单元，什么是它们的对齐地址？为什么要对齐地址？

**题目解析：**

### 数据存储格式

#### 1. 基本存储单位
- **位（bit）**：计算机存储信息的基本单位，1位存储一个二进制数0或1
- **字节（Byte）**：8个二进制位组成1字节，位编号D₇～D₀（从右向左）
- **字（Word）**：8086和80286为16位，由2字节组成，位编号D₁₅～D₀
- **双字（Double Word）**：80386和80486为32位，由4字节组成，位编号D₃₁～D₀

#### 2. "小端方式"（Little Endian）
小端方式是8086处理器采用的数据存储格式：

**定义**：多字节数据中，**低字节存入低地址，高字节存入高地址**。

**示例**：
- 字单元地址0002H存放数据1234H：
  - 0002H单元：34H（低字节）
  - 0003H单元：12H（高字节）
  - 表示为：[0002H] = 1234H

- 双字单元存放数据8561234H：
  - 0002H单元：34H（最低字节）
  - 0003H单元：12H
  - 0004H单元：56H
  - 0005H单元：85H（最高字节）
  - 表示为：[0002H] = 8561234H

### 地址对齐

#### 1. 对齐地址的定义
**地址边界对齐**：对于n字节（n = 2²，即2、4、8、16…字节）的数据，如果起始于能够被n整除的存储器地址位置（模n地址），则称地址边界对齐。

#### 2. 不同数据的对齐要求
- **字数据（2字节）**：起始偶地址（模2地址，地址最低1位为0）
- **双字数据（4字节）**：起始模4地址（地址最低2位为00）
- **4字数据（8字节）**：起始模8地址（地址最低3位为000）

#### 3. 对齐地址的表示
- **字对齐**：地址xxx₀b（二进制）或xxxH（十六进制中最低位为0、2、4、6、8、A、C、E）
- **双字对齐**：地址xx00b（二进制）或xxH（十六进制中最低2位为00、04、08、0C等）

### 为什么要对齐地址？

#### 1. 性能考虑
- **对齐访问**：处理器可以用一次存储器访问操作完整读取数据
- **未对齐访问**：处理器需要多次访问存储器才能完整读取数据
- **性能差异**：未对齐访问的执行速度明显慢于对齐访问

#### 2. 硬件效率
- **总线宽度**：8086有16位数据总线，一次可以传送2字节
- **对齐优化**：字数据从偶地址开始时，一次总线传输即可完成
- **未对齐成本**：字数据从奇地址开始时，需要两次总线传输

#### 3. 访问示例
**对齐的字访问**（地址0002H）：
- 一次读取0002H和0003H两个字节
- 效率高，单周期完成

**未对齐的字访问**（地址0003H）：
- 第一次读取0003H，保存低字节
- 第二次读取0004H，获取高字节
- 组合成完整数据，效率低

### 8086的灵活性
- **允许不对齐**：8086处理器比较灵活，允许不对齐边界存放数据
- **性能建议**：为了获得更好的性能，建议进行地址边界对齐
- **现代处理器**：很多现代处理器要求数据存放必须对齐地址边界，否则会发生非法操作

---

## 1.19 什么是8086中的逻辑地址和物理地址？逻辑地址如何转换成物理地址？请将如下逻辑地址用物理地址表达（表达地址默认采用十六进制数）：

**(1) FFFF:0**
**(2) 40:17**
**(3) 2000:4500**
**(4) B821:4567**

**题目解析：**

### 基本概念

#### 1. 物理地址（Physical Address）
- **定义**：每个存储器单元的唯一的20位地址
- **范围**：00000H～FFFFFH（对应1MB存储空间）
- **作用**：唯一标识存储器中每个字节单元的位置
- **表示**：用20位二进制数或5位十六进制数表示

#### 2. 逻辑地址（Logical Address）
- **定义**：在8086内部和用户编程时采用的"段地址:偏移地址"形式
- **格式**：段基地址:段内偏移地址
- **组成**：
  - **段地址**：16位，说明逻辑段在主存中的起始位置
  - **偏移地址**：16位，说明主存单元距离段起始位置的偏移量

### 地址转换机制

#### 1. 段地址特征
- 8086规定段地址必须是**模16地址**，即xxxx0H形式
- 省略低4位的0后，段地址可以用16位数据表示
- 段地址通常保存在16位的段寄存器中

#### 2. 转换公式
**物理地址 = 段地址 × 16 + 偏移地址**
或者
**物理地址 = 段地址左移4位 + 偏移地址**

#### 3. 转换过程
1. 将16位段地址左移4位（相当于乘以16）
2. 加上16位偏移地址
3. 得到20位物理地址

### 题目计算

#### (1) FFFF:0
```
段地址：FFFFH
偏移地址：0000H

物理地址 = FFFFH × 16 + 0000H
         = FFFF0H + 0000H
         = FFFF0H
```

#### (2) 40:17
```
段地址：0040H
偏移地址：0017H

物理地址 = 0040H × 16 + 0017H
         = 0400H + 0017H
         = 0417H
```

#### (3) 2000:4500
```
段地址：2000H
偏移地址：4500H

物理地址 = 2000H × 16 + 4500H
         = 20000H + 4500H
         = 24500H
```

#### (4) B821:4567
```
段地址：B821H
偏移地址：4567H

物理地址 = B821H × 16 + 4567H
         = B8210H + 4567H
         = BC777H
```

### 重要特性

#### 1. 同一物理地址的多种表示
同一个物理地址可以有多个逻辑地址表示，这是因为：
- 段地址只要是指向同一个64KB段内的任何模16地址都可以
- 偏移地址相应调整即可指向同一物理地址

#### 2. 地址重叠示例
物理地址00417H可以用多种逻辑地址表示：
- 0040:0017H（题目中的计算结果）
- 0041:0007H（因为00410H + 0007H = 00417H）
- 0042:FFF7H（因为00420H + FFF7H = 00417H）

### 应用意义

#### 1. 内存分段管理
- 支持**分段管理**的内存结构
- 每个段最大不超过64KB（偏移地址16位的限制）
- 便于程序的模块化设计

#### 2. 段寄存器使用
- **CS:IP**：代码段，指向下一条要执行的指令
- **DS:EA**：数据段，指向数据操作数
- **SS:SP**：堆栈段，指向堆栈栈顶
- **ES:DI**：附加段，用于字符串操作等

---

## 1.20 8086有哪4种逻辑段？各种逻辑段分别是什么用途？

**题目解析：**

### 8086的4种逻辑段

8086处理器采用分段内存管理，设计了4种逻辑段，每种段都有特定的用途：

#### 1. 代码段（Code Segment）
**段寄存器**：CS（Code Segment）

**主要用途**：
- **存放程序指令序列**：程序的指令代码必须安排在代码段中
- **程序执行的基础**：处理器从代码段中取出指令并执行
- **指令指针配合**：CS存放代码段的段地址，IP指示代码段中指令的偏移地址
- **取指机制**：处理器利用CS:IP取得下一条要执行的指令

**特点**：
- 只读性质（从程序执行角度）
- 段大小不超过64KB
- 程序可以有多个代码段，但任一时刻只能有一个当前代码段

#### 2. 数据段（Data Segment）
**段寄存器**：DS（Data Segment）

**主要用途**：
- **存放程序数据**：存放当前运行程序所用的数据
- **默认数据段**：一般数据访问的默认段
- **操作数存储**：存储器中操作数的偏移地址由各种主存寻址方式得到
- **变量存储**：程序中定义的变量通常存放在数据段

**访问方式**：
- 默认段寄存器：DS
- 有效地址：由寻址方式计算得到
- 允许段超越：可以使用CS、ES、SS段替代

#### 3. 堆栈段（Stack Segment）
**段寄存器**：SS（Stack Segment）

**主要用途**：
- **确定堆栈区域**：确定程序使用的堆栈所在的主存区域
- **数据暂存**：调用子程序时暂存数据、传递参数、存放局部变量
- **后进先出操作**：支持堆栈的先进后出（FILO）/后进先出（LIFO）操作
- **栈顶管理**：SS存放堆栈段的段地址，SP指示堆栈栈顶的偏移地址

**操作特点**：
- **栈顶指针**：处理器利用SS:SP操作堆栈中的数据
- **自动管理**：堆栈操作指令会自动调整SP的值
- **特殊用途**：临时保存数据，过程调用和返回

#### 4. 附加段（Extra Segment）
**段寄存器**：ES（Extra Segment）

**主要用途**：
- **附加数据存储**：附加的数据段，也用于数据的保存
- **字符串操作**：串操作指令将附加段作为其目的操作数的存放区域
- **数据段扩展**：当数据段不够使用时的补充数据段
- **特殊用途**：某些特定指令必须使用附加段

**特殊规定**：
- **字符串操作目的区**：串操作的目的操作数必须在附加段中
- **不可替代**：在字符串操作中，附加段不能被其他段替代

### 段寄存器使用规定总结

| 访问存储器的方式 | 默认的段寄存器 | 可超越的段寄存器 | 偏移地址 |
|----------------|----------------|------------------|----------|
| 取指令 | CS | 无 | IP |
| 堆栈操作 | SS | 无 | SP |
| 一般数据访问 | DS | CS, ES, SS | EA |
| 串操作的源操作数 | DS | CS, ES, SS | SI |
| 串操作的目的操作数 | ES | 无 | DI |
| BP作为基址的寻址方式 | SS | CS, DS, ES | EA |

### 段超越前缀

当需要使用非默认段时，可以使用段超越前缀：
```assembly
cs:          ; 代码段超越，使用代码段的数据
ss:          ; 堆栈段超越，使用堆栈段的数据
ds:          ; 数据段超越，使用数据段的数据
es:          ; 附加段超越，使用附加段的数据
```

### 程序设计意义

#### 1. 模块化程序设计
- 符合程序的模块化思想
- 利于编写模块化结构的程序
- 不同类型的数据和代码分离管理

#### 2. 内存管理灵活性
- 各段可以重叠
- 段大小可以根据实际需要分配
- 支持紧凑的程序设计（所有段在一个64KB内）

#### 3. 数据安全
- 代码段保护（执行时只读）
- 堆栈段独立管理
- 数据分离提高程序可靠性

---

## 1.24 说明下列指令中源操作数的寻址方式？如果BX = 2000H，DI = 40H，给出DX的值或有效地址EA的值。

**(1) mov dx, [1234H]**
**(2) mov dx, 1234H**
**(3) mov dx, bx**
**(4) mov dx, [bx]**
**(5) mov dx, [bx+1234H]**
**(6) mov dx, [bx+di]**
**(7) mov dx, [bx+di+1234H]**

**题目解析：**

根据题目条件：BX = 2000H，DI = 0040H（注意：题目中DI = 40H，应该是0040H）

### (1) mov dx, [1234H]

**寻址方式**：直接寻址方式

**解析**：
- 指令中直接包含了有效地址1234H
- 默认使用数据段DS
- 物理地址 = DS × 16 + 1234H

**有效地址EA**：1234H

**结果**：DX ← DS:[1234H]，即DX等于数据段中偏移地址1234H处的内容

---

### (2) mov dx, 1234H

**寻址方式**：立即数寻址方式

**解析**：
- 操作数直接包含在指令中
- 立即数1234H紧跟在操作码之后
- 直接将数值传送到DX寄存器

**结果**：DX = 1234H

---

### (3) mov dx, bx

**寻址方式**：寄存器寻址方式

**解析**：
- 源操作数存放在CPU的内部寄存器BX中
- 不需要访问存储器，执行速度较快
- 16位寄存器传送

**结果**：DX = BX = 2000H

---

### (4) mov dx, [bx]

**寻址方式**：寄存器间接寻址方式

**解析**：
- 有效地址存放在寄存器BX中
- 默认使用数据段DS
- BX作为地址指针指向存储单元

**有效地址EA**：BX = 2000H

**结果**：DX ← DS:[2000H]，即DX等于数据段中偏移地址2000H处的内容

---

### (5) mov dx, [bx+1234H]

**寻址方式**：寄存器相对寻址方式

**解析**：
- 有效地址 = 寄存器内容 + 位移量
- EA = BX + 1234H
- 默认使用数据段DS

**有效地址EA**：BX + 1234H = 2000H + 1234H = 3234H

**结果**：DX ← DS:[3234H]，即DX等于数据段中偏移地址3234H处的内容

---

### (6) mov dx, [bx+di]

**寻址方式**：基址变址寻址方式

**解析**：
- 有效地址 = 基址寄存器 + 变址寄存器
- EA = BX + DI
- 基址寄存器BX默认使用数据段DS

**有效地址EA**：BX + DI = 2000H + 0040H = 2040H

**结果**：DX ← DS:[2040H]，即DX等于数据段中偏移地址2040H处的内容

---

### (7) mov dx, [bx+di+1234H]

**寻址方式**：相对基址变址寻址方式

**解析**：
- 有效地址 = 基址寄存器 + 变址寄存器 + 位移量
- EA = BX + DI + 1234H
- 基址寄存器BX默认使用数据段DS
- 位移量采用补码表示

**有效地址EA**：BX + DI + 1234H = 2000H + 0040H + 1234H = 3274H

**结果**：DX ← DS:[3274H]，即DX等于数据段中偏移地址3274H处的内容

---

### 总结表格

| 指令 | 寻址方式 | EA计算 | EA值 | DX结果 |
|------|----------|---------|------|---------|
| mov dx, [1234H] | 直接寻址 | 1234H | 1234H | DS:[1234H]的内容 |
| mov dx, 1234H | 立即数寻址 | 无 | 无 | 1234H |
| mov dx, bx | 寄存器寻址 | 无 | 无 | 2000H |
| mov dx, [bx] | 寄存器间接寻址 | BX | 2000H | DS:[2000H]的内容 |
| mov dx, [bx+1234H] | 寄存器相对寻址 | BX+1234H | 3234H | DS:[3234H]的内容 |
| mov dx, [bx+di] | 基址变址寻址 | BX+DI | 2040H | DS:[2040H]的内容 |
| mov dx, [bx+di+1234H] | 相对基址变址寻址 | BX+DI+1234H | 3274H | DS:[3274H]的内容 |

### 重要说明

1. **默认段寄存器**：以上存储器寻址方式（除立即数和寄存器寻址外）默认使用数据段DS
2. **段超越**：如果需要使用其他段，可以添加段超越前缀，如es:[bx]、cs:[1234H]等
3. **地址范围**：计算出的EA如果超过FFFFH，则取64K的模
4. **访问速度**：寄存器寻址最快，存储器寻址需要访问内存，相对较慢